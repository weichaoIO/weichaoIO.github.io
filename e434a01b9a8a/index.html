<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/my_icon.ico"><link rel="icon" href="/img/my_icon.ico"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="魏超"><meta name="keywords" content="魏超,weichao"><meta name="description" content="Reference  native-audio 源代码 OpenSL_ES_Specification_1.0.1.pdf    启动页  4段音频：  Hello：单词hello的音频，存放在hello_clip.h文件中 Android：单词Android的音频，存放在android_clip.h文件中 Sawtooth：代码生成的单锯齿波，存放在内存中 Embedded soundtrac"><meta property="og:type" content="article"><meta property="og:title" content="Android NDK sample 之 native-audio"><meta property="og:url" content="https://weichao.io/e434a01b9a8a/index.html"><meta property="og:site_name" content="『魏超』的 blog"><meta property="og:description" content="Reference  native-audio 源代码 OpenSL_ES_Specification_1.0.1.pdf    启动页  4段音频：  Hello：单词hello的音频，存放在hello_clip.h文件中 Android：单词Android的音频，存放在android_clip.h文件中 Sawtooth：代码生成的单锯齿波，存放在内存中 Embedded soundtrac"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/Android-NDK-sample-%E4%B9%8B-native-audio/Android-NDK-sample-%E4%B9%8B-native-audio1.png"><meta property="og:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/Android-NDK-sample-%E4%B9%8B-audio-echo/Android-NDK-sample-%E4%B9%8B-audio-echo2.png"><meta property="og:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/Android-NDK-sample-%E4%B9%8B-audio-echo/Android-NDK-sample-%E4%B9%8B-audio-echo3.png"><meta property="og:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/Android-NDK-sample-%E4%B9%8B-audio-echo/Android-NDK-sample-%E4%B9%8B-audio-echo4.png"><meta property="og:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/Android-NDK-sample-%E4%B9%8B-audio-echo/Android-NDK-sample-%E4%B9%8B-audio-echo5.png"><meta property="og:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/Android-NDK-sample-%E4%B9%8B-audio-echo/Android-NDK-sample-%E4%B9%8B-audio-echo6.png"><meta property="og:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/Android-NDK-sample-%E4%B9%8B-audio-echo/Android-NDK-sample-%E4%B9%8B-audio-echo7.png"><meta property="og:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/Android-NDK-sample-%E4%B9%8B-audio-echo/Android-NDK-sample-%E4%B9%8B-audio-echo8.png"><meta property="og:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/Android-NDK-sample-%E4%B9%8B-audio-echo/Android-NDK-sample-%E4%B9%8B-audio-echo9.png"><meta property="og:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/Android-NDK-sample-%E4%B9%8B-audio-echo/Android-NDK-sample-%E4%B9%8B-audio-echo10.png"><meta property="og:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/Android-NDK-sample-%E4%B9%8B-audio-echo/Android-NDK-sample-%E4%B9%8B-audio-echo11.png"><meta property="og:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/Android-NDK-sample-%E4%B9%8B-native-audio/Android-NDK-sample-%E4%B9%8B-native-audio2.png"><meta property="og:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/Android-NDK-sample-%E4%B9%8B-audio-echo/Android-NDK-sample-%E4%B9%8B-audio-echo12.png"><meta property="og:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/Android-NDK-sample-%E4%B9%8B-native-audio/Android-NDK-sample-%E4%B9%8B-native-audio3.jpg"><meta property="og:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/Android-NDK-sample-%E4%B9%8B-native-audio/Android-NDK-sample-%E4%B9%8B-native-audio4.jpg"><meta property="og:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/Android-NDK-sample-%E4%B9%8B-native-audio/Android-NDK-sample-%E4%B9%8B-native-audio5.jpg"><meta property="og:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/Android-NDK-sample-%E4%B9%8B-native-audio/Android-NDK-sample-%E4%B9%8B-native-audio6.jpg"><meta property="og:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/Android-NDK-sample-%E4%B9%8B-native-audio/Android-NDK-sample-%E4%B9%8B-native-audio7.jpg"><meta property="og:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/Android-NDK-sample-%E4%B9%8B-native-audio/Android-NDK-sample-%E4%B9%8B-native-audio8.jpg"><meta property="article:published_time" content="2021-08-12T08:28:54.000Z"><meta property="article:modified_time" content="2022-12-04T06:04:05.223Z"><meta property="article:author" content="魏超"><meta property="article:tag" content="魏超,weichao"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/Android-NDK-sample-%E4%B9%8B-native-audio/Android-NDK-sample-%E4%B9%8B-native-audio1.png"><title>Android NDK sample 之 native-audio - 『魏超』的 blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1956623_vyed6le6uz.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"weichao.io",root:"/",version:"1.9.4",typing:{enable:!1,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!1},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:2},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!0,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"kQcwfNV9f5OTEb51AgXNco4o-gzGzoHsz",app_key:"IVVmse4bqkjcVx2bEJiswbJc",server_url:"https://kqcwfnv9.lc-cn-n1-shared.com",path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>『魏超』的 blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-my-home"></i> <span>首页</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-my-document"></i> <span>文档</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/archives/"><i class="iconfont icon-my-archive"></i> <span>归档</span> </a><a class="dropdown-item" href="/categories/"><i class="iconfont icon-my-category"></i> <span>分类</span> </a><a class="dropdown-item" href="/tags/"><i class="iconfont icon-my-tag"></i> <span>标签</span></a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-my-image"></i> <span>图库</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/photo/"><i class="iconfont icon-my-camera"></i> <span>摄影</span> </a><a class="dropdown-item" href="/skiing/"><i class="iconfont icon-my-skiing"></i> <span>滑雪</span> </a><a class="dropdown-item" href="/motor/"><i class="iconfont icon-my-motor"></i> <span>摩托车</span></a></div></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-my-me"></i> <span>关于</span></a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-my-link"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/my_background.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle">Android NDK sample 之 native-audio</span></div><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> 魏超 </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2021-08-12 16:28" pubdate>2021年8月12日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 15k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 127 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">Android NDK sample 之 native-audio</h1><p class="note note-info">本文最后更新于：5 个月前</p><div class="markdown-body"><h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> <strong>Reference</strong></h1><ul><li><a target="_blank" rel="noopener" href="https://github.com/android/ndk-samples/tree/main/native-audio" title="https://github.com/android/ndk-samples/tree/main/native-audio">native-audio 源代码</a></li><li><a target="_blank" rel="noopener" href="https://www.khronos.org/registry/OpenSL-ES/specs/OpenSL_ES_Specification_1.0.1.pdf" title="https://www.khronos.org/registry/OpenSL-ES/specs/OpenSL_ES_Specification_1.0.1.pdf">OpenSL_ES_Specification_1.0.1.pdf</a></li></ul><hr><h1 id="启动页"><a class="markdownIt-Anchor" href="#启动页"></a> <strong>启动页</strong></h1><p><img src="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/Android-NDK-sample-%E4%B9%8B-native-audio/Android-NDK-sample-%E4%B9%8B-native-audio1.png" alt=""></p><p>4段音频：</p><ul><li><code>Hello</code>：单词hello的音频，存放在hello_clip.h文件中</li><li><code>Android</code>：单词Android的音频，存放在android_clip.h文件中</li><li><code>Sawtooth</code>：代码生成的单锯齿波，存放在内存中</li><li><code>Embedded soundtrack</code>：一段纯音乐，存放在background.mp3文件中</li></ul><p>4个控制：</p><ul><li><code>Reverb</code>：控制是否启用音频的回声音效（实测可以启用，但是启用后不能取消）</li><li><code>Mute</code>：控制是否静音，效果就是不影响正在播放的声音的播放进度，但是听不到声音</li><li><code>Enable SP</code>：控制是否启用立体声，启用之后，通过pan_uri可以调整声音从耳机左侧出来多一点 or 从耳机右侧出来多一点</li><li><code>volume_url</code>：控制音量大小</li></ul><blockquote><p>URI播放功能不可用：<br>native uriPlayer is broken in android 21 and over, internal bug id: b/29321867 will re-open after it is fixed in later OSes</p></blockquote><p>录音、播放功能：</p><ul><li><code>Record</code>：录音，固定5秒钟，存放到内存中</li><li><code>Playback</code>：播放录音</li></ul><hr><h1 id="opensl-es-基础"><a class="markdownIt-Anchor" href="#opensl-es-基础"></a> <strong>OpenSL ES 基础</strong></h1><p>OpenSL_ES_Specification_1.0.1.pdf 部分内容摘抄。</p><h2 id="311对象的状态机"><a class="markdownIt-Anchor" href="#311对象的状态机"></a> <strong>(3.1.1)对象的状态机</strong></h2><p><img src="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/Android-NDK-sample-%E4%B9%8B-audio-echo/Android-NDK-sample-%E4%B9%8B-audio-echo2.png" alt=""></p><ul><li>Unrealized（未实现（初始状态））:对象处于活动状态但尚未分配资源。尚不能使用；它的接口方法还不能被调用。</li><li>Realized（实现）: 对象的资源已分配，对象可用。</li><li>Suspended（挂起）：对象的资源少于可用所需的资源，但它保持挂起时的状态。这种状态是可选的，因为面对资源损失，实现可以选择将对象置于挂起状态或未实现状态。</li></ul><h2 id="315创建一个对象的步骤"><a class="markdownIt-Anchor" href="#315创建一个对象的步骤"></a> <strong>(3.1.5)创建一个对象的步骤</strong></h2><ol><li>如果尚未创建引擎对象，则创建并实现引擎对象。</li><li>从此对象获取 SLEngineItf 接口。</li><li>调用此接口的相应对象创建方法。</li><li>如果调用成功，该方法将返回新对象的 SLObjectItf 接口。</li><li>处理完对象后，调用 SLObjectItf 的 Destroy() 方法来释放对象及其资源。</li></ol><h2 id="41opensl-es-对象"><a class="markdownIt-Anchor" href="#41opensl-es-对象"></a> <strong>(4.1)OpenSL ES 对象</strong></h2><ol><li>Engine 对象</li><li>Media 对象</li><li>Metadata Extractor 对象</li><li>Audio Output Mix 对象</li><li>LED Array 对象</li><li>Vibration Control 对象</li></ol><h3 id="411engine-对象"><a class="markdownIt-Anchor" href="#411engine-对象"></a> <strong>(4.1.1)Engine 对象</strong></h3><p>OpenSL ES API 的入口点。此对象使您能够创建 OpenSL ES 中使用的所有其他对象。</p><p>engine 对象是特殊的，因为它是使用全局函数 slCreateEngine() 创建的。创建的结果是 engine 对象的 SLObjectItf 接口。</p><p>创建 engine 对象后，大部分工作将通过该对象公开的 SLEngineItf 接口完成。</p><p>engine 对象通过唯一的设备 ID 代表系统的各种多媒体相关设备。它支持 enumeration of audio input（枚举音频输入）、audio output（音频输出）、LED 和 vibrator devices（振动器）以及查询其功能的机制。</p><h3 id="412media-对象"><a class="markdownIt-Anchor" href="#412media-对象"></a> <strong>(4.1.2)Media 对象</strong></h3><p>media 对象通过在给定一组规定的输入和输出的情况下执行一些媒体处理任务来实现多媒体用例。media 对象包括（但不限于）呈现和捕获媒体流的对象，通常分别称为播放器和记录器。它们对音频数据进行操作。</p><h4 id="4121data-source数据源-和-sink-structures接收器"><a class="markdownIt-Anchor" href="#4121data-source数据源-和-sink-structures接收器"></a> <strong>(4.1.2.1)Data Source（数据源） 和 Sink Structures（接收器）</strong></h4><p>数据源是 media 对象的输入参数，指定 media 对象将从何处接收特定类型的数据（例如采样音频或 MIDI 数据）。<br>数据接收器也是 media 对象的输入参数，指定 media 对象将向何处发送特定类型的数据。</p><p>数据源和接收器的数量和类型因媒体对象而异。以下特征定义了数据源或接收器：</p><ul><li><p>它的数据定位器标识数据所在的位置。可能的定位器包括：</p><ul><li>URIs（例如文件名）</li><li>内存地址</li><li>IO设备</li><li>Output Mixes（输出混音）</li><li>Buffer queues（缓冲队列）</li></ul></li><li><p>它的数据格式标识了数据流的特征。可能的格式包括：</p><ul><li>基于 MIME 类型的格式</li><li>PCM 格式</li></ul></li></ul><h3 id="413metadata-extractor-对象"><a class="markdownIt-Anchor" href="#413metadata-extractor-对象"></a> <strong>(4.1.3)Metadata Extractor 对象</strong></h3><p>播放器对象支持读取媒体内容的元数据。但是，有时仅能够读取元数据而不必能够播放媒体就很有用。Metadata Extractor 对象可用于读取元数据，而无需为媒体播放分配资源。当应用程序只对呈现元数据感兴趣而不播放内容以及想要呈现多个文件的元数据时，特别推荐使用此对象。后者对于为演示目的生成播放列表特别有趣，因为播放器对象会不必要地分配播放资源。此外，播放器不能动态改变他们的数据源；因此，对于从多个文件中提取元数据，应用程序需要多次创建和销毁播放器对象，这既低效又可能导致堆碎片化。Metadata Extractor 对象没有数据接收器，但它有一个可以动态更改的数据源。</p><h3 id="414audio-output-mix-对象"><a class="markdownIt-Anchor" href="#414audio-output-mix-对象"></a> <strong>(4.1.4)Audio Output Mix 对象</strong></h3><p>API 允许将音频路由到多个音频输出，并包含一个 Audio Output Mix 对象，以促进此功能。应用程序从引擎检索输出混合对象，并且可以将该输出混合指定为媒体对象的接收器。Audio Output Mix 对象被指定为媒体对象的接收器，使用 SL_DATALOCATOR_OUTPUTMIX 数据定位器。引擎使用一组默认音频输出设备填充输出混合。应用程序可以通过 SLOutputMixItf 接口查询此设备列表或请求对其进行更改。API 不提供直接音频输出 IO 设备作为媒体对象的接收器。</p><h3 id="415led-array-对象"><a class="markdownIt-Anchor" href="#415led-array-对象"></a> <strong>(4.1.5)LED Array 对象</strong></h3><p>设备 LED 的控制是通过 LED 阵列对象处理的。查询 LED 阵列对象的功能和创建 LED 阵列对象是引擎级操作，而对单个 LED 的控制由对象处理。</p><h3 id="416vibration-control-对象"><a class="markdownIt-Anchor" href="#416vibration-control-对象"></a> <strong>(4.1.6)Vibration Control 对象</strong></h3><p>设备振动支持的控制是通过 Vibra 对象处理的。查询 Vibra 对象的能力和创建 Vibra 对象是引擎级别的操作，而实际振动的控制由对象处理。</p><h2 id="46示例用例"><a class="markdownIt-Anchor" href="#46示例用例"></a> <strong>(4.6)示例用例</strong></h2><h3 id="461采样音频播放"><a class="markdownIt-Anchor" href="#461采样音频播放"></a> <strong>(4.6.1)采样音频播放</strong></h3><p><img src="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/Android-NDK-sample-%E4%B9%8B-audio-echo/Android-NDK-sample-%E4%B9%8B-audio-echo3.png" alt=""></p><p>Audio Player 对象用于采样音频播放。我们使用 engine 对象的 SLEngineItf 接口创建 Audio Player 和 Output Mix。同时，将 Audio Player 和 Output Mix 关联用于音频输出。我们还在创建时设置了 Audio Player 的数据源，数据源可以是指向本地文件系统中的音频文件的 URI。默认情况下，Output Mix 与系统相关的 default output device 相关联。</p><h3 id="464录制音频"><a class="markdownIt-Anchor" href="#464录制音频"></a> <strong>(4.6.4)录制音频</strong></h3><p><img src="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/Android-NDK-sample-%E4%B9%8B-audio-echo/Android-NDK-sample-%E4%B9%8B-audio-echo4.png" alt=""></p><p>录音用例由 Audio Recorder 对象处理。我们使用引擎对象的 SLEngineItf 接口创建录音机对象。创建时，我们将其与音频数据源相关联，例如可以是 microphone（音频输入设备）。Audio Recorder 的数据接收器可以是指向本地文件系统中的音频文件的 URI，音频将被记录到该文件系统中。</p><h3 id="465读取元数据"><a class="markdownIt-Anchor" href="#465读取元数据"></a> <strong>(4.6.5)读取元数据</strong></h3><p><img src="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/Android-NDK-sample-%E4%B9%8B-audio-echo/Android-NDK-sample-%E4%B9%8B-audio-echo5.png" alt=""></p><p>Metadata Extractor 对象将读取音频文件的元数据，而无需为音频播放分配资源。与其他用例一样，我们使用引擎对象的 SLEngineItf 接口创建对象，并在创建时设置元数据提取器的数据源。数据源通常是指向本地文件系统中的音频文件的 URI。但是，元数据提取器支持 SLDynamicSourceItf 接口，我们可以使用它来更改数据源。因此，我们可以从多个文件（连续）中提取元数据，而无需为每个文件创建新的 Metadata Extractor 对象。SLMetadataExtractionItf 和 SLMetadataTraversalItf 接口用于从文件中实际读取和遍历元数据。</p><h3 id="471电话"><a class="markdownIt-Anchor" href="#471电话"></a> <strong>(4.7.1)电话</strong></h3><p><img src="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/Android-NDK-sample-%E4%B9%8B-audio-echo/Android-NDK-sample-%E4%B9%8B-audio-echo6.png" alt=""></p><p><img src="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/Android-NDK-sample-%E4%B9%8B-audio-echo/Android-NDK-sample-%E4%B9%8B-audio-echo7.png" alt=""></p><p><img src="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/Android-NDK-sample-%E4%B9%8B-audio-echo/Android-NDK-sample-%E4%B9%8B-audio-echo8.png" alt=""></p><h3 id="472音乐"><a class="markdownIt-Anchor" href="#472音乐"></a> <strong>(4.7.2)音乐</strong></h3><p><img src="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/Android-NDK-sample-%E4%B9%8B-audio-echo/Android-NDK-sample-%E4%B9%8B-audio-echo9.png" alt=""></p><h2 id="474数据源"><a class="markdownIt-Anchor" href="#474数据源"></a> <strong>(4.7.4)数据源</strong></h2><p><img src="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/Android-NDK-sample-%E4%B9%8B-audio-echo/Android-NDK-sample-%E4%B9%8B-audio-echo10.png" alt=""><br><img src="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/Android-NDK-sample-%E4%B9%8B-audio-echo/Android-NDK-sample-%E4%B9%8B-audio-echo11.png" alt=""></p><h2 id="61slcreateengine"><a class="markdownIt-Anchor" href="#61slcreateengine"></a> <strong>(6.1)slCreateEngine</strong></h2><p>初始化引擎对象并为用户提供一个句柄。</p><h2 id="7对象类型"><a class="markdownIt-Anchor" href="#7对象类型"></a> <strong>(7)对象类型</strong></h2><h3 id="72audio-player"><a class="markdownIt-Anchor" href="#72audio-player"></a> <strong>(7.2)Audio Player</strong></h3><p>音频播放器媒体对象播放由数据源指定的一段内容，执行任何隐式解码，应用任何指定的处理，并将其呈现到数据接收器指定的目的地。</p><h3 id="73audio-recorder"><a class="markdownIt-Anchor" href="#73audio-recorder"></a> <strong>(7.3)Audio Recorder</strong></h3><p>音频记录器媒体对象将内容片段记录到数据接收器指定的目的地，从数据源指定的输入中捕获它并执行任何指定的编码或处理。</p><h3 id="74engine-object"><a class="markdownIt-Anchor" href="#74engine-object"></a> <strong>(7.4)Engine Object</strong></h3><p>此对象类型是 API 的入口点。一个实现应该能够创建至少一个这样的对象，但尝试创建更多实例（通过单个应用程序或多个不同的应用程序）可能会失败。</p><p>引擎对象支持通过其 SLEngineItf 接口创建所有 API 的对象，并通过其 SLEngineCapabilitiesItf 接口查询实现的功能。</p><h3 id="77metadata-extractor-object"><a class="markdownIt-Anchor" href="#77metadata-extractor-object"></a> <strong>(7.7)Metadata Extractor Object</strong></h3><p>此对象可用于读取元数据，而无需为媒体播放分配资源。当应用程序只对呈现元数据感兴趣而不播放内容以及想要呈现多个文件的元数据时，特别推荐使用此对象。后者对于为演示目的生成播放列表特别有趣，因为音频播放器会不必要地分配播放资源。此外，播放器不能动态改变他们的数据源；因此，对于从多个文件中提取元数据，应用程序需要多次创建和销毁播放器对象，这既低效又可能导致堆碎片化。</p><h3 id="79output-mix"><a class="markdownIt-Anchor" href="#79output-mix"></a> <strong>(7.9)Output Mix</strong></h3><p>输出混合对象表示一组音频输出设备，一个音频输出流被发送到这些设备。应用程序从引擎检索输出混合对象，并且可以将该输出混合指定为媒体对象的接收器。引擎必须至少支持一种输出混合，但它可能支持更多。API 不提供直接音频输出 IO 设备作为媒体对象的接收器。</p><p>输出混合是一个逻辑对象；它并不（必然）代表物理混合。因此，由混合对象及其与媒体对象的关联在逻辑上定义的混合的实际实现是一个实现细节。输出混音不代表系统的主混音。此外，混合对象表示应用程序对输出的贡献；实施可能会将此贡献与其他来源的输出混合。</p><h2 id="8api"><a class="markdownIt-Anchor" href="#8api"></a> <strong>(8)API</strong></h2><h3 id="812slbufferqueueitf"><a class="markdownIt-Anchor" href="#812slbufferqueueitf"></a> <strong>(8.12)SLBufferQueueItf</strong></h3><p>此接口用于流式传输音频数据。它提供了一种在播放器对象上排队缓冲区以供设备播放的方法。它还提供了每当队列中的缓冲区完成时调用的回调函数。缓冲区按它们排队的顺序播放。可以查询缓冲区队列的状态以提供有关缓冲区队列播放状态的信息。这个接口实现了一个简单的流媒体机制。</p><ul><li>尝试在数据源不是 SL_DATALOCATOR_BUFFERQUEUE 或 SL_DATALOCATOR_MIDIBUFFERQUEUE 类型的 media 对象上实例化 SLBufferQueueItf 是无效的，将失败。</li><li>当播放器处于由 SLPlayItf 接口控制的 SL_PLAYSTATE_PLAYING 状态时，填充缓冲区将隐式开始播放。在队列中缓冲区不足导致饥饿的情况下，音频数据的播放会停止，但播放器仍保持在 SL_PLAYSTATE_PLAYING 状态，直到再次填充缓冲区，音频数据的播放才会恢复。请注意，排队缓冲区的饥饿会导致音频数据流中出现可听见的间隙。在播放器未处于播放状态的情况下，填充缓冲区不会启动音频播放。</li><li>排队的缓冲区就地使用，设备不需要复制，尽管这可能取决于实现。应用程序开发人员应该知道，在缓冲区排队之后修改缓冲区的内容是未定义的，并且可能导致音频损坏。</li><li>一旦入队的缓冲区完成播放，如回调通知所通知的那样，删除缓冲区或用新数据填充缓冲区并再次将缓冲区入队以进行播放是安全的。</li><li>在转换到 SL_PLAYSTATE_STOPPED 状态时，播放光标返回到当前播放缓冲区的开头。</li><li>在转换到 SL_PLAYSTATE_PAUSED 状态时，播放光标保持在缓冲区中的当前位置。</li><li>对于数据源是缓冲区队列的播放器，无法在缓冲区内查找。尝试在具有缓冲队列作为数据源的媒体对象上实例化 SLSeekitf 接口将失败。</li></ul><p><strong>默认</strong>：</p><ul><li>没有缓冲区排队</li><li>没有注册回调方法</li></ul><table><thead><tr><th>Callbacks</th><th>描述</th></tr></thead><tbody><tr><td>slBufferQueueCallback</td><td>播放完缓冲区队列中的缓冲区后调用的回调函数。</td></tr></tbody></table><p>Methods|描述|评论<br>–|–<br>Enqueue|向队列添加缓冲区。该方法将指向要排队的数据的指针和缓冲区的大小（以字节为单位）作为参数。缓冲区按使用此方法排队的顺序播放。|当播放器处于由 SLPlayItf 接口控制的 SL_PLAYSTATE_PLAYING 状态时，填充缓冲区将隐式开始播放。在队列中缓冲区不足导致饥饿的情况下，音频数据的播放会停止，但播放器仍保持在 SL_PLAYSTATE_PLAYING 状态，直到再次填充缓冲区，音频数据的播放才会恢复。请注意，排队缓冲区的饥饿会导致音频数据流中出现可听见的间隙。在播放器未处于播放状态的情况下，填充缓冲区不会启动音频播放。如果已达到使用 CreateAudioPlayer 或 CreateMidiPlayer 方法创建媒体对象时用作数据源的 SLDataLocator_BufferQueue 结构中指定的最大缓冲区数，则不会将该缓冲区添加到缓冲区队列，并返回 SL_RESULT_BUFFER_INSUFFICIENT。此时客户端应该等待，直到它收到缓冲区完成的回调通知，此时它可以将缓冲区排入队列。<br>Clear|释放当前在缓冲区队列中排队的所有缓冲区。不调用已释放缓冲区的回调函数。SLBufferQueueState 被重置为初始状态。|此方法会重置用于 GetPosition() 的 SLPlayItf 接口中使用的累积位置信息。<br>GetState|返回缓冲区队列的当前状态。|<br>RegisterCallback|设置在缓冲区完成时调用的回调函数。|RegisterCallback() 方法只能在媒体对象处于 SL_PLAYSTATE_STOPPED 状态时调用，以避免回调函数的删除和可能正在处理的回调之间的竞争条件。回调函数可以通过多次调用 RegisterCallback() 方法来更改，但仅限于媒体对象处于停止状态时。如果调用该方法时媒体对象不处于 SL_PLAYSTATE_STOPPED 状态，则返回 SL_RESULT_PRECONDITIONS_VIOLATED。</p><h3 id="816sleffectsenditf"><a class="markdownIt-Anchor" href="#816sleffectsenditf"></a> <strong>(8.16)SLEffectSendItf</strong></h3><p>此接口允许应用程序开发人员控制声音对辅助效果的贡献。辅助效果由其接口指针标识。 规范中唯一标准化的辅助效果是单个混响。一些实现可能会暴露其他辅助效果。</p><p>此界面需要启用辅助效果才能产生任何可听效果。对于混响效果，这需要在输出混合对象上公开 PresetReverb 或 EnvironmentalReverb。</p><p>音频播放器和 MIDI 播放器对象支持此接口。</p><p><strong>默认</strong>：</p><ul><li>直接level：0 mB（无level变化）</li><li>没有启用效果发送。</li></ul><p>Methods|描述|评论<br>–|–<br>EnableEffectSend|启用或禁用播放器对辅助效果的贡献。|如果实现无法将播放器的输出提供给指定的效果，则此方法可能会失败并返回值 SL_RESULT_RESOURCE_ERROR。如果 pAuxEffect 不是与效果发送接口一起使用的有效效果接口，则实现应返回 SL_RESULT_PARAMETER_INVALID。<br>IsEnabled|返回是否将播放器的输出输入到辅助效果中。|如果 pAuxEffect 不是与效果发送接口一起使用的有效效果接口，则实现应返回 SL_RESULT_PARAMETER_INVALID。<br>SetDirectLevel|设置声音的干（直接）路径level。<br>GetDirectLevel|获取播放器的干（直接）路径level。<br>SetSendLevel|为指定的辅助效果设置播放器的发送路径level。<br>GetSendLevel|获取指定辅助效果的播放器发送路径level。</p><h3 id="817slengineitf"><a class="markdownIt-Anchor" href="#817slengineitf"></a> <strong>(8.17)SLEngineItf</strong></h3><p>该接口公开了所有 OpenSL ES 对象类型的创建方法。</p><p>Methods|描述|评论<br>–|–<br>CreateLEDDevice|创建一个 LED 设备。|<br>CreateVibraDevice|创建振动器设备<br>CreateAudioPlayer|创建一个音频播放器对象。<br>CreateAudioRecorder|创建录音机。<br>CreateMidiPlayer|创建一个 MIDI 播放器。|如果在 pBankSrc 参数中提供了一个库，并且在 MIDI 源中嵌入了一个库，则播放器创建可能会失败并显示 SL_RESULT_FEATURE_UNSUPPORTED 代码。在这种情况下，建议应用程序尝试创建 MIDI 播放器而不在 pBankSrc 中提供库。如果应用程序计划单独使用 MIDI 消息接口 SLMIDIMessageItf 来提供 MIDI，则该应用程序可能希望将 pMIDISrc 设置为 NULL 从单个播放器到 MIDI 合成器的数据。<br>CreateListener|创建一个监听器。<br>Create3DGroup|创建一个 3D 组。<br>CreateOutputMix|创建输出混音器。<br>CreateMetadataExtractor|创建元数据提取器对象。<br>CreateExtensionObject|创建一个对象。此方法用于从规范外部定义的扩展对象。规范定义的对象必须由引擎接口中的特定创建方法创建。|如果引擎由于缺乏内存或资源而无法创建对象，它将分别返回 SL_RESULT_MEMORY_FAILURE 或 SL_RESULT_RESOURCE_ERROR 错误。由 pParameters 指向的 ObjectID 和数据结构应由扩展定义。当 ObjectID 无效时，该方法将返回 SL_RESULT_FEATURE_UNSUPPORTED。<br>QueryNumSupportedInterfaces|查询支持的可用接口数量。|支持的接口数量将包括对象可用的强制接口和可选接口。此方法可用于通过检查返回值来确定实现是否支持对象。<br>QuerySupportedInterfaces|查询支持的接口。|支持的接口数量将包括可用于对象的强制接口和可选接口。<br>QueryNumSupportedExtensions|查询支持的扩展数量。|支持的扩展数量将包括 Khronos 注册表中列出的标准化扩展和特定于供应商的扩展。<br>QuerySupportedExtension|根据给定的索引获取实现支持的扩展名。|如果给定的长度小于所需的大小，则返回 SL_RESULT_BUFFER_INSUFFICIENT 并且只会写入给定大小的数据； 但是，不会写入无效字符串。也就是说，空终止符始终存在，多字节字符不会在中间被截断。<br>IsExtensionSupported|查询实现是否支持给定的扩展。|这是一种替代方法，用于代替 QueryNumSupportedExtensions() 和 QuerySupportedExtension() 来查询仅一个已知扩展的可用性。</p><h3 id="819slenvironmentalreverbitf"><a class="markdownIt-Anchor" href="#819slenvironmentalreverbitf"></a> <strong>(8.19)SLEnvironmentalReverbItf</strong></h3><p>在特定声学环境中产生的声音通常通过许多不同的路径到达听众。听众首先听到来自声源本身的直达声。稍后，他会听到一些由附近墙壁、天花板或地板反弹的声音引起的离散回声。这些声音被称为早期反射。后来，随着声波在经过越来越多的反射后到达，各个反射变得难以区分，听众会听到随时间衰减的连续混响。下图说明了这种直接声、反射声和混响声的组合。请注意，反射level和混响level分别是早期反射和后期混响的总（积分）能量level，而不是峰值level。</p><p><img src="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/Android-NDK-sample-%E4%B9%8B-native-audio/Android-NDK-sample-%E4%B9%8B-native-audio2.png" alt=""></p><p>此接口允许应用程序在全局混响环境中控制这些属性。此接口公开的混响控制基于 I3DL2 指南，限制是高频参考level固定为 5 kHz。</p><p>当这个接口暴露在输出混音上时，它作为一个辅助效果；要将混响应用于播放器的输出，SLEffectSendItf 接口必须在播放器上公开。</p><p>公开此接口时必须遵守以下限制：</p><ul><li>当同一对象的 SLPresetReverbItf 接口已经公开时，无法公开此接口。</li></ul><p>输出混合对象支持此接口。</p><p><strong>高频衰减</strong>：<br>当声音被房间内的物体反射时，其高频通常比低频衰减得更快。此接口可控制对混响和反射的高频分量应用多少衰减。衰减是使用一个设置来控制的，该设置指定了 5 kHz 以上频率（高频）相对于低频的衰减level（以毫贝为单位）。这允许不同的实现为内部低通滤波器使用不同的滤波器设计（例如一极、二极）。</p><p><strong>默认</strong>：</p><ul><li>房间level：SL_MILLIBEL_MIN mB</li><li>房间高频level：0 mB</li><li>衰减时间：1000 毫秒</li><li>衰减高频比：500‰</li><li>反射延迟：20 毫秒</li><li>反射level：SL_MILLIBEL_MIN mB</li><li>混响level：SL_MILLIBEL_MIN mB</li><li>混响延迟：40 毫秒</li><li>扩散：1000‰</li><li>密度：1000‰</li></ul><p>Methods|描述|评论<br>–|–<br>SetRoomLevel|设置环境混响效果的主音量level。<br>GetRoomLevel|获取环境混响效果的主音量level。<br>SetRoomHFLevel|相对于整体混响效果的低频音量level，将音量level设置为 5 kHz。|这控制了一个低通滤波器，将降低高频level。<br>GetRoomHFLevel|获取房间的高频level<br>SetDecayTime|设置混响level衰减 60 dB 所需的时间。<br>GetDecayTime|获取混响level衰减 60 dB 所需的时间。<br>SetDecayHFRatio|设置高频衰减时间（5 kHz）相对于低频衰减时间的比率。<br>GetDecayHFRatio|获取高频衰减时间（5 kHz）相对于低频衰减时间的比率。<br>SetReflectionsLevel|设置早期反射的音量level。|此level与整体房间level相结合（使用 SetRoomLevel 设置）<br>GetReflectionsLevel|获取早期反射的音量level。<br>SetReflectionsDelay|设置早期反射的延迟时间。|此方法设置听到直接路径和听到第一次反射之间的时间。<br>GetReflectionsDelay|获取早期反射的延迟时间。<br>SetReverbLevel|设置后期混响的音量level。|此level与整体房间level（使用 SetRoomLevel 设置）相结合。<br>GetReverbLevel|获取后期混响的音量level。<br>SetReverbDelay|设置第一次反射和混响之间的时间。<br>GetReverbDelay|获取第一次反射和混响之间的时间。<br>SetDiffusion|设置后期混响衰减中的回声密度。|比例尺应近似线性映射到感知的混响变化。<br>GetDiffusion|获取后期混响衰减中的回声密度。<br>SetDensity|控制后期混响衰减的模态密度。|比例应该近似线性映射到混响的感知变化。较低的密度会产生空心的声音，这对于模拟小的混响空间（如浴室）很有用。<br>GetDensity|获取后期混响衰减的模态密度。<br>SetEnvironmentalReverbProperties|在一个方法调用中设置所有环境属性。|这可以与环境混响预设定义一起使用。<br>例如：<br>SLEnvironmentalReverbSettings ReverbSettings = SL_I3DL2_ENVIRONMENT_PRESET_BATHROOM;<br>/* Change reverb environment to bathroom.*/<br>pReverb-&gt;SetEnvironmentalReverbProperties(pReverb, &amp;ReverbSettings);<br>建议开发人员在给定时间更改多个参数时使用此方法，因为这样可以减少不必要的处理量。<br>GetEnvironmentalReverbProperties|获取环境的所有属性。</p><h4 id="9117slenvironmentalreverbsettings"><a class="markdownIt-Anchor" href="#9117slenvironmentalreverbsettings"></a> <strong>(9.1.17)SLEnvironmentalReverbSettings</strong></h4><p>这个结构可以存储所有的环境混响设置。</p><table><thead><tr><th>Field</th><th>描述</th></tr></thead><tbody><tr><td>roomLevel</td><td>以毫贝尔为单位的环境音量level。有效范围是 [SL_MILLIBEL_MIN, 0]。</td></tr><tr><td>roomHFLevel</td><td>以毫贝尔为单位的高频衰减level。有效范围是 [SL_MILLIBEL_MIN, 0]。</td></tr><tr><td>decayTime</td><td>以毫秒为单位的衰减时间。有效范围是 [100, 20000]。</td></tr><tr><td>decayHFRatio</td><td>使用 permille 标度的高频参考 (5 kHz) 下的相对衰减时间。有效范围是 [100, 2000]。</td></tr><tr><td>reflectionsLevel</td><td>以毫贝尔为单位的早期反射衰减level。有效范围是 [SL_MILLIBEL_MIN, 1000]。</td></tr><tr><td>reflectionsDelay</td><td>早期反射延迟长度以毫秒为单位。有效范围是 [0, 300]。</td></tr><tr><td>reverbLevel</td><td>以毫贝尔为单位的后期混响level。有效范围是 [SL_MILLIBEL_MIN, 2000]。</td></tr><tr><td>reverbDelay</td><td>以毫秒为单位的后期混响延迟。有效范围是 [0, 100]。</td></tr><tr><td>diffusion</td><td>以 permilles 表示的扩散level。有效范围是 [0, 1000]。</td></tr><tr><td>density</td><td>密度level以 permilles 表示。有效范围是 [0, 1000]。</td></tr></tbody></table><h3 id="829slobjectitf"><a class="markdownIt-Anchor" href="#829slobjectitf"></a> <strong>(8.29)SLObjectItf</strong></h3><p>SLObjectItf 接口为所有对象提供基本的实用方法。此类功能包括对象的销毁、实现和恢复、接口指针的获取、运行时错误的回调以及异步操作终止。</p><p>在任何给定时间，一个对象最多可以执行一个异步操作。当对象已经在处理异步调用时尝试调用异步操作等同于中止第一个操作，然后调用第二个操作。</p><p>SLObjectItf 是所有对象类型的隐式接口，在创建每个对象时自动可用。</p><p><strong>默认</strong>：</p><ul><li>对象处于未实现状态。</li><li>没有注册回调。</li></ul><table><thead><tr><th>Callbacks</th><th>描述</th></tr></thead><tbody><tr><td>slObjectCallback</td><td>回调函数，通知运行时错误、异步调用终止或对象资源状态的更改。</td></tr></tbody></table><p>Methods|描述|评论<br>–|–<br>Realize|同步或异步地将对象从 Unrealized 状态转换到 Realized 状态。|实现对象获取其功能所需的资源。如果可用资源不足，操作可能会失败。在这种情况下，应用程序可能会等到资源变得可用并收到 SL_OBJECT_EVENT_RESOURCES_AVAILABLE 事件，然后重试实现。另一种选择是尝试提高对象的优先级，从而增加对象窃取另一个对象资源的可能性。<br>Resume|同步或异步地将对象从挂起状态转换到已实现状态。|恢复对象获取其功能所需的资源。如果可用资源不足，操作可能会失败。在这种情况下，应用程序可能会等待资源变得可用并收到 SL_OBJECT_EVENT_RESOURCES_AVAILABLE 事件，然后重试恢复。另一种选择是尝试提高对象的优先级，从而增加对象窃取另一个对象资源的可能性。<br>GetState|检索当前对象状态。<br>GetInterface|获取对象暴露的接口|如果对象未公开请求的接口类型，则返回代码将为 SL_RESULT_FEATURE_UNSUPPORTED。<br>RegisterCallback|在发生运行时错误或异步操作终止时执行的对象上注册回调。|回调将仅报告运行时错误和调用异步函数的结果。<br>AbortAsyncOperation|中止对象当前处理的异步调用。此方法仅影响从 SLObjectItf 或 XADynamicInterfaceManagementItf 发起的异步调用。如果没有处理此类调用，则忽略该调用。如果注册了回调，它将被调用，SL_OBJECT_EVENT_ASYNC_TERMINATION 作为事件，SL_RESULT_OPERATION_ABORTED 作为返回码。|该方法用于正常超时或用户启动的异步调用中止。<br>Destroy|销毁对象|Destroy 通过 Unrealized 状态隐式传输对象，从而在释放对象之前释放分配给对象的所有资源。对属于此对象的接口的所有引用都将变为无效，并且如果使用可能会导致未定义的行为。所有挂起的异步操作都被中止，就好像 AbortAsyncOperations() 已被调用。<br>SetPriority|设置对象的优先级。|尽管可以在指定范围内设置任何优先级，但 SL_PRIORITY 定义了一组固定的优先级用于此方法。<br>GetPriority|获取对象的优先级。<br>SetLossOfControllnterfaces|设置/取消设置接口 ID 列表的失控功能。启用标志的默认值由全局设置确定。|对此方法的调用将覆盖指定接口列表的失控功能的全局设置。</p><h3 id="832slplayitf"><a class="markdownIt-Anchor" href="#832slplayitf"></a> <strong>(8.32)SLPlayItf</strong></h3><p>SLPlayItf 是一个用于控制对象播放状态的接口。</p><p><strong>默认</strong>：<br>最初，播放状态为 SL_PLAYSTATE_STOPPED，位置在内容的开头，更新周期为一秒，没有设置标记，也没有注册回调，回调事件标志被清除。</p><table><thead><tr><th>Callbacks</th><th>描述</th></tr></thead><tbody><tr><td>slPlayCallback</td><td>通知播放器应用程序播放事件。</td></tr></tbody></table><p>Methods|描述|评论<br>–|–<br>SetPlayState|请求播放器转换到给定的播放状态。|所有状态转换都是合法的。状态默认为 SL_PLAYSTATE_STOPPED。请注意，尽管状态更改是立即发生的，但此方法的执行与其对行为的影响之间可能存在一些延迟。从这个意义上说，播放器的状态在技术上代表了应用程序对播放器的意图。请注意，播放器的状态会影响播放器的预取状态（有关详细信息，请参阅 SLPrefetchStatusItf）。播放器可能会分别返回 SL_RESULT_PERMISSION_DENIED、SL_RESULT_CONTENT_CORRUPTED 或 SL_RESULT_CONTENT_UNSUPPORTED 如果在请求状态更改时检测到权限不足、内容损坏或内容不受支持。当播放器到达内容结尾时，播放状态将转换为暂停和暂停，播放光标将停留在内容的末尾。<br>GetPlayState|获取播放器当前的播放状态|<br>GetDuration|获取当前内容的持续时间，以毫秒为单位。|在数据源为缓冲队列的情况下，当前时长是自上次缓冲队列Clear()方法以来所有缓冲的累计时长。<br>GetPosition|返回播放头相对于内容开头的当前位置。|返回值介于 0 和内容的持续时间之间。在数据源为缓冲队列的情况下，当前位置是自上次缓冲队列Clear()方法以来所有缓冲的累计持续时间。请注意，位置是相对于以 1 倍前进速率播放的内容定义的； 位置不会随着播放速率的变化而缩放。<br>RegisterCallback|设置播放回调函数。|回调函数默认为 NULL。<br>应用程序可以使用上下文指针将状态传递给回调函数。<br>SetCallbackEventsMask|启用/禁用播放事件的通知。|回调事件标志默认为清除所有标志。<br>GetCallbackEventsMask|查询播放事件的通知状态（启用/禁用）。|<br>SetMarkerPosition|设置播放标记的位置。|当播放头通过标记时，播放器将通过带有 SL_PLAYEVENT_HEADATMARKER 事件的回调通知应用程序。默认情况下，没有定义标记位置。当标记位置与周期性位置更新（由 SetPositionUpdatePeriod() 指定）重合时，标记位置回调和周期性位置更新回调必须彼此相邻发布。两个回调的顺序无关紧要。<br>ClearMarkerPosition|清除标记。|即使标记已经清除，此功能也会成功。<br>GetMarkerPosition|查询播放标记的位置。|<br>SetPositionUpdatePeriod|设置定期位置通知之间的间隔。|当播放头通过指定时间段所暗示的位置时，播放器将通知应用程序。这些位置被定义为相对于内容开头的周期的整数倍。默认情况下，更新周期为 1000 毫秒。当周期性位置更新与标记位置重合时（由 SetMarkerPosition() 指定），则位置更新周期回调和标记位置回调必须彼此相邻发布。两个回调的顺序无关紧要。<br>GetPositionUpdatePeriod|查询周期性位置通知的间隔时间。|</p><h3 id="837slrecorditf"><a class="markdownIt-Anchor" href="#837slrecorditf"></a> <strong>(8.37)SLRecordItf</strong></h3><p>SLRecordItf 是一个用于控制对象录制状态的接口。录制的状态机如下：<br><img src="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/Android-NDK-sample-%E4%B9%8B-audio-echo/Android-NDK-sample-%E4%B9%8B-audio-echo12.png" alt=""></p><p>如果在记录到文件时存储介质变满，SL_OBJECT_EVENT_RUNTIME_ERROR 将通过 slObjectCallback 发布，SL_RESULT_IO_ERROR 作为此回调的结果参数。在这种情况下，记录器将自动转换到 SL_RECORDSTATE_STOPPED 状态。</p><p><strong>默认</strong>：<br>记录器默认为 SL_RECORDSTATE_STOPPED 状态，没有标记，没有持续时间限制，更新周期为一秒，没有设置标记，也没有注册回调，回调事件标志被清除。</p><table><thead><tr><th>Callbacks</th><th>描述</th></tr></thead><tbody><tr><td>slRecordCallback</td><td>通知记录器应用程序记录事件。</td></tr></tbody></table><p>Methods|描述|评论<br>–|–<br>SetRecordState|将记录器转换为给定的记录状态。|所有状态转换都是合法的。<br>GetRecordState|获取记录器的当前记录状态。|<br>SetDurationLimit|以毫秒为单位设置当前内容的持续时间。|当记录器达到限制时，它会自动转换到 SL_RECORDSTATE_STOPPED 状态并通过 SL_RECORDEVENT_HEADATLIMIT 事件通知应用程序。<br>GetPosition|返回记录头相对于内容开头的当前位置。|该位置与记录的内容量同义。<br>RegisterCallback|注册记录回调函数。|<br>SetCallbackEventsMask|设置记录事件的通知状态。|回调事件标志默认为清除所有标志。<br>GetCallbackEventsMask|查询记录事件的通知状态。|<br>SetMarkerPosition|设置记录标记的位置。|当录音头通过标记时，播放器将通过带有 SL_RECORDEVENT_HEADATMARKER 事件的回调通知应用程序。<br>ClearMarkerPosition|清除标记。|即使标记已经清除，此功能也会成功<br>GetMarkerPosition|查询录音标记的位置。|<br>SetPositionUpdatePeriod|设置定期位置通知之间的间隔。|当记录头通过指定时间段所暗示的位置时，记录器将通知应用程序。这些位置被定义为相对于内容开头的周期的整数倍。<br>GetPositionUpdatePeriod|查询周期性位置通知的间隔时间。</p><h3 id="838slseekitf"><a class="markdownIt-Anchor" href="#838slseekitf"></a> <strong>(8.38)SLSeekItf</strong></h3><p>SeekItf 是一个操作播放头的接口，包括设置它的位置和循环特性。如果支持，则可以使用搜索，而不管播放状态或速率如何。<br>音频播放器和 MIDI 播放器对象支持此接口。</p><p><strong>默认</strong>：<br>播放位置默认为 0 毫秒（当前内容的开始）。默认情况下禁用全局和本地循环。</p><p>Methods|描述|评论<br>–|–<br>SetPosition|设置播放头的位置|该实现可以将位置设置为最近的离散样本或帧。请注意，位置是相对于以 1 倍前进速率播放的内容定义的；位置不会随着播放速率的变化而缩放。<br>SetLoop|启用或禁用循环并设置循环的起点和终点。当循环开启并且播放头到达结束位置时，播放器自动将头设置到开始位置并保持在 SL_PLAYSTATE_PLAYING 状态。设置循环不会对播放头产生任何影响，即使在设置循环时头在循环之外。|如果不支持本地循环，则此方法返回 SL_RESULT_FEATURE_UNSUPPORTED。<br>GetLoop|查询循环是开启还是关闭，并检索循环点。</p><h3 id="843slvolumeitf"><a class="markdownIt-Anchor" href="#843slvolumeitf"></a> <strong>(8.43)SLVolumeItf</strong></h3><p>此接口公开用于操作对象的音频音量属性的控件。</p><p>此接口还公开了立体声位置控制。它的确切效果取决于对象的格式；如果对象的格式为单声道，则应用平移效果，如果对象的格式为立体声，则应用平衡效果。</p><p>音频播放器、MIDI 播放器和输出混合对象支持此接口。</p><p><strong>默认</strong>：</p><ul><li>音量level：0 mB</li><li>静音：禁用（不静音）</li><li>立体声位置：禁用，0‰（中心）</li></ul><p>Methods|描述|评论<br>–|–<br>SetVolumeLevel|设置对象的音量level。|如果对象被静音，对 SetVolumeLevel() 的调用仍将更改内部音量level，但这在对象取消静音之前不会产生声音效果。<br>GetVolumeLevel|获取对象的音量level。<br>GetMaxVolumeLevel|获取支持的最大level。|支持的最大level取决于实现，但始终至少为 0 mB。<br>SetMute|使对象静音或取消静音|使对象静音不会改变 GetVolumeLevel() 报告的音量level。当对象已经静音时调用 SetMute() 并将静音设置为 true 是一个有效的操作，没有任何效果。调用 SetMute() 时静音设置为 false 对象已经取消静音是一个无效的有效操作。<br>GetMute|检索对象的静音状态<br>EnableStereoPosition|启用或禁用立体定位效果。|如果对象的输出是单声道的，则此设置没有任何效果。<br>IsEnabledStereoPosition|返回立体声定位效果的启用状态。|如果对象的输出是单声道的，则此设置没有任何效果。<br>SetStereoPosition|设置对象的立体位置；对于单声道对象，这将控制恒定能量平移效果，对于立体声对象，这将控制平衡效果。|用于此方法的确切平移和平衡曲线取决于实现，但要满足参数描述。对于（输入）格式为单声道的对象，此方法控制恒定能量平移效果。对于（输入）格式为立体声的对象 ，此方法控制平衡效果。如果对象的输出是单声道的，则此设置没有任何效果。<br>GetStereoPosition|获取对象的立体位置设置。</p><hr><h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> <strong>代码</strong></h1><p><a target="_blank" rel="noopener" href="http://colors.black:10086/0/ndk-samples/tree/main/native-audio" title="http://colors.black:10086/0/ndk-samples/tree/main/native-audio">native-audio</a></p><hr><h1 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> <strong>分析</strong></h1><p>1、时序图（app启动后~点击任何按钮前）<br><img src="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/Android-NDK-sample-%E4%B9%8B-native-audio/Android-NDK-sample-%E4%B9%8B-native-audio3.jpg" alt=""></p><p>2.1、流程图（点击Hello或Android按钮）<br><img src="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/Android-NDK-sample-%E4%B9%8B-native-audio/Android-NDK-sample-%E4%B9%8B-native-audio4.jpg" alt=""></p><p>2.2、流程图（点击Sawtooth按钮）<br><img src="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/Android-NDK-sample-%E4%B9%8B-native-audio/Android-NDK-sample-%E4%B9%8B-native-audio5.jpg" alt=""></p><p>2.3、时序图（点击Embedded soundtrack按钮）<br><img src="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/Android-NDK-sample-%E4%B9%8B-native-audio/Android-NDK-sample-%E4%B9%8B-native-audio6.jpg" alt=""></p><p>2.4、时序图（点击Record按钮）<br><img src="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/Android-NDK-sample-%E4%B9%8B-native-audio/Android-NDK-sample-%E4%B9%8B-native-audio7.jpg" alt=""></p><p>2.5、流程图（点击Playback按钮）<br><img src="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/Android-NDK-sample-%E4%B9%8B-native-audio/Android-NDK-sample-%E4%B9%8B-native-audio8.jpg" alt=""></p><hr></div><hr><div><div class="post-metas my-3"></div><div class="license-box my-3"><div class="license-title"><div>Android NDK sample 之 native-audio</div><div>https://weichao.io/e434a01b9a8a/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>魏超</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2021年8月12日</div></div><div class="license-meta-item license-meta-date"><div>更新于</div><div>2022年12月4日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i> </span></a><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="NC - 非商业性使用"><i class="iconfont icon-nc"></i> </span></a><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="SA - 相同方式共享"><i class="iconfont icon-sa"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/4b5e292bd6f0/" title="Android NDK sample 之 android-wavemaker"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Android NDK sample 之 android-wavemaker</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/3c8edfb928da/" title="Android NDK sample 之 audio-echo"><span class="hidden-mobile">Android NDK sample 之 audio-echo</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><i class="iconfont icon-my-hexo"></i>&nbsp;<span>博客框架Hexo&nbsp;&nbsp;</span></a> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><i class="iconfont icon-my-theme"></i>&nbsp;<span>博客主题Fluid&nbsp;&nbsp;</span></a> <a href="https://weichao.io" target="_blank" rel="nofollow noopener"><i class="iconfont icon-my-copyright"></i>&nbsp;2023<span>魏超</span></a></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>