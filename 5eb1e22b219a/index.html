<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/my_icon.ico"><link rel="icon" href="/img/my_icon.ico"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="魏超"><meta name="keywords" content="魏超,weichao"><meta name="description" content="Reference  Media API    include 123456789#include &lt;NdkImage.h&gt;#include &lt;NdkImageReader.h&gt;#include &lt;NdkMediaCodec.h&gt;#include &lt;NdkMediaCrypto.h&gt;#include &lt;NdkMediaDrm.h&gt;#in"><meta property="og:type" content="article"><meta property="og:title" content="Android NDK API 之 Media"><meta property="og:url" content="https://weichao.io/5eb1e22b219a/index.html"><meta property="og:site_name" content="『魏超』的 blog"><meta property="og:description" content="Reference  Media API    include 123456789#include &lt;NdkImage.h&gt;#include &lt;NdkImageReader.h&gt;#include &lt;NdkMediaCodec.h&gt;#include &lt;NdkMediaCrypto.h&gt;#include &lt;NdkMediaDrm.h&gt;#in"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2021-08-27T03:17:22.000Z"><meta property="article:modified_time" content="2022-12-04T06:04:05.217Z"><meta property="article:author" content="魏超"><meta property="article:tag" content="魏超,weichao"><meta name="twitter:card" content="summary_large_image"><title>Android NDK API 之 Media - 『魏超』的 blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1956623_vyed6le6uz.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"weichao.io",root:"/",version:"1.9.4",typing:{enable:!1,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!1},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:2},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!0,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"kQcwfNV9f5OTEb51AgXNco4o-gzGzoHsz",app_key:"IVVmse4bqkjcVx2bEJiswbJc",server_url:"https://kqcwfnv9.lc-cn-n1-shared.com",path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>『魏超』的 blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-my-home"></i> <span>首页</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-my-document"></i> <span>文档</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/archives/"><i class="iconfont icon-my-archive"></i> <span>归档</span> </a><a class="dropdown-item" href="/categories/"><i class="iconfont icon-my-category"></i> <span>分类</span> </a><a class="dropdown-item" href="/tags/"><i class="iconfont icon-my-tag"></i> <span>标签</span></a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-my-image"></i> <span>图库</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/photo/"><i class="iconfont icon-my-camera"></i> <span>摄影</span> </a><a class="dropdown-item" href="/skiing/"><i class="iconfont icon-my-skiing"></i> <span>滑雪</span> </a><a class="dropdown-item" href="/motor/"><i class="iconfont icon-my-motor"></i> <span>摩托车</span></a></div></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-my-me"></i> <span>关于</span></a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-my-link"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/my_background.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle">Android NDK API 之 Media</span></div><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> 魏超 </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2021-08-27 11:17" pubdate>2021年8月27日 上午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 27k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 224 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">Android NDK API 之 Media</h1><p class="note note-info">本文最后更新于：1 个月前</p><div class="markdown-body"><h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> <strong>Reference</strong></h1><ul><li><a target="_blank" rel="noopener" href="https://developer.android.com/ndk/reference/group/media" title="https://developer.android.com/ndk/reference/group/media">Media API</a></li></ul><hr><h1 id="include"><a class="markdownIt-Anchor" href="#include"></a> <strong>include</strong></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;NdkImage.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;NdkImageReader.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;NdkMediaCodec.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;NdkMediaCrypto.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;NdkMediaDrm.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;NdkMediaError.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;NdkMediaExtractor.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;NdkMediaFormat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;NdkMediaMuxer.h&gt;</span></span><br></code></pre></td></tr></table></figure><hr><h1 id="enumerations"><a class="markdownIt-Anchor" href="#enumerations"></a> <strong>Enumerations</strong></h1><table><thead><tr><th>Anonymous Enum 100</th><th>说明</th></tr></thead><tbody><tr><td>AMEDIAEXTRACTOR_SAMPLE_FLAG_SYNC = 1</td><td></td></tr><tr><td>AMEDIAEXTRACTOR_SAMPLE_FLAG_ENCRYPTED = 2</td><td></td></tr></tbody></table><table><thead><tr><th>Anonymous Enum 99</th><th>说明</th></tr></thead><tbody><tr><td>AMEDIACODEC_BUFFER_FLAG_CODEC_CONFIG = 2</td><td></td></tr><tr><td>AMEDIACODEC_BUFFER_FLAG_END_OF_STREAM = 4</td><td></td></tr><tr><td>AMEDIACODEC_BUFFER_FLAG_PARTIAL_FRAME = 8</td><td></td></tr><tr><td>AMEDIACODEC_CONFIGURE_FLAG_ENCODE = 1</td><td></td></tr><tr><td>AMEDIACODEC_INFO_OUTPUT_BUFFERS_CHANGED = -3</td><td></td></tr><tr><td>AMEDIACODEC_INFO_OUTPUT_FORMAT_CHANGED = -2</td><td></td></tr><tr><td>AMEDIACODEC_INFO_TRY_AGAIN_LATER = -1</td><td></td></tr></tbody></table><p>AImage 支持的格式：AImageReader 只保证支持这里列出的格式。</p><p>AIMAGE_FORMATS|说明|评论<br>–|–<br>AIMAGE_FORMAT_RGBA_8888 = 0x1|32 位 RGBA 格式，四个通道各 8 位。|对应格式：<br>AHardwareBuffer：AHARDWAREBUFFER_FORMAT_R8G8B8A8_UNORM<br>Vulkan：VK_FORMAT_R8G8B8A8_UNORM<br>OpenGL ES：GL_RGBA8<br>AIMAGE_FORMAT_RGBX_8888 = 0x2|32 位 RGBX 格式，四个通道各 8 位。|Alpha 通道位的值被忽略（假设图像是不透明的）。<br>对应格式：<br>AHardwareBuffer：AHARDWAREBUFFER_FORMAT_R8G8B8X8_UNORM<br>Vulkan：VK_FORMAT_R8G8B8A8_UNORM<br>OpenGL ES：GL_RGB8<br>AIMAGE_FORMAT_RGB_888 = 0x3|24 位 RGB 格式，三个通道各 8 位。|对应格式：<br>AHardwareBuffer：AHARDWAREBUFFER_FORMAT_R8G8B8_UNORM<br>Vulkan：VK_FORMAT_R8G8B8_UNORM<br>OpenGL ES：GL_RGB8<br>AIMAGE_FORMAT_RGB_565 = 0x4|RGB 格式 16 位，红色通道 5 位，绿色通道 6 位，蓝色通道 5 位。|对应格式：<br>AHardwareBuffer: AHARDWAREBUFFER_FORMAT_R5G6B5_UNORM<br>Vulkan：VK_FORMAT_R5G6B5_UNORM_PACK16<br>OpenGL ES：GL_RGB565<br>AIMAGE_FORMAT_RGBA_FP16 = 0x16|64 位 RGBA 格式，四个通道各 16 位。|对应格式：<br>AHardwareBuffer：AHARDWAREBUFFER_FORMAT_R16G16B16A16_FLOAT<br>Vulkan：VK_FORMAT_R16G16B16A16_SFLOAT<br>OpenGL ES：GL_RGBA16F<br>AIMAGE_FORMAT_YUV_420_888 = 0x23|多平面 Android YUV 420 格式。|此格式是通用 YCbCr 格式，能够描述任何 4:2:0 色度子采样平面或半平面缓冲区（但不是完全交错），每个颜色采样 8 位。<br>这种格式的图像总是由三个独立的数据缓冲区表示，每个缓冲区一个用于每个颜色平面。附加信息总是伴随着缓冲区，描述每个平面的行跨度和像素跨度。<br>保证平面的顺序，使得平面#0 始终为Y，平面#1 始终为U (Cb)，平面#2 始终为V (Cr)。<br>Y 平面保​​证不与 U/V 平面交错（特别是，像素步幅在 AImage_getPlanePixelStride 中始终为 1）。<br>保证U/V平面具有相同的row stride和pixel stride，即保证U/V平面的AImage_getPlaneRowStride的返回值相同，U/V平面的AImage_getPlanePixelStride的返回值保证相同也保证是一样的。<br>例如，AImage 对象可以通过 AImageReader 对象从 ACameraDevice 提供这种格式的数据。<br>此格式始终支持作为 android Camera2 NDK API 的输出格式。<br>AIMAGE_FORMAT_JPEG = 0x100|压缩的 JPEG 格式。|此格式始终支持作为 android Camera2 NDK API 的输出格式。<br>AIMAGE_FORMAT_RAW16 = 0x20|每像素 16 位原始相机传感器图像格式，通常表示单通道拜耳马赛克图像。|颜色马赛克的布局、原始像素数据的最大和最小编码值、图像的颜色空间以及解释原始传感器图像所需的所有其他信息都必须从生成图像的 ACameraDevice 中查询。<br>AIMAGE_FORMAT_RAW_PRIVATE = 0x24|私有原始相机传感器图像格式，具有实现相关像素布局的单通道图像。|AIMAGE_FORMAT_RAW_PRIVATE 是来自图像传感器的未处理原始图像缓冲区的格式。这种格式的缓冲区的实际结构是依赖于实现的。<br>AIMAGE_FORMAT_RAW10 = 0x25|Android 10 位原始格式。|这是一个单平面、每像素 10 位、密集打包（每行）、未处理的格式，通常表示来自图像传感器的原始拜耳模式图像。<br>AIMAGE_FORMAT_RAW12 = 0x26|Android 12 位原始格式。|这是一个单平面、每像素 12 位、密集打包（每行）、未处理的格式，通常表示来自图像传感器的原始拜耳模式图像。<br>AIMAGE_FORMAT_DEPTH16 = 0x44363159|每个像素为16位，表示深度从深度相机或类似的传感器测距测量。16位采样由置信值和实际测距测量值组成。|置信值是对该采样正确性的估计。它被编码在采样的 3 个最高有效位中，值 0 表示 100% 置信度，值 1 表示 0% 置信度，值 2 表示 1/7，值 3 表示 2/7， 等等。<br><br>AIMAGE_FORMAT_DEPTH_POINT_CLOUD = 0x101|Android 稀疏深度点云格式。|一个可变长度的 3D 点列表加上一个置信度值，每个点由四个浮点数表示； 首先是 X、Y、Z 位置坐标，然后是置信度值。<br>点数是（（缓冲区的大小，以字节为单位）/16）。<br>位置值的坐标系和单位取决于点云数据的来源。置信度值介于 0.f 和 1.f 之间（含），其中 0 表示 0% 置信度，1.f 表示测量位置值的 100% 置信度。<br>AIMAGE_FORMAT_PRIVATE = 0x22|Android 私有不透明图像格式。|实际格式和像素数据布局的选择完全取决于设备特定和框架内部实现，并且可能因用例而异，即使对于同一设备也是如此。<br>另请注意，应用程序无法直接访问这些缓冲区的内容。<br>当从 AImageReader 或 AImage_getNumberOfPlanes() 方法获取此格式的 AImage 时，将返回零。<br>AIMAGE_FORMAT_Y8 = 0x20203859|安卓 Y8 格式。|Y8 是仅由 WxH Y 平面组成的平面格式，每个像素由 8 位表示。<br>AIMAGE_FORMAT_HEIC = 0x48454946|压缩的 HEIC 格式。|此格式定义了 ISO/IEC 23008-12 中描述的高效图像文件格式的 HEIC 品牌。<br>AIMAGE_FORMAT_DEPTH_JPEG = 0x69656963|深度增强的压缩 JPEG 格式。|JPEG 压缩主图像以及 XMP 嵌入深度元数据，符合 ISO 16684-1:2011(E)。</p><table><thead><tr><th>AMediaDrmEventType</th><th>说明</th></tr></thead><tbody><tr><td>EVENT_PROVISION_REQUIRED = 1</td><td></td></tr><tr><td>EVENT_KEY_REQUIRED = 2</td><td></td></tr><tr><td>EVENT_KEY_EXPIRED = 3</td><td></td></tr><tr><td>EVENT_VENDOR_DEFINED = 4</td><td></td></tr><tr><td>EVENT_SESSION_RECLAIMED = 5</td><td></td></tr></tbody></table><table><thead><tr><th>AMediaDrmKeyType</th><th>说明</th></tr></thead><tbody><tr><td>KEY_TYPE_STREAMING = 1</td><td></td></tr><tr><td>KEY_TYPE_OFFLINE = 2</td><td></td></tr><tr><td>KEY_TYPE_RELEASE = 3</td><td></td></tr></tbody></table><table><thead><tr><th>AMediaKeyStatusType</th><th>说明</th></tr></thead><tbody><tr><td>KEY_STATUS_TYPE_USABLE</td><td></td></tr><tr><td>KEY_STATUS_TYPE_EXPIRED</td><td></td></tr><tr><td>KEY_STATUS_TYPE_OUTPUTNOTALLOWED</td><td></td></tr><tr><td>KEY_STATUS_TYPE_STATUSPENDING</td><td></td></tr><tr><td>KEY_STATUS_TYPE_INTERNALERROR</td><td></td></tr></tbody></table><table><thead><tr><th>AppendMode</th><th>说明</th></tr></thead><tbody><tr><td>AMEDIAMUXER_APPEND_IGNORE_LAST_VIDEO_GOP = 0</td><td></td></tr><tr><td>AMEDIAMUXER_APPEND_TO_EXISTING_DATA = 1</td><td></td></tr></tbody></table><table><thead><tr><th>OutputFormat</th><th>说明</th></tr></thead><tbody><tr><td>AMEDIAMUXER_OUTPUT_FORMAT_MPEG_4 = 0</td><td></td></tr><tr><td>AMEDIAMUXER_OUTPUT_FORMAT_WEBM = 1</td><td></td></tr><tr><td>AMEDIAMUXER_OUTPUT_FORMAT_THREE_GPP = 2</td><td></td></tr></tbody></table><table><thead><tr><th>SeekMode</th><th>说明</th></tr></thead><tbody><tr><td>AMEDIAEXTRACTOR_SEEK_PREVIOUS_SYNC</td><td></td></tr><tr><td>AMEDIAEXTRACTOR_SEEK_NEXT_SYNC</td><td></td></tr><tr><td>AMEDIAEXTRACTOR_SEEK_CLOSEST_SYNC</td><td></td></tr></tbody></table><table><thead><tr><th>cryptoinfo_mode_t</th><th>说明</th></tr></thead><tbody><tr><td>AMEDIACODECRYPTOINFO_MODE_CLEAR = 0</td><td></td></tr><tr><td>AMEDIACODECRYPTOINFO_MODE_AES_CTR = 1</td><td></td></tr><tr><td>AMEDIACODECRYPTOINFO_MODE_AES_WV = 2</td><td></td></tr><tr><td>AMEDIACODECRYPTOINFO_MODE_AES_CBC = 3</td><td></td></tr></tbody></table><p>从 NDK 媒体函数返回的媒体错误消息类型。</p><p>media_status_t|说明|评论<br>–|–<br>AMEDIA_OK = 0|请求的媒体操作成功完成。<br>AMEDIACODEC_ERROR_INSUFFICIENT_RESOURCE = 1100|这表示无法分配所需的资源。<br>AMEDIACODEC_ERROR_RECLAIMED = 1101|这表示资源管理器回收了编解码器使用的媒体资源。|出现此错误时，必须释放编解码器，因为它已进入终端状态。<br>AMEDIA_ERROR_BASE = -10000|<br>AMEDIA_ERROR_UNKNOWN = AMEDIA_ERROR_BASE|被调用的媒体函数因未知错误而失败。<br>AMEDIA_ERROR_MALFORMED = AMEDIA_ERROR_BASE - 1|输入的媒体数据已损坏或不完整。<br>AMEDIA_ERROR_UNSUPPORTED = AMEDIA_ERROR_BASE - 2|不支持所需的操作或媒体格式。<br>AMEDIA_ERROR_INVALID_OBJECT = AMEDIA_ERROR_BASE - 3|函数调用中使用了无效（或已关闭）的对象。<br>AMEDIA_ERROR_INVALID_PARAMETER = AMEDIA_ERROR_BASE - 4|至少使用了一个无效参数。<br>AMEDIA_ERROR_INVALID_OPERATION = AMEDIA_ERROR_BASE - 5|媒体对象未处于所需操作的正确状态。<br>AMEDIA_ERROR_END_OF_STREAM = AMEDIA_ERROR_BASE - 6|媒体流在处理请求的操作时结束。<br>AMEDIA_ERROR_IO = AMEDIA_ERROR_BASE - 7|媒体对象进行 IO 操作时发生错误。<br>AMEDIA_ERROR_WOULD_BLOCK = AMEDIA_ERROR_BASE - 8|必须阻止所需的操作（在 I/O 或其他上），但未启用阻止。<br>AMEDIA_DRM_ERROR_BASE = -20000|<br>AMEDIA_DRM_NOT_PROVISIONED = AMEDIA_DRM_ERROR_BASE - 1|<br>AMEDIA_DRM_RESOURCE_BUSY = AMEDIA_DRM_ERROR_BASE - 2|<br>AMEDIA_DRM_DEVICE_REVOKED = AMEDIA_DRM_ERROR_BASE - 3|<br>AMEDIA_DRM_SHORT_BUFFER = AMEDIA_DRM_ERROR_BASE - 4|<br>AMEDIA_DRM_SESSION_NOT_OPENED = AMEDIA_DRM_ERROR_BASE - 5|<br>AMEDIA_DRM_TAMPER_DETECTED = AMEDIA_DRM_ERROR_BASE - 6|<br>AMEDIA_DRM_VERIFY_FAILED = AMEDIA_DRM_ERROR_BASE - 7|<br>AMEDIA_DRM_NEED_KEY = AMEDIA_DRM_ERROR_BASE - 8|<br>AMEDIA_DRM_LICENSE_EXPIRED = AMEDIA_DRM_ERROR_BASE - 9|<br>AMEDIA_IMGREADER_ERROR_BASE = -30000|<br>AMEDIA_IMGREADER_NO_BUFFER_AVAILABLE = AMEDIA_IMGREADER_ERROR_BASE - 1|没有更多的图像缓冲区来读取/写入图像数据。<br>AMEDIA_IMGREADER_MAX_IMAGES_ACQUIRED = AMEDIA_IMGREADER_ERROR_BASE - 2|AImage 对象已用完允许的最大图像缓冲区。<br>AMEDIA_IMGREADER_CANNOT_LOCK_IMAGE = AMEDIA_IMGREADER_ERROR_BASE - 3|无法锁定所需的图像缓冲区以进行读取。<br>AMEDIA_IMGREADER_CANNOT_UNLOCK_IMAGE = AMEDIA_IMGREADER_ERROR_BASE - 4|无法解锁媒体数据或缓冲区。<br>AMEDIA_IMGREADER_IMAGE_NOT_LOCKED = AMEDIA_IMGREADER_ERROR_BASE - 5|需要锁定媒体/缓冲区才能执行所需的操作。</p><hr><h1 id="typedefs"><a class="markdownIt-Anchor" href="#typedefs"></a> <strong>Typedefs</strong></h1><p> |说明|评论<br>–|–<br>struct AImage|AImage 是一种不透明类型，它提供对 AImageReader 生成的图像的访问。<br>struct AImageCropRect|描述由 AImage_getCropRect 返回的裁剪矩形的数据类型。|注意右下坐标是互斥的，所以矩形的宽度是（右-左），矩形的高度是（下-上）。<br>struct AImageReader|AImage 是一种不透明类型，它允许应用程序直接访问呈现到 ANativeWindow 中的图像数据。<br>void(* AImageReader_BufferRemovedCallback)(void *context, AImageReader *reader, AHardwareBuffer <em>buffer)|当 AImageReader 即将删除缓冲区时调用的回调签名。<br>struct AImageReader_BufferRemovedListener|AHardwareBuffer 移除事件的监听器，使用 AImageReader_setBufferRemovedListener 将监听器对象注册到 AImageReader。<br>void(</em> AImageReader_ImageCallback)(void *context, AImageReader <em>reader)|当 AImageReader 有新图像可用时调用的回调签名。<br>struct AImageReader_ImageListener|<br>struct AMediaCodec|<br>struct AMediaCodecBufferInfo|<br>struct AMediaCodecCryptoInfo|<br>void(</em> AMediaCodecOnAsyncError)(AMediaCodec *codec, void *userdata, media_status_t error, int32_t actionCode, const char <em>detail)|当 MediaCodec 遇到错误时调用。|指定的actionCode表示客户端可能采取的动作，可以通过调用AMediaCodecActionCode_isRecoverable或AMediaCodecActionCode_isTransient来查看。如果 AMediaCodecActionCode_isRecoverable() 和 AMediaCodecActionCode_isTransient() 都返回 false，则编解码器错误是致命的，必须删除编解码器。指定的详细信息可能包含有关此错误的更多详细消息。<br>void(</em> AMediaCodecOnAsyncFormatChanged)(AMediaCodec *codec, void *userdata, AMediaFormat <em>format)|当输出格式改变时调用。|指定的格式包含新的输出格式。<br>void(</em> AMediaCodecOnAsyncInputAvailable)(AMediaCodec *codec, void <em>userdata, int32_t index)|当输入缓冲区可用时调用。|指定的索引是可用输入缓冲区的索引。<br>struct AMediaCodecOnAsyncNotifyCallback|<br>void(</em> AMediaCodecOnAsyncOutputAvailable)(AMediaCodec *codec, void *userdata, int32_t index, AMediaCodecBufferInfo <em>bufferInfo)|当输出缓冲区可用时调用。|指定的索引是可用输出缓冲区的索引。 指定的 bufferInfo 包含有关可用输出缓冲区的信息。<br>struct AMediaCrypto|<br>struct AMediaDrm|<br>void(</em> AMediaDrmEventListener)(AMediaDrm *, const AMediaDrmSessionId *sessionId, AMediaDrmEventType eventType, int extra, const uint8_t <em>data, size_t dataSize)|<br>enum AMediaDrmEventType|<br>void(</em> AMediaDrmExpirationUpdateListener)(AMediaDrm *, const AMediaDrmSessionId <em>sessionId, int64_t expiryTimeInMS)|<br>AMediaDrmByteArray AMediaDrmKeyId|<br>AMediaDrmByteArray AMediaDrmKeySetId|<br>struct AMediaDrmKeyStatus|<br>enum AMediaKeyStatusType|<br>enum AMediaDrmKeyType|<br>struct AMediaDrmKeyValuePair|包含 {key, value} 对的数据类型。<br>void(</em> AMediaDrmKeysChangeListener)(AMediaDrm *, const AMediaDrmSessionId *sessionId, const AMediaDrmKeyStatus *keyStatus, size_t numKeys, bool hasNewUsableKey)|<br>AMediaDrmByteArray AMediaDrmScope|<br>AMediaDrmByteArray AMediaDrmSecureStop|<br>AMediaDrmByteArray AMediaDrmSessionId|<br>struct AMediaExtractor|<br>struct AMediaFormat|<br>struct AMediaMuxer|<br>uint8_t AMediaUUID[16]|<br>struct ANativeWindow|<br>struct PsshEntry|将加密方案 uuid 映射到该方案的方案特定数据<br>struct PsshInfo|加密方案列表及其数据</p><hr><h1 id="functions"><a class="markdownIt-Anchor" href="#functions"></a> <strong>Functions</strong></h1><p>返回值|函数|说明|评论<br>–|–<br>media_status_t|AImageReader_acquireLatestImage(AImageReader *reader, AImage **image)|<br>media_status_t|AImageReader_acquireLatestImageAsync(AImageReader *reader, AImage **image, int *acquireFenceFd)|<br>media_status_t|AImageReader_acquireNextImage(AImageReader *reader, AImage **image)|<br>media_status_t|AImageReader_acquireNextImageAsync(AImageReader *reader, AImage **image, int *acquireFenceFd)|<br>void|AImageReader_delete(AImageReader *reader)|<br>media_status_t|AImageReader_getFormat(const AImageReader *reader, int32_t *format)|<br>media_status_t|AImageReader_getHeight(const AImageReader *reader, int32_t *height)|<br>media_status_t|AImageReader_getMaxImages(const AImageReader *reader, int32_t *maxImages)|<br>media_status_t|AImageReader_getWidth(const AImageReader *reader, int32_t *width)|<br>media_status_t|AImageReader_getWindow(AImageReader *reader, ANativeWindow **window)|<br>media_status_t|AImageReader_new(int32_t width, int32_t height, int32_t format, int32_t maxImages, AImageReader **reader)|<br>media_status_t|AImageReader_newWithUsage(int32_t width, int32_t height, int32_t format, uint64_t usage, int32_t maxImages, AImageReader **reader)|<br>media_status_t|AImageReader_setBufferRemovedListener(AImageReader *reader, AImageReader_BufferRemovedListener *listener)|<br>media_status_t|AImageReader_setImageListener(AImageReader *reader, AImageReader_ImageListener *listener)|<br>void|AImage_delete(AImage *image)|<br>void|AImage_deleteAsync(AImage *image, int releaseFenceFd)|<br>media_status_t|AImage_getCropRect(const AImage *image, AImageCropRect *rect)|<br>media_status_t|AImage_getFormat(const AImage *image, int32_t *format)|<br>media_status_t|AImage_getHardwareBuffer(const AImage *image, AHardwareBuffer **buffer)|<br>media_status_t|AImage_getHeight(const AImage *image, int32_t *height)|<br>media_status_t|AImage_getNumberOfPlanes(const AImage *image, int32_t *numPlanes)|<br>media_status_t|AImage_getPlaneData(const AImage *image, int planeIdx, uint8_t **data, int *dataLength)|<br>media_status_t|AImage_getPlanePixelStride(const AImage *image, int planeIdx, int32_t *pixelStride)|<br>media_status_t|AImage_getPlaneRowStride(const AImage *image, int planeIdx, int32_t *rowStride)|<br>media_status_t|AImage_getTimestamp(const AImage *image, int64_t *timestampNs)|<br>media_status_t|AImage_getWidth(const AImage *image, int32_t *width)|<br>bool|AMediaCodecActionCode_isRecoverable(int32_t actionCode)|如果编解码器无法继续进行，则返回 true，但可以通过停止、配置和重新启动来恢复。|自 API 级别 28 起可用。<br>bool|AMediaCodecActionCode_isTransient(int32_t actionCode)|如果编解码器错误是暂时性问题，可能是由于资源限制，并且该方法（或编码/解码）可能会在稍后重试，则返回 true。|自 API 级别 28 起可用。<br>media_status_t|AMediaCodecCryptoInfo_delete(AMediaCodecCryptoInfo *)|删除之前使用 AMediaCodecCryptoInfo_new 创建的或从 AMediaExtractor 获得的 AMediaCodecCryptoInfo。|自 API 级别 21 起可用。<br>media_status_t|AMediaCodecCryptoInfo_getClearBytes(AMediaCodecCryptoInfo *, size_t *dst)|每个子采样中的前导未加密字节数。|自 API 级别 21 起可用。<br>media_status_t|AMediaCodecCryptoInfo_getEncryptedBytes(AMediaCodecCryptoInfo *, size_t *dst)|每个子采样中的尾随加密字节数。|自 API 级别 21 起可用。<br>media_status_t|AMediaCodecCryptoInfo_getIV(AMediaCodecCryptoInfo *, uint8_t *dst)|一个 16 字节的初始化向量。|自 API 级别 21 起可用。<br>media_status_t|AMediaCodecCryptoInfo_getKey(AMediaCodecCryptoInfo *, uint8_t *dst)|一个 16 字节的不透明密钥。|自 API 级别 21 起可用。<br>cryptoinfo_mode_t|AMediaCodecCryptoInfo_getMode(AMediaCodecCryptoInfo *)|已应用的加密类型，AMEDIACODECRYPTOINFO_MODE_CLEAR 或 AMEDIACODECRYPTOINFO_MODE_AES_CTR 之一。|自 API 级别 21 起可用。<br>size_t|AMediaCodecCryptoInfo_getNumSubSamples(AMediaCodecCryptoInfo *)|构成缓冲区内容的子采样数。|自 API 级别 21 起可用。<br>AMediaCodecCryptoInfo *|AMediaCodecCryptoInfo_new(int numsubsamples, uint8_t key[16], uint8_t iv[16], cryptoinfo_mode_t mode, size_t *clearbytes, size_t *encryptedbytes)|从头开始创建 AMediaCodecCryptoInfo。|如果您需要使用自定义加密信息，而不是从 AMediaExtractor 获得的信息，请使用此选项。<br>AMediaCodecCryptoInfo 描述了（至少部分）加密输入采样的结构。缓冲区的数据被认为被划分为“子采样”，每个子采样都以（可能为空的）纯未加密字节运行开始，然后是（也可能为空）加密字节运行。numBytesOfClearData 可以为 null 以指示所有数据都已加密。此信息封装了 ISO/IEC FDIS 23001-7:2011“ISO 基本媒体文件格式文件中的通用加密”中概述的每个采样元数据。<br>自 API 级别 21 起可用。<br>void|AMediaCodecCryptoInfo_setPattern(AMediaCodecCryptoInfo *info, cryptoinfo_pattern_t *pattern)|在 AMediaCryptoInfo 对象上设置加密模式。|自 API 级别 21 起可用。<br>media_status_t|AMediaCodec_configure(AMediaCodec *, const AMediaFormat *format, ANativeWindow *surface, AMediaCrypto *crypto, uint32_t flags)|配置编解码器。|对于解码，您通常会从提取器中获取格式。<br>自 API 级别 21 起可用。<br>AMediaCodec *|AMediaCodec_createCodecByName(const char *name)|按名称创建编解码器。|如果您知道要使用的确切编解码器，请使用此选项。配置时，您需要指定是将编解码器用作编码器还是解码器。<br>自 API 级别 21 起可用。<br>AMediaCodec *|AMediaCodec_createDecoderByType(const char *mime_type)|按 MIME 类型创建编解码器。|大多数应用程序将使用它，指定从媒体提取器获得的 mime 类型。<br>自 API 级别 21 起可用。<br>AMediaCodec *|AMediaCodec_createEncoderByType(const char *mime_type)|按名称创建编码器。|自 API 级别 21 起可用。<br>media_status_t|AMediaCodec_createInputSurface(AMediaCodec *mData, ANativeWindow **surface)|创建可用作编码器输入的 Surface，代替输入缓冲区。|这只能在通过 AMediaCodec_configure(…) 配置编解码器后调用； 并且在 AMediaCodec_start() 被调用之前。<br>应用程序负责通过在完成后调用 ANativeWindow_release() 来释放表面。<br>自 API 级别 26 起可用。<br>media_status_t|AMediaCodec_createPersistentInputSurface(ANativeWindow **surface)|创建可用作编码器输入的持久 Surface。|持久表面可以被 MediaCodec 实例重用，并且可以通过 AMediaCodec_setInputSurface() 在新实例上设置。在任何时间点，一个持久表面最多可以连接到一个 MediaCodec 实例。<br>应用程序负责通过在完成后调用 ANativeWindow_release() 来释放表面。<br>自 API 级别 26 起可用。<br>media_status_t|AMediaCodec_delete(AMediaCodec *)|删除编解码器并释放其资源。|自 API 级别 21 起可用。<br>ssize_t|AMediaCodec_dequeueInputBuffer(AMediaCodec *, int64_t timeoutUs)|获取下一个可用输入缓冲区的索引。|应用程序通常将它与 getInputBuffer() 一起使用以获取指向缓冲区的指针，然后将要编码或解码的数据复制到缓冲区中，然后再将其传递给编解码器。<br>自 API 级别 21 起可用。<br>ssize_t|AMediaCodec_dequeueOutputBuffer(AMediaCodec *, AMediaCodecBufferInfo *info, int64_t timeoutUs)|获取已处理数据的下一个可用缓冲区的索引。|自 API 级别 21 起可用。<br>media_status_t|AMediaCodec_flush(AMediaCodec *)|<br>AMediaFormat *|AMediaCodec_getBufferFormat(AMediaCodec *, size_t index)|获取缓冲区的格式。|指定的缓冲区索引必须先前已从 dequeueOutputBuffer 获得。调用者必须释放返回的格式。<br>自 API 级别 28 起可用。<br>uint8_t *|AMediaCodec_getInputBuffer(AMediaCodec *, size_t idx, size_t *out_size)|获取输入缓冲区。|指定的缓冲区索引必须先前已从 dequeueInputBuffer 获得，并且尚未排队。<br>自 API 级别 21 起可用。<br>AMediaFormat *|AMediaCodec_getInputFormat(AMediaCodec *)|在 AMediaCodec_configure() 成功返回后调用此方法以获取编解码器接受的输入格式。|这样做是为了确定编解码器支持哪些可选配置参数。调用者必须释放返回的格式。<br>自 API 级别 28 起可用。<br>media_status_t|AMediaCodec_getName(AMediaCodec *, char **out_name)|获取组件名称。|如果编解码器是由 createDecoderByType 或 createEncoderByType 创建的，则事先不知道选择了哪个组件。 调用者应调用 AMediaCodec_releaseName 以释放返回的指针。<br>自 API 级别 28 起可用。<br>uint8_t *|AMediaCodec_getOutputBuffer(AMediaCodec *, size_t idx, size_t *out_size)|获取输出缓冲区。|指定的缓冲区索引必须先前已从 dequeueOutputBuffer 获得，并且尚未排队。<br>自 API 级别 21 起可用。<br>AMediaFormat *|AMediaCodec_getOutputFormat(AMediaCodec *)|返回编解码器输出的格式。|调用者必须释放返回的格式。<br>自 API 级别 21 起可用。<br>media_status_t|AMediaCodec_queueInputBuffer(AMediaCodec <em>, size_t idx, <em>off_t_compat offset, size_t size, uint64_t time, uint32_t flags)|将指定的缓冲区发送到编解码器进行处理。|自 API 级别 21 起可用。<br>media_status_t|AMediaCodec_queueSecureInputBuffer(AMediaCodec <em>, size_t idx, <em>off_t_compat offset, AMediaCodecCryptoInfo *, uint64_t time, uint32_t flags)|将指定的缓冲区发送到编解码器进行处理。|自 API 级别 21 起可用。<br>media_status_t|AMediaCodec_releaseCrypto(AMediaCodec *)|如果适用，请释放加密。|自 API 级别 28 起可用。<br>void|AMediaCodec_releaseName(AMediaCodec *, char *name)|释放 AMediaCodec_getName 返回的 name 指向的内存。|自 API 级别 28 起可用。<br>media_status_t|AMediaCodec_releaseOutputBuffer(AMediaCodec *, size_t idx, bool render)|如果您使用完缓冲区，请使用此调用将缓冲区返回给编解码器。|如果您之前在配置此视频解码器时指定了一个表面，您可以选择渲染缓冲区。<br>自 API 级别 21 起可用。<br>media_status_t|AMediaCodec_releaseOutputBufferAtTime(AMediaCodec *mData, size_t idx, int64_t timestampNs)|如果您使用完缓冲区，请使用此调用来更新其表面时间戳并将其返回给编解码器以在输出表面上呈现它。|如果您在配置此视频编解码器时未指定输出表面，则此调用将简单地将缓冲区返回给编解码器。<br>自 API 级别 21 起可用。<br>media_status_t|AMediaCodec_setAsyncNotifyCallback(AMediaCodec *, AMediaCodecOnAsyncNotifyCallback callback, void *userdata)|为可操作的 AMediaCodec 事件设置异步回调。|启用异步回调时，客户端不应调用 AMediaCodec_getInputBuffers()、AMediaCodec_getOutputBuffers()、AMediaCodec_dequeueInputBuffer() 或 AMediaCodec_dequeueOutputBuffer()。<br>此外， AMediaCodec_flush() 在异步模式下的行为也不同。 调用 AMediaCodec_flush() 后，您必须调用 AMediaCodec_start() 以“恢复”接收输入缓冲区，即使创建了输入表面。<br>关于每个回调函数的调用方式和指定内容，请参阅 AMediaCodecOnAsyncNotifyCallback 的定义。 指定的 userdata 是调用这些回调函数时使用的指针。<br>所有回调都在一个 NDK 内部线程上触发。 不应在回调线程上调用 AMediaCodec_setAsyncNotifyCallback。 不应在回调线程上执行繁重的任务。<br>自 API 级别 28 起可用。<br>media_status_t|AMediaCodec_setInputSurface(AMediaCodec *mData, ANativeWindow *surface)|设置可用作编码器输入的持久表面，以代替输入缓冲区。|提供的表面必须是通过 AMediaCodec_createPersistentInputSurface() 创建的持久表面 这只能在通过调用 AMediaCodec_configure(…) 配置编解码器后调用； 并且在 AMediaCodec_start() 被调用之前。<br>自 API 级别 26 起可用。<br>media_status_t|AMediaCodec_setOutputSurface(AMediaCodec *, ANativeWindow *surface)|动态设置编解码器的输出表面。|这只能在编解码器配置有输出表面时使用。新输出表面应具有与原始输出表面兼容的使用类型。 例如。编解码器可能不支持从 SurfaceTexture（GPU 可读）输出切换到 ImageReader（软件可读）输出。<br>自 API 级别 21 起可用。<br>media_status_t|AMediaCodec_setParameters(AMediaCodec *mData, const AMediaFormat *params)|向编解码器实例发送附加参数。|只有在编解码器运行时才能传递参数，即在调用 AMediaCodec_start() 之后。<br>注意：其中一些参数更改可能会默默地无法应用。<br>自 API 级别 26 起可用。<br>media_status_t|AMediaCodec_signalEndOfInputStream(AMediaCodec *mData)|输入信号流结束。|相当于提交一个设置了 AMEDIACODEC_BUFFER_FLAG_END_OF_STREAM 的空缓冲区。<br>当与未处于执行状态的编码器一起使用或未从 AMediaCodec_createInputSurface 或 AMediaCodec_createPersistentInputSurface 创建的 Surface 接收输入时，返回 AMEDIA_ERROR_INVALID_OPERATION。<br>如果存在，则返回上一个编解码器错误。<br>成功完成后返回 AMEDIA_OK。<br>自 API 级别 26 起可用。<br>media_status_t|AMediaCodec_start(AMediaCodec *)|启动编解码器。|编解码器必须在启动之前进行配置，并且必须在缓冲区被发送到它之前启动。<br>自 API 级别 21 起可用。<br>media_status_t|AMediaCodec_stop(AMediaCodec *)|停止编解码器。|自 API 级别 21 起可用。<br>void|AMediaCrypto_delete(AMediaCrypto *crypto)|<br>bool|AMediaCrypto_isCryptoSchemeSupported(const AMediaUUID uuid)|<br>AMediaCrypto *|AMediaCrypto_new(const AMediaUUID uuid, const void *initData, size_t initDataSize)|<br>bool|AMediaCrypto_requiresSecureDecoderComponent(const char *mime)|<br>media_status_t|AMediaDrm_closeSession(AMediaDrm *, const AMediaDrmSessionId *sessionId)|<br>AMediaDrm *|AMediaDrm_createByUUID(const uint8_t *uuid)|<br>media_status_t|AMediaDrm_decrypt(AMediaDrm *, const AMediaDrmSessionId *sessionId, const char *cipherAlgorithm, uint8_t *keyId, uint8_t *iv, const uint8_t *input, uint8_t *output, size_t dataSize)|<br>media_status_t|AMediaDrm_encrypt(AMediaDrm *, const AMediaDrmSessionId *sessionId, const char *cipherAlgorithm, uint8_t *keyId, uint8_t *iv, const uint8_t *input, uint8_t *output, size_t dataSize)|<br>media_status_t|AMediaDrm_getKeyRequest(AMediaDrm *, const AMediaDrmScope *scope, const uint8_t *init, size_t initSize, const char *mimeType, AMediaDrmKeyType keyType, const AMediaDrmKeyValue *optionalParameters, size_t numOptionalParameters, const uint8_t **keyRequest, size_t *keyRequestSize)|<br>media_status_t|AMediaDrm_getPropertyByteArray(AMediaDrm *, const char *propertyName, AMediaDrmByteArray *propertyValue)|<br>media_status_t|AMediaDrm_getPropertyString(AMediaDrm *, const char *propertyName, const char **propertyValue)|<br>media_status_t|AMediaDrm_getProvisionRequest(AMediaDrm *, const uint8_t **provisionRequest, size_t *provisionRequestSize, const char **serverUrl)|<br>media_status_t|AMediaDrm_getSecureStops(AMediaDrm *, AMediaDrmSecureStop *secureStops, size_t *numSecureStops)|<br>bool|AMediaDrm_isCryptoSchemeSupported(const uint8_t *uuid, const char *mimeType)|<br>media_status_t|AMediaDrm_openSession(AMediaDrm *, AMediaDrmSessionId *sessionId)|<br>media_status_t|AMediaDrm_provideKeyResponse(AMediaDrm *, const AMediaDrmScope *scope, const uint8_t *response, size_t responseSize, AMediaDrmKeySetId *keySetId)|<br>media_status_t|AMediaDrm_provideProvisionResponse(AMediaDrm *, const uint8_t *response, size_t responseSize)|<br>media_status_t|AMediaDrm_queryKeyStatus(AMediaDrm *, const AMediaDrmSessionId *sessionId, AMediaDrmKeyValue *keyValuePairs, size_t *numPairs)|<br>void|AMediaDrm_release(AMediaDrm *)|<br>media_status_t|AMediaDrm_releaseSecureStops(AMediaDrm *, const AMediaDrmSecureStop *ssRelease)|<br>media_status_t|AMediaDrm_removeKeys(AMediaDrm *, const AMediaDrmSessionId *keySetId)|<br>media_status_t|AMediaDrm_restoreKeys(AMediaDrm *, const AMediaDrmSessionId *sessionId, const AMediaDrmKeySetId *keySetId)|<br>media_status_t|AMediaDrm_setOnEventListener(AMediaDrm *, AMediaDrmEventListener listener)|<br>media_status_t|AMediaDrm_setOnExpirationUpdateListener(AMediaDrm *, AMediaDrmExpirationUpdateListener listener)|<br>media_status_t|AMediaDrm_setOnKeysChangeListener(AMediaDrm *, AMediaDrmKeysChangeListener listener)|<br>media_status_t|AMediaDrm_setPropertyByteArray(AMediaDrm *, const char *propertyName, const uint8_t *value, size_t valueSize)|<br>media_status_t|AMediaDrm_setPropertyString(AMediaDrm *, const char *propertyName, const char *value)|<br>media_status_t|AMediaDrm_sign(AMediaDrm *, const AMediaDrmSessionId *sessionId, const char *macAlgorithm, uint8_t *keyId, uint8_t *message, size_t messageSize, uint8_t *signature, size_t *signatureSize)|<br>media_status_t|AMediaDrm_verify(AMediaDrm *, const AMediaDrmSessionId *sessionId, const char *macAlgorithm, uint8_t *keyId, const uint8_t *message, size_t messageSize, const uint8_t *signature, size_t signatureSize)|<br>bool|AMediaExtractor_advance(AMediaExtractor *)|前进到下一个采样。|如果没有更多的采样数据可用（流结束），则返回 false。<br>自 API 级别 21 起可用。<br>media_status_t|AMediaExtractor_delete(AMediaExtractor *)|删除以前创建的媒体提取器。|自 API 级别 21 起可用。<br>int64_t|AMediaExtractor_getCachedDuration(AMediaExtractor *)|返回从网络数据源（带有“http(s)”URI 的 AMediaExtractor_setDataSource）下载的缓存媒体采样的持续时间（以微秒为单位）。|此信息使用总比特率计算； 如果总比特率不在媒体容器中，则使用总持续时间和文件大小计算。<br>当提取器未从网络数据源读取时，或无法计算缓存持续时间（比特率、持续时间和文件大小信息不可用）时，返回 -1。<br>自 API 级别 28 起可用。<br>AMediaFormat *|AMediaExtractor_getFileFormat(AMediaExtractor *)|返回提取器的格式。|调用者必须使用 AMediaFormat_delete(format) 释放返回的格式。<br>此函数将始终返回格式；但是，如果媒体容器不提供格式信息，格式可能为空（没有键值对）。<br>自 API 级别 28 起可用。<br>PsshInfo *|AMediaExtractor_getPsshInfo(AMediaExtractor *)|获取 PSSH 信息（如果存在）。|自 API 级别 21 起可用。<br>AMediaCodecCryptoInfo *|AMediaExtractor_getSampleCryptoInfo(AMediaExtractor *)||自 API 级别 21 起可用。<br>uint32_t|AMediaExtractor_getSampleFlags(AMediaExtractor *)|读取当前采样的标志。|自 API 级别 21 起可用。<br>media_status_t|AMediaExtractor_getSampleFormat(AMediaExtractor *ex, AMediaFormat *fmt)|将当前采样的元数据格式读入 fmt。|采样元数据的示例是 SEI（补充增强信息）和 MPEG 用户数据，两者都可以嵌入隐藏式字幕数据<br>成功时返回 AMEDIA_OK 或 AMEDIA_ERROR</em></em> 以指示失败原因。 fmt 中现有的键值对 如果此 API 返回 AMEDIA_OK，则将被删除。 fmt 的内容 如果此 API 返回 AMEDIA_ERROR</em></em>，则未定义。<br>自 API 级别 28 起可用。<br>ssize_t|AMediaExtractor_getSampleSize(AMediaExtractor *)|返回当前采样的大小（以字节为单位），如果没有可用采样（流结束），则返回 -1。|此 API 可与 AMediaExtractor_readSampleData 结合使用：ssize_t sampleSize = AMediaExtractor_getSampleSize(ex); uint8_t *buf = 新 uint8_t[sampleSize]; AMediaExtractor_readSampleData(ex, buf, sampleSize);<br>自 API 级别 28 起可用。<br>int64_t|AMediaExtractor_getSampleTime(AMediaExtractor *)|以微秒为单位返回当前采样的呈现时间。|如果没有更多可用的采样，则为 -1。<br>自 API 级别 21 起可用。<br>int|AMediaExtractor_getSampleTrackIndex(AMediaExtractor *)|返回当前采样源自的轨道索引（如果没有更多可用采样，则返回 -1）|自 API 级别 21 起可用。<br>size_t|AMediaExtractor_getTrackCount(AMediaExtractor *)|返回先前指定的媒体文件中的曲目数。|自 API 级别 21 起可用。<br>AMediaFormat *|AMediaExtractor_getTrackFormat(AMediaExtractor *, size_t idx)|返回指定轨道的格式。|调用者必须释放返回的格式<br>自 API 级别 21 起可用。<br>AMediaExtractor *|AMediaExtractor_new()|创建新的媒体提取器。|自 API 级别 21 起可用。<br>ssize_t|AMediaExtractor_readSampleData(AMediaExtractor *, uint8_t *buffer, size_t capacity)|读取当前采样。|自 API 级别 21 起可用。<br>media_status_t|AMediaExtractor_seekTo(AMediaExtractor *, int64_t seekPosUs, SeekMode mode)||自 API 级别 21 起可用。<br>media_status_t|AMediaExtractor_selectTrack(AMediaExtractor *, size_t idx)|选择指定的曲目。|对 readSampleData、getSampleTrackIndex 和 getSampleTime 的后续调用仅检索所选轨道子集的信息。多次选择同一曲目没有任何效果，曲目仅被选中一次。<br>自 API 级别 21 起可用。<br>media_status_t|AMediaExtractor_setDataSource(AMediaExtractor *, const char *location)|设置提取器将从中读取的 URI。|自 API 级别 21 起可用。<br>media_status_t|AMediaExtractor_setDataSourceCustom(AMediaExtractor *, AMediaDataSource *src)|设置提取器将从中读取的自定义数据源实现。|自 API 级别 28 起可用。<br>media_status_t|AMediaExtractor_setDataSourceFd(AMediaExtractor *, int fd, off64_t offset, off64_t length)|设置提取器将从中读取的文件描述符。|自 API 级别 21 起可用。<br>media_status_t|AMediaExtractor_unselectTrack(AMediaExtractor *, size_t idx)|取消选择指定的曲目。|对 readSampleData、getSampleTrackIndex 和 getSampleTime 的后续调用仅检索所选轨道子集的信息。<br>自 API 级别 21 起可用。<br>void|AMediaFormat_clear(AMediaFormat *)|从给定的 AMediaFormat 中删除所有键/值对。|自 API 级别 29 起可用。<br>media_status_t|AMediaFormat_copy(AMediaFormat *to, AMediaFormat *from)|将一个 AMediaFormat 复制到另一个。|自 API 级别 29 起可用。<br>media_status_t|AMediaFormat_delete(AMediaFormat *)||自 API 级别 21 起可用。<br>bool|AMediaFormat_getBuffer(AMediaFormat *, const char *name, void **data, size_t *size)|返回的数据归格式所有并且只要命名条目是格式的一部分就保持有效。|自 API 级别 21 起可用。<br>bool|AMediaFormat_getDouble(AMediaFormat *, const char *name, double *out)||自 API 级别 28 起可用。<br>bool|AMediaFormat_getFloat(AMediaFormat *, const char *name, float *out)||自 API 级别 21 起可用。<br>bool|AMediaFormat_getInt32(AMediaFormat *, const char *name, int32_t *out)||自 API 级别 21 起可用。<br>bool|AMediaFormat_getInt64(AMediaFormat *, const char *name, int64_t *out)||自 API 级别 21 起可用。<br>bool|AMediaFormat_getRect(AMediaFormat *, const char *name, int32_t *left, int32_t *top, int32_t *right, int32_t *bottom)||自 API 级别 28 起可用。<br>bool|AMediaFormat_getSize(AMediaFormat *, const char *name, size_t *out)||自 API 级别 21 起可用。<br>bool|AMediaFormat_getString(AMediaFormat *, const char *name, const char **out)|返回的字符串归格式所有，并且在下一次调用 getString 或删除格式之前一直有效。|自 API 级别 21 起可用。<br>AMediaFormat *|AMediaFormat_new()||自 API 级别 21 起可用。<br>void|AMediaFormat_setBuffer(AMediaFormat *, const char *name, const void *data, size_t size)|提供的数据被复制到格式中。|自 API 级别 21 起可用。<br>void|AMediaFormat_setDouble(AMediaFormat *, const char *name, double value)||自 API 级别 28 起可用。<br>void|AMediaFormat_setFloat(AMediaFormat *, const char *name, float value)||自 API 级别 21 起可用。<br>void|AMediaFormat_setInt32(AMediaFormat *, const char *name, int32_t value)||自 API 级别 21 起可用。<br>void|AMediaFormat_setInt64(AMediaFormat *, const char *name, int64_t value)||自 API 级别 21 起可用。<br>void|AMediaFormat_setRect(AMediaFormat *, const char *name, int32_t left, int32_t top, int32_t right, int32_t bottom)||自 API 级别 28 起可用。<br>void|AMediaFormat_setSize(AMediaFormat *, const char *name, size_t value)||自 API 级别 28 起可用。<br>void|AMediaFormat_setString(AMediaFormat *, const char *name, const char *value)|提供的字符串被复制到格式中。|自 API 级别 21 起可用。<br>const char *|AMediaFormat_toString(AMediaFormat *)|格式的人类可读表示。|返回的字符串归格式所有，并且在下一次调用 toString 或删除格式之前一直有效。<br>自 API 级别 21 起可用。<br>ssize_t|AMediaMuxer_addTrack(AMediaMuxer *, const AMediaFormat *format)|添加具有指定格式的曲目。|返回新轨道的索引或失败时的负值，可以解释为 media_status_t。<br>自 API 级别 21 起可用。<br>AMediaMuxer *|AMediaMuxer_append(int fd, AppendMode mode)|创建一个新的媒体复用器，用于将数据附加到现有的 MPEG4 文件。|这是一个同步 API 调用，如果现有文件很大，可能需要一段时间才能返回。<br>仅适用于符合以下特征之一的 MPEG4 文件：<br>单个音轨。<br>单个视频轨道。<br>单个音频和单个视频轨道。<br>自 API 级别 31 起可用。<br>media_status_t|AMediaMuxer_delete(AMediaMuxer *)|删除之前创建的媒体复用器。|自 API 级别 21 起可用。<br>ssize_t|AMediaMuxer_getTrackCount(AMediaMuxer *)|返回传递给 AMediaMuxer_new 的文件中添加的轨道数或传递给 AMediaMuxer_append 的文件中的现有轨道数。|应在 INITIALIZED 或 STARTED 状态下调用，否则返回 -1。<br>自 API 级别 31 起可用。<br>AMediaFormat *|AMediaMuxer_getTrackFormat(AMediaMuxer *muxer, size_t idx)|返回传递给 AMediaMuxer_new 的文件中具有索引 idx 的添加轨道的 AMediaFormat 或传递给 AMediaMuxer_append 的文件中具有索引 idx 的现有轨道的 AMediaFormat。|应在 INITIALIZED 或 STARTED 状态下调用，否则返回 nullptr。AMediaFormat_delete 应该用于释放返回的指针。<br>自 API 级别 31 起可用。<br>AMediaMuxer *|AMediaMuxer_new(int fd, OutputFormat format)|创建新的媒体复用器。|自 API 级别 21 起可用。<br>media_status_t|AMediaMuxer_setLocation(AMediaMuxer *, float latitude, float longitude)|在输出文件中设置和存储地理数据（纬度和经度）。|此方法应在 AMediaMuxer_start 之前调用。 如果输出格式为 AMEDIAMUXER_OUTPUT_FORMAT_MPEG_4，则地理数据存储在 udta 框中，其他输出格式将忽略该地理数据。地理数据是根据 ISO-6709 标准存储的。<br>这两个值都以度数指定。纬度必须在 [-90, 90] 范围内。经度必须在 [-180, 180] 范围内。<br>自 API 级别 21 起可用。<br>media_status_t|AMediaMuxer_setOrientationHint(AMediaMuxer *, int degrees)|设置输出视频播放的方向提示。|此方法应在 AMediaMuxer_start 之前调用。调用此方法不会在muxer生成文件时旋转视频帧，但如果输出格式为AMEDIAMUXER_OUTPUT_FORMAT_MPEG_4，则在输出视频中添加一个包含旋转角度的合成矩阵，以便视频播放器可以选择合适的方向进行播放。请注意，某些视频播放器可能会在播放过程中选择忽略合成矩阵。角度以度数指定，顺时针方向。支持的角度为 0、90、180 和 270 度。<br>自 API 级别 21 起可用。<br>media_status_t|AMediaMuxer_start(AMediaMuxer *)|启动多路复用器。|应在 AMediaMuxer_addTrack 之后和 AMediaMuxer_writeSampleData 之前调用。<br>自 API 级别 21 起可用。<br>media_status_t|AMediaMuxer_stop(AMediaMuxer *)|停止多路复用器。|一旦多路复用器停止，就无法重新启动。<br>自 API 级别 21 起可用。<br>media_status_t|AMediaMuxer_writeSampleData(AMediaMuxer *muxer, size_t trackIdx, const uint8_t *data, const AMediaCodecBufferInfo *info)|将编码采样写入复用器。|应用程序需要确保将采样写入正确的轨道。 此外，它还需要确保每个轨道的采样按时间顺序写入（例如，按照编码器提供的顺序）。<br>自 API 级别 21 起可用。</p><hr></div><hr><div><div class="post-metas my-3"></div><div class="license-box my-3"><div class="license-title"><div>Android NDK API 之 Media</div><div>https://weichao.io/5eb1e22b219a/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>魏超</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2021年8月27日</div></div><div class="license-meta-item license-meta-date"><div>更新于</div><div>2022年12月4日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i> </span></a><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="NC - 非商业性使用"><i class="iconfont icon-nc"></i> </span></a><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="SA - 相同方式共享"><i class="iconfont icon-sa"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/9a2c5ee31f69/" title="Android NDK sample 之 MegaDrone"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Android NDK sample 之 MegaDrone</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/e080eb5d7f17/" title="Android NDK API 之 Asset"><span class="hidden-mobile">Android NDK API 之 Asset</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><i class="iconfont icon-my-hexo"></i>&nbsp;<span>博客框架Hexo&nbsp;&nbsp;</span></a> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><i class="iconfont icon-my-theme"></i>&nbsp;<span>博客主题Fluid&nbsp;&nbsp;</span></a> <a href="https://weichao.io" target="_blank" rel="nofollow noopener"><i class="iconfont icon-my-copyright"></i>&nbsp;2023<span>魏超</span></a></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>