<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/my_icon.ico"><link rel="icon" href="/img/my_icon.ico"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="魏超"><meta name="keywords" content="魏超,weichao"><meta name="description" content="Reference  输入某二叉树的前序遍历和中序遍历的结果，重建此二叉树。 剑指offer最优解Java版-二叉树的下一个结点    赋值运算符函数 Java 不支持用户自定义操作符重载。   实现 Singleton 模式  设计一个类，我们只能生成该类的一个实例。   饿汉式 123456789public class SingleTon&amp;#123;	private static Sing"><meta property="og:type" content="article"><meta property="og:title" content="《剑指 Offer》算法题（10&#x2F;68）"><meta property="og:url" content="https://weichao.io/db7d7a2f7b38/index.html"><meta property="og:site_name" content="『魏超』的 blog"><meta property="og:description" content="Reference  输入某二叉树的前序遍历和中序遍历的结果，重建此二叉树。 剑指offer最优解Java版-二叉树的下一个结点    赋值运算符函数 Java 不支持用户自定义操作符重载。   实现 Singleton 模式  设计一个类，我们只能生成该类的一个实例。   饿汉式 123456789public class SingleTon&amp;#123;	private static Sing"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E3%80%8A%E5%89%91%E6%8C%87%20Offer%E3%80%8B%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%881068%EF%BC%891.png"><meta property="og:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E3%80%8A%E5%89%91%E6%8C%87%20Offer%E3%80%8B%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%881068%EF%BC%892.png"><meta property="og:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E3%80%8A%E5%89%91%E6%8C%87%20Offer%E3%80%8B%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%881068%EF%BC%893.png"><meta property="og:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E3%80%8A%E5%89%91%E6%8C%87%20Offer%E3%80%8B%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%881068%EF%BC%894.png"><meta property="og:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E3%80%8A%E5%89%91%E6%8C%87%20Offer%E3%80%8B%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%881068%EF%BC%895.PNG"><meta property="og:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E3%80%8A%E5%89%91%E6%8C%87%20Offer%E3%80%8B%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%881068%EF%BC%896.PNG"><meta property="og:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E3%80%8A%E5%89%91%E6%8C%87%20Offer%E3%80%8B%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%881068%EF%BC%897.PNG"><meta property="og:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E3%80%8A%E5%89%91%E6%8C%87%20Offer%E3%80%8B%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%881068%EF%BC%898.PNG"><meta property="og:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E3%80%8A%E5%89%91%E6%8C%87%20Offer%E3%80%8B%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%881068%EF%BC%899.PNG"><meta property="og:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E3%80%8A%E5%89%91%E6%8C%87%20Offer%E3%80%8B%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%881068%EF%BC%8910.PNG"><meta property="article:published_time" content="2020-03-16T15:14:01.000Z"><meta property="article:modified_time" content="2022-12-04T06:04:05.239Z"><meta property="article:author" content="魏超"><meta property="article:tag" content="魏超,weichao"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E3%80%8A%E5%89%91%E6%8C%87%20Offer%E3%80%8B%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%881068%EF%BC%891.png"><title>《剑指 Offer》算法题（10/68） - 『魏超』的 blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1956623_vyed6le6uz.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"weichao.io",root:"/",version:"1.9.4",typing:{enable:!1,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!1},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:2},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!0,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"kQcwfNV9f5OTEb51AgXNco4o-gzGzoHsz",app_key:"IVVmse4bqkjcVx2bEJiswbJc",server_url:"https://kqcwfnv9.lc-cn-n1-shared.com",path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>『魏超』的 blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-my-home"></i> <span>首页</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-my-document"></i> <span>文档</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/archives/"><i class="iconfont icon-my-archive"></i> <span>归档</span> </a><a class="dropdown-item" href="/categories/"><i class="iconfont icon-my-category"></i> <span>分类</span> </a><a class="dropdown-item" href="/tags/"><i class="iconfont icon-my-tag"></i> <span>标签</span></a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-my-image"></i> <span>图库</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/photo/"><i class="iconfont icon-my-camera"></i> <span>摄影</span> </a><a class="dropdown-item" href="/skiing/"><i class="iconfont icon-my-skiing"></i> <span>滑雪</span> </a><a class="dropdown-item" href="/motor/"><i class="iconfont icon-my-motor"></i> <span>摩托车</span></a></div></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-my-me"></i> <span>关于</span></a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-my-link"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/my_background.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle">《剑指 Offer》算法题（10/68）</span></div><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> 魏超 </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2020-03-16 23:14" pubdate>2020年3月16日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 21k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 173 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">《剑指 Offer》算法题（10/68）</h1><p class="note note-info">本文最后更新于：1 年前</p><div class="markdown-body"><h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> <strong>Reference</strong></h1><ul><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/Yeoman92/article/details/77868367" title="https://blog.csdn.net/Yeoman92/article/details/77868367">输入某二叉树的前序遍历和中序遍历的结果，重建此二叉树。</a></li><li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/940aa4243829" title="https://www.jianshu.com/p/940aa4243829">剑指offer最优解Java版-二叉树的下一个结点</a></li></ul><hr><h1 id="赋值运算符函数"><a class="markdownIt-Anchor" href="#赋值运算符函数"></a> <strong>赋值运算符函数</strong></h1><p>Java 不支持用户自定义操作符重载。</p><hr><h1 id="实现-singleton-模式"><a class="markdownIt-Anchor" href="#实现-singleton-模式"></a> <strong>实现 Singleton 模式</strong></h1><blockquote><p>设计一个类，我们只能生成该类的一个实例。</p></blockquote><h2 id="饿汉式"><a class="markdownIt-Anchor" href="#饿汉式"></a> <strong>饿汉式</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleTon</span>&#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">SingleTon</span> <span class="hljs-variable">mSingleTon</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingleTon</span>();<br>	<br>	<span class="hljs-keyword">private</span> <span class="hljs-title function_">SingleTon</span><span class="hljs-params">()</span> &#123;&#125;<br>	<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingleTon <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> mSingleTon;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="懒汉式线程不安全"><a class="markdownIt-Anchor" href="#懒汉式线程不安全"></a> <strong>懒汉式(线程不安全)</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleTon</span>&#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">SingleTon</span> <span class="hljs-variable">mSingleTon</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>	<br>	<span class="hljs-keyword">private</span> <span class="hljs-title function_">SingleTon</span><span class="hljs-params">()</span> &#123;&#125;<br>	<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingleTon <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">if</span>(mSingleTon == <span class="hljs-literal">null</span>) &#123;<br>			mSingleTon = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingleTon</span>();<br>		&#125;<br>		<span class="hljs-keyword">return</span> mSingleTon;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="懒汉式线程安全"><a class="markdownIt-Anchor" href="#懒汉式线程安全"></a> <strong>懒汉式(线程安全)</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleTon</span>&#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">SingleTon</span> <span class="hljs-variable">mSingleTon</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>	<br>	<span class="hljs-keyword">private</span> <span class="hljs-title function_">SingleTon</span><span class="hljs-params">()</span> &#123;&#125;<br>	<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> SingleTon <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">if</span>(mSingleTon == <span class="hljs-literal">null</span>) &#123;<br>			mSingleTon = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingleTon</span>();<br>		&#125;<br>		<span class="hljs-keyword">return</span> mSingleTon;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="懒汉式双重校验锁线程不一定安全"><a class="markdownIt-Anchor" href="#懒汉式双重校验锁线程不一定安全"></a> <strong>懒汉式(双重校验锁，线程不一定安全)</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleTon</span>&#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">SingleTon</span> <span class="hljs-variable">mSingleTon</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>	<br>	<span class="hljs-keyword">private</span> <span class="hljs-title function_">SingleTon</span><span class="hljs-params">()</span> &#123;&#125;<br>	<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingleTon <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">if</span>(mSingleTon == <span class="hljs-literal">null</span>)&#123;<br>			<span class="hljs-keyword">synchronized</span>(SingleTon.class) &#123;<br>				<span class="hljs-keyword">if</span>(mSingleTon == <span class="hljs-literal">null</span>) &#123;<br>					mSingleTon = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingleTon</span>();<br>				&#125;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">return</span> mSingleTon;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="懒汉式双重校验锁线程安全"><a class="markdownIt-Anchor" href="#懒汉式双重校验锁线程安全"></a> <strong>懒汉式(双重校验锁，线程安全)</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleTon</span>&#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">SingleTon</span> <span class="hljs-variable">mSingleTon</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>	<br>	<span class="hljs-keyword">private</span> <span class="hljs-title function_">SingleTon</span><span class="hljs-params">()</span> &#123;&#125;<br>	<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingleTon <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">if</span>(mSingleTon == <span class="hljs-literal">null</span>)&#123;<br>			<span class="hljs-keyword">synchronized</span>(SingleTon.class) &#123;<br>				<span class="hljs-keyword">if</span>(mSingleTon == <span class="hljs-literal">null</span>) &#123;<br>					mSingleTon = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingleTon</span>();<br>				&#125;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">return</span> mSingleTon;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="枚举"><a class="markdownIt-Anchor" href="#枚举"></a> <strong>枚举</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">SingleTon</span> &#123;<br>	SINGLE<br>&#125;<br><br>SingleTon.SINGLE<br></code></pre></td></tr></table></figure><h2 id="静态内部类"><a class="markdownIt-Anchor" href="#静态内部类"></a> <strong>静态内部类</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleTon</span> &#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InnerClass</span> &#123;<br>		<span class="hljs-keyword">static</span> <span class="hljs-type">SingleTon</span> <span class="hljs-variable">mSingleTon</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingleTon</span>();<br>	&#125;<br>	<br>	<span class="hljs-keyword">private</span> <span class="hljs-title function_">SingleTon</span><span class="hljs-params">()</span> &#123;&#125;<br>	<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingleTon <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> InnerClass.mSingleTon;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="数组中重复的数字"><a class="markdownIt-Anchor" href="#数组中重复的数字"></a> <strong>数组中重复的数字</strong></h1><h2 id="找出数组中重复的数字"><a class="markdownIt-Anchor" href="#找出数组中重复的数字"></a> <strong>找出数组中重复的数字</strong></h2><blockquote><p>在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了。也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为 7 的数组 {2, 3, 1, 0, 2, 5, 3}，那么对应的输出是重复的数字 2 或者 3。</p></blockquote><p>思路：<br>观察值的范围，当数组中没有重复数字时，排序之后的结果应该是值和索引一一对应。以此为突破口，尝试给数组排序。<br>遍历数组，当值和索引相等时，继续处理下个索引的值；否则，比较当前值（arr[i] == m）和值作为索引的值（arr[m]），如果相等则说明找到了重复的数字，否则，交换两个值，再执行该过程。<br><img src="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E3%80%8A%E5%89%91%E6%8C%87%20Offer%E3%80%8B%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%881068%EF%BC%891.png" alt=""></p><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, size = arr.length; i &lt; size; i++) &#123;<br>        <span class="hljs-keyword">while</span> (arr[i] != i) &#123;<br>            <span class="hljs-keyword">if</span> (arr[i] == arr[arr[i]]) &#123;<br>                <span class="hljs-keyword">return</span> arr[i];<br>            &#125;<br><br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>            arr[i] = arr[temp];<br>            arr[temp] = temp;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> find(arr);<br>System.out.println(<span class="hljs-string">&quot;value:&quot;</span> + value);<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n)。代码中尽管有一个两重循环，但每个数字最多只要交换两次就能找到位置。<br>空间复杂度：O(1)。所有操作都是在输入数组上进行，不需要额外分配内存。</p><h2 id="不修改数组找出重复的数字"><a class="markdownIt-Anchor" href="#不修改数组找出重复的数字"></a> <strong>不修改数组找出重复的数字</strong></h2><blockquote><p>在一个长度为 n + 1 的数组里的所有数字都在 1 到 n 的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，如果输入长度为 8 的数组 {2, 3, 5, 4, 3, 2, 6, 7}，那么对应的输出是重复的数字 2 或者 3。</p></blockquote><p>思路：<br>将值按照大于 m 值的和不大于 m 值的分为大、小两个区间，数组如果不重复（n 个元素对应 1~n），则大区间中必有 m 个元素，且小区间中必有 n - m 个元素，但是由于多 1 个元素，所以至少有大区间元素个数大于 m，或小区间元素个数大于 m - n。以此为突破口，统计数组在各区间元素的个数。<br>遍历数组，找到元素个数大于区间的，将该区间重新划分大、小两个区间；重复此步骤，直至区间不可再划分。</p><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (end &gt;= start) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">middle</span> <span class="hljs-operator">=</span> ((end - start) &gt;&gt; <span class="hljs-number">1</span>) + start;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> count(arr, start, middle);<br>        <span class="hljs-keyword">if</span> (start == middle) &#123;<br>            <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> start;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (count &gt; middle - start + <span class="hljs-number">1</span>) &#123;<br>            end = middle;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            start = middle + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">count</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> middle)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : arr) &#123;<br>        <span class="hljs-keyword">if</span> (i &gt;= start &amp;&amp; i &lt;= middle) &#123;<br>            count++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;;<br><span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> find(arr);<br>System.out.println(<span class="hljs-string">&quot;value:&quot;</span> + value);<br></code></pre></td></tr></table></figure><p>时间复杂度：O(nlogn)。数组长度为 n，是 O(n)，二分查找是 O(logn)，所以总时间是 O(nlogn)。<br>空间复杂度：O(1)。</p><hr><h1 id="二维数组中的查找"><a class="markdownIt-Anchor" href="#二维数组中的查找"></a> <strong>二维数组中的查找</strong></h1><blockquote><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p></blockquote><p>思路：<br>二维数组行、列都是有序的，所以如果列的第一个元素大于目标值时，则目标值不可能在此列；同理，行也一样。以此为突破口，先用二分法缩小目标可能存在的范围，再遍历。<br>使用二分法找到中间列，判断列的第一个元素和目标值的大小关系，如果等于，说明找到了，直接返回；如果大于，记录位置为 C1；如果小于，记录位置为 C2。重复此过程，直到 C2 &gt;= C1，则找到了列在遍历时的最大值 C2 - 1。同理，再找到行在遍历时的最大值。然后从列的最大值开始遍历，查找目标值。<br><img src="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E3%80%8A%E5%89%91%E6%8C%87%20Offer%E3%80%8B%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%881068%EF%BC%892.png" alt=""></p><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contain</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] arr, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxCol</span> <span class="hljs-operator">=</span> findMaxCol(arr, target);<br>    <span class="hljs-keyword">if</span> (arr[<span class="hljs-number">0</span>][maxCol] == target) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxRow</span> <span class="hljs-operator">=</span> findMaxRow(arr, target);<br>    <span class="hljs-keyword">if</span> (arr[maxRow][<span class="hljs-number">0</span>] == target) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> maxCol; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> maxCol - j; i &lt;= maxRow; i++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[i][j] == target) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[i][j] &gt; target) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMaxCol</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] arr, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (end &gt;= start) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">middle</span> <span class="hljs-operator">=</span> ((end - start) &gt;&gt; <span class="hljs-number">1</span>) + start;<br>        <span class="hljs-keyword">if</span> (arr[<span class="hljs-number">0</span>][middle] == target) &#123;<br>            <span class="hljs-keyword">return</span> middle;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[<span class="hljs-number">0</span>][middle] &gt; target) &#123;<br>            end = middle - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            start = middle + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> start - <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMaxRow</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] arr, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (end &gt;= start) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">middle</span> <span class="hljs-operator">=</span> ((end - start) &gt;&gt; <span class="hljs-number">1</span>) + start;<br>        <span class="hljs-keyword">if</span> (arr[middle][<span class="hljs-number">0</span>] == target) &#123;<br>            <span class="hljs-keyword">return</span> middle;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arr[middle][<span class="hljs-number">0</span>] &gt; target) &#123;<br>            end = middle - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            start = middle + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> start - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[][] arr = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">12</span>&#125;, &#123;<span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">10</span>, <span class="hljs-number">13</span>&#125;, &#123;<span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">11</span>, <span class="hljs-number">15</span>&#125;&#125;;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> contain(arr, <span class="hljs-number">7</span>);<br>System.out.println(<span class="hljs-string">&quot;contain:&quot;</span> + b);<br></code></pre></td></tr></table></figure><p>时间复杂度：<br>空间复杂度：O(1)。</p><hr><h1 id="替换空格"><a class="markdownIt-Anchor" href="#替换空格"></a> <strong>替换空格</strong></h1><blockquote><p>请实现一个函数，把字符串中的每个空格替换成&quot;%20&quot;。例如，输入&quot;We are happy.“，则输出&quot;We%20are%20happy.”。</p></blockquote><p>思路：<br>操作同一个数组时，如果从前往后替换会导致后面的数据被覆盖。因为每替换 1 个空格，数组所需的长度需要 + 2，所以可以以此为突破口，从后往前替换。<br>统计字符串中空格的个数，先计算出替换后的长度，由于 Java 数组长度不可变，所以以计算出的长度重新申请一块内存，然后再从后往前遍历，遇到空格时替换为%20，否则直接复制。<br><img src="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E3%80%8A%E5%89%91%E6%8C%87%20Offer%E3%80%8B%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%881068%EF%BC%893.png" alt=""></p><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">convert</span><span class="hljs-params">(StringBuffer stringBuffer)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, size = stringBuffer.length(); i &lt; size; i++) &#123;<br>        <span class="hljs-keyword">if</span> (stringBuffer.charAt(i) == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            count++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldLen</span> <span class="hljs-operator">=</span> stringBuffer.length();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">newLen</span> <span class="hljs-operator">=</span> oldLen + (count &lt;&lt; <span class="hljs-number">1</span>);<br>    stringBuffer.setLength(newLen);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> oldLen - <span class="hljs-number">1</span>, j = newLen - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--, j--) &#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> stringBuffer.charAt(i);<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>            stringBuffer.setCharAt(j, <span class="hljs-string">&#x27;0&#x27;</span>);<br>            stringBuffer.setCharAt(--j, <span class="hljs-string">&#x27;2&#x27;</span>);<br>            stringBuffer.setCharAt(--j, <span class="hljs-string">&#x27;%&#x27;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            stringBuffer.setCharAt(j, c);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StringBuffer</span> <span class="hljs-variable">stringBuffer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(<span class="hljs-string">&quot;We are happy.&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;stringBuffer:&quot;</span> + stringBuffer.toString());<br>convert(stringBuffer);<br>System.out.println(<span class="hljs-string">&quot;stringBuffer:&quot;</span> + stringBuffer.toString());<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n)。<br>空间复杂度：O(n)。</p><h2 id="相关题目把数组-a2-中的所有数字插入数组-a1-中"><a class="markdownIt-Anchor" href="#相关题目把数组-a2-中的所有数字插入数组-a1-中"></a> <strong>相关题目：把数组 A2 中的所有数字插入数组 A1 中</strong></h2><blockquote><p>有两个排序的数组 A1 和 A2，内存在 A1 的末尾有足够多的空余空间容纳 A2。请实现一个函数，把 A2 中的所有数字插入 A1 中，并且所有的数字是排序的。</p></blockquote><p>思路：<br>合并两个数组，可以知道两个数组占用的总的空间大小。以此为突破口，合并数组 A2 到 A1。<br>计算总大小，比较数组 A1 和 A2 各自最后位置的元素的大小，将更大的元素放到末尾。</p><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 随机初始化数组中的元素</span><br><span class="hljs-type">int</span>[] arr1src = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br><span class="hljs-type">int</span>[] arr2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br><span class="hljs-type">int</span> <span class="hljs-variable">beforeValue</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, size = arr1src.length; i &lt; size; i++) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">10</span>);<br>    beforeValue += random;<br>    arr1src[i] = beforeValue;<br>&#125;<br>beforeValue = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, size = arr2.length; i &lt; size; i++) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">10</span>);<br>    beforeValue += random;<br>    arr2[i] = beforeValue;<br>&#125;<br><br><span class="hljs-type">int</span>[] arr1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">100</span>];<br>System.arraycopy(arr1src, <span class="hljs-number">0</span>, arr1, <span class="hljs-number">0</span>, arr1src.length); <span class="hljs-comment">// 由于 Java 中数组长度不可变，此处假装数组 A1 末尾有足够多的空余空间</span><br>System.out.println(<span class="hljs-string">&quot;arr1:&quot;</span> + Arrays.toString(arr1));<br>System.out.println(<span class="hljs-string">&quot;arr2:&quot;</span> + Arrays.toString(arr2));<br><br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> arr1src.length - <span class="hljs-number">1</span>, j = arr2.length - <span class="hljs-number">1</span>, index = arr1src.length + arr2.length - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">v1</span> <span class="hljs-operator">=</span> arr1[i];<br>    <span class="hljs-type">int</span> <span class="hljs-variable">v2</span> <span class="hljs-operator">=</span> arr2[j];<br>    <span class="hljs-keyword">if</span> (v1 == v2) &#123;<br>        arr1[index--] = v1;<br>        arr1[index--] = v2;<br>        i--;<br>        j--;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v1 &gt; v2) &#123;<br>        arr1[index--] = v1;<br>        i--;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        arr1[index--] = v2;<br>        j--;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">if</span> (j &gt;= <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 最小值在 A2 数组时，直接把剩余元素复制到 A1 数组开头</span><br>    System.arraycopy(arr2, <span class="hljs-number">0</span>, arr1, <span class="hljs-number">0</span>, j + <span class="hljs-number">1</span>);<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;arr1:&quot;</span> + Arrays.toString(arr1));<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n)。<br>空间复杂度：O(1)。</p><hr><h1 id="从尾到头打印链表"><a class="markdownIt-Anchor" href="#从尾到头打印链表"></a> <strong>从尾到头打印链表</strong></h1><blockquote><p>输入一个链表的头节点，从尾到头反过来打印出每个节点的值。</p></blockquote><p>思路：<br>判断单向链表中的节点，如果持有节点为空，则说明不是该节点是尾节点，可以打印了；否则可以继续判断持有的节点是否还持有节点。循环此过程。</p><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> value;<br>    <span class="hljs-keyword">private</span> Node next;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> value, Node next)</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>        <span class="hljs-built_in">this</span>.next = next;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">getNext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.next;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.value;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-keyword">if</span> (node.getNext() != <span class="hljs-literal">null</span>) &#123;<br>        print(node.getNext());<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;value:&quot;</span> + node.getValue());<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>    node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(i, node);<br>&#125;<br><br><span class="hljs-type">Node</span> <span class="hljs-variable">firstNode</span> <span class="hljs-operator">=</span> node;<br><br><span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span>) &#123;<br>    System.out.println(<span class="hljs-string">&quot;value:&quot;</span> + node.getValue());<br>    node = node.getNext();<br>&#125;<br><br>print(firstNode);<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n)。<br>空间复杂度：O(1)。</p><hr><h1 id="重建二叉树"><a class="markdownIt-Anchor" href="#重建二叉树"></a> <strong>重建二叉树</strong></h1><blockquote><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1, 2, 4, 7, 3, 5, 6, 8}和中序遍历序列{4, 7, 2, 1, 5, 3, 8, 6}，则重建二叉树并输出它的头节点。</p></blockquote><p>思路：<br><img src="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E3%80%8A%E5%89%91%E6%8C%87%20Offer%E3%80%8B%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%881068%EF%BC%894.png" alt=""><br>（1）前序遍历看根节点；<br>（2）中序遍历看左子树、右子树；<br>（3）把子树值带回前序遍历，排在前面的是根节点；<br>（4）重复（2）（3）过程，直到左子树、右子树为空。</p><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> value;<br>    <span class="hljs-keyword">private</span> Node left;<br>    <span class="hljs-keyword">private</span> Node right;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">getLeft</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setLeft</span><span class="hljs-params">(Node left)</span> &#123;<br>        <span class="hljs-built_in">this</span>.left = left;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">getRight</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRight</span><span class="hljs-params">(Node right)</span> &#123;<br>        <span class="hljs-built_in">this</span>.right = right;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> Node <span class="hljs-title function_">create</span><span class="hljs-params">(<span class="hljs-type">int</span>[] preorderArr, <span class="hljs-type">int</span>[] inorderArr)</span> &#123;<br>    <span class="hljs-keyword">if</span> (preorderArr == <span class="hljs-literal">null</span> || preorderArr.length == <span class="hljs-number">0</span> ||<br>            inorderArr == <span class="hljs-literal">null</span> || inorderArr.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(preorderArr[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, size = inorderArr.length; i &lt; size; i++) &#123;<br>        <span class="hljs-keyword">if</span> (preorderArr[<span class="hljs-number">0</span>] == inorderArr[i]) &#123; <span class="hljs-comment">// 根节点</span><br>            node.setLeft(create(Arrays.copyOfRange(preorderArr, <span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>), Arrays.copyOfRange(inorderArr, <span class="hljs-number">0</span>, i)));<br>            node.setRight(create(Arrays.copyOfRange(preorderArr, i + <span class="hljs-number">1</span>, preorderArr.length), Arrays.copyOfRange(inorderArr, i + <span class="hljs-number">1</span>, inorderArr.length)));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] preorderArr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>&#125;;<br><span class="hljs-type">int</span>[] inorderArr = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>&#125;;<br><br><span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> create(preorderArr, inorderArr);<br>System.out.println(<span class="hljs-string">&quot;node:&quot;</span> + node.getValue());<br></code></pre></td></tr></table></figure><p>时间复杂度：O(nlogn)。<br>空间复杂度：O(n)。</p><h2 id="扩展输入某二叉树的中序遍历和后序遍历的结果重建出该二叉树"><a class="markdownIt-Anchor" href="#扩展输入某二叉树的中序遍历和后序遍历的结果重建出该二叉树"></a> <strong>扩展：输入某二叉树的中序遍历和后序遍历的结果，重建出该二叉树</strong></h2><p>思路：<br>（1）后序遍历看根节点；<br>（2）中序遍历看左子树、右子树；<br>（3）把子树值带回后序遍历，排在前面的是根节点；<br>（4）重复（2）（3）过程，直到左子树、右子树为空。</p><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">create</span><span class="hljs-params">(<span class="hljs-type">int</span>[] inorderArr, <span class="hljs-type">int</span>[] postorderArr)</span> &#123;<br>    <span class="hljs-keyword">if</span> (inorderArr == <span class="hljs-literal">null</span> || inorderArr.length == <span class="hljs-number">0</span> ||<br>            postorderArr == <span class="hljs-literal">null</span> || postorderArr.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(postorderArr[postorderArr.length - <span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, size = inorderArr.length; i &lt; size; i++) &#123;<br>        <span class="hljs-keyword">if</span> (postorderArr[postorderArr.length - <span class="hljs-number">1</span>] == inorderArr[i]) &#123; <span class="hljs-comment">// 根节点</span><br>            node.setLeft(create(Arrays.copyOfRange(inorderArr, <span class="hljs-number">0</span>, i), Arrays.copyOfRange(postorderArr, <span class="hljs-number">0</span>, i)));<br>            node.setRight(create(Arrays.copyOfRange(inorderArr, i + <span class="hljs-number">1</span>, inorderArr.length), Arrays.copyOfRange(postorderArr, i, postorderArr.length - <span class="hljs-number">1</span>)));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] inorderArr = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>&#125;;<br><span class="hljs-type">int</span>[] postorderArr = &#123;<span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>&#125;;<br><br><span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> create(inorderArr, postorderArr);<br>System.out.println(<span class="hljs-string">&quot;node:&quot;</span> + node.getValue());<br></code></pre></td></tr></table></figure><hr><h1 id="二叉树的下一个节点"><a class="markdownIt-Anchor" href="#二叉树的下一个节点"></a> <strong>二叉树的下一个节点</strong></h1><blockquote><p>给定一棵二叉树和其中的一个节点，如何找出中序遍历序列的下一个节点？树中的结点除了有两个分别指向左、右子节点的指针，还有一个指向父节点的指针。</p></blockquote><p>思路：<br>分情况讨论——<br>（1）给出的节点有右子树，则沿着右子树向下遍历左子节点，最左子节点是下一个节点；<br><img src="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E3%80%8A%E5%89%91%E6%8C%87%20Offer%E3%80%8B%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%881068%EF%BC%895.PNG" alt=""><br>（2）给出的节点没有右子树，如果它是父节点的右子节点，则沿着父节点向上遍历，直到节点是父节点的左子节点，则该节点的父节点是下一个节点；<br><img src="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E3%80%8A%E5%89%91%E6%8C%87%20Offer%E3%80%8B%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%881068%EF%BC%896.PNG" alt=""><br>（3）给出的节点没有右子树，如果它是父节点的左子节点，则父节点是下一个节点。（3）是（2）的特例。<br><img src="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E3%80%8A%E5%89%91%E6%8C%87%20Offer%E3%80%8B%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%881068%EF%BC%897.PNG" alt=""></p><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">char</span> value;<br>    <span class="hljs-keyword">private</span> Node left;<br>    <span class="hljs-keyword">private</span> Node right;<br>    <span class="hljs-keyword">private</span> Node parent;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">char</span> value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">char</span> <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">getLeft</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setLeft</span><span class="hljs-params">(Node left)</span> &#123;<br>        <span class="hljs-built_in">this</span>.left = left;<br>        left.setParent(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">getRight</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> right;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRight</span><span class="hljs-params">(Node right)</span> &#123;<br>        <span class="hljs-built_in">this</span>.right = right;<br>        right.setParent(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Node <span class="hljs-title function_">getParent</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> parent;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setParent</span><span class="hljs-params">(Node parent)</span> &#123;<br>        <span class="hljs-built_in">this</span>.parent = parent;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> Node <span class="hljs-title function_">inorderNext</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-keyword">if</span> (node.getRight() != <span class="hljs-literal">null</span>) &#123;<br>        node = node.getRight();<br>        <span class="hljs-keyword">while</span> (node.getLeft() != <span class="hljs-literal">null</span>) &#123;<br>            node = node.getLeft();<br>        &#125;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">while</span> (node.getParent() != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (node.equals(node.getParent().getLeft())) &#123;<br>                <span class="hljs-keyword">return</span> node.getParent();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                node = node.getParent();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 初始化二叉树</span><br>ArrayList&lt;Node&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-number">14</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">14</span>; i++) &#123;<br>    list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>((<span class="hljs-type">char</span>) (<span class="hljs-string">&#x27;A&#x27;</span> + i)));<br>&#125;<br>list.get(<span class="hljs-number">0</span>).setLeft(list.get(<span class="hljs-number">1</span>));<br>list.get(<span class="hljs-number">0</span>).setRight(list.get(<span class="hljs-number">2</span>));<br>list.get(<span class="hljs-number">1</span>).setLeft(list.get(<span class="hljs-number">3</span>));<br>list.get(<span class="hljs-number">1</span>).setRight(list.get(<span class="hljs-number">4</span>));<br>list.get(<span class="hljs-number">2</span>).setLeft(list.get(<span class="hljs-number">5</span>));<br>list.get(<span class="hljs-number">2</span>).setRight(list.get(<span class="hljs-number">6</span>));<br>list.get(<span class="hljs-number">3</span>).setRight(list.get(<span class="hljs-number">7</span>));<br>list.get(<span class="hljs-number">4</span>).setLeft(list.get(<span class="hljs-number">8</span>));<br>list.get(<span class="hljs-number">4</span>).setRight(list.get(<span class="hljs-number">9</span>));<br>list.get(<span class="hljs-number">5</span>).setRight(list.get(<span class="hljs-number">10</span>));<br>list.get(<span class="hljs-number">6</span>).setLeft(list.get(<span class="hljs-number">11</span>));<br>list.get(<span class="hljs-number">6</span>).setRight(list.get(<span class="hljs-number">12</span>));<br>list.get(<span class="hljs-number">7</span>).setLeft(list.get(<span class="hljs-number">13</span>));<br><br><span class="hljs-keyword">for</span> (Node node : list) &#123;<br>    System.out.println(<span class="hljs-string">&quot;node:&quot;</span> + node.getValue() + <span class="hljs-string">&quot;; next node:&quot;</span> + ((node = inorderNext(node)) == <span class="hljs-literal">null</span> ? <span class="hljs-string">&quot;null&quot;</span> : node.getValue()));<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：<br>空间复杂度：O(1)。</p><h2 id="扩展前序遍历"><a class="markdownIt-Anchor" href="#扩展前序遍历"></a> <strong>扩展：前序遍历</strong></h2><p>思路：前序遍历的顺序是节点-&gt;左子节点-&gt;右子节点。</p><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preorder</span><span class="hljs-params">(ArrayList&lt;Node&gt; list, Node node)</span> &#123;<br>    list.add(node);<br>    <span class="hljs-keyword">if</span> (node.getLeft() != <span class="hljs-literal">null</span>) &#123;<br>        preorder(list, node.getLeft());<br>    &#125;<br>    <span class="hljs-keyword">if</span> (node.getRight() != <span class="hljs-literal">null</span>) &#123;<br>        preorder(list, node.getRight());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Node&gt; preorderList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-number">14</span>);<br>preorder(preorderList, list.get(<span class="hljs-number">0</span>));<br><span class="hljs-keyword">for</span> (Node node : preorderList) &#123;<br>    System.out.println(<span class="hljs-string">&quot;node:&quot;</span> + node.getValue());<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="扩展中序遍历"><a class="markdownIt-Anchor" href="#扩展中序遍历"></a> <strong>扩展：中序遍历</strong></h2><p>思路：中序遍历的顺序是左子节点-&gt;节点-&gt;右子节点。</p><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inorder</span><span class="hljs-params">(ArrayList&lt;Node&gt; list, Node node)</span> &#123;<br>    <span class="hljs-keyword">if</span> (node.getLeft() != <span class="hljs-literal">null</span>) &#123;<br>        inorder(list, node.getLeft());<br>    &#125;<br>    list.add(node);<br>    <span class="hljs-keyword">if</span> (node.getRight() != <span class="hljs-literal">null</span>) &#123;<br>        inorder(list, node.getRight());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Node&gt; inorderList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-number">14</span>);<br>inorder(inorderList, list.get(<span class="hljs-number">0</span>));<br><span class="hljs-keyword">for</span> (Node node : inorderList) &#123;<br>    System.out.println(<span class="hljs-string">&quot;node:&quot;</span> + node.getValue());<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="扩展后序遍历"><a class="markdownIt-Anchor" href="#扩展后序遍历"></a> <strong>扩展：后序遍历</strong></h2><p>思路：后序遍历的顺序是左子节点-&gt;右子节点-&gt;节点。</p><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postorder</span><span class="hljs-params">(ArrayList&lt;Node&gt; list, Node node)</span> &#123;<br>    <span class="hljs-keyword">if</span> (node.getLeft() != <span class="hljs-literal">null</span>) &#123;<br>        postorder(list, node.getLeft());<br>    &#125;<br>    <span class="hljs-keyword">if</span> (node.getRight() != <span class="hljs-literal">null</span>) &#123;<br>        postorder(list, node.getRight());<br>    &#125;<br>    list.add(node);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Node&gt; postorderList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-number">14</span>);<br>postorder(postorderList, list.get(<span class="hljs-number">0</span>));<br><span class="hljs-keyword">for</span> (Node node : postorderList) &#123;<br>    System.out.println(<span class="hljs-string">&quot;node:&quot;</span> + node.getValue());<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="扩展给定一棵二叉树和其中的一个节点找出前序遍历序列的下一个节点"><a class="markdownIt-Anchor" href="#扩展给定一棵二叉树和其中的一个节点找出前序遍历序列的下一个节点"></a> <strong>扩展：给定一棵二叉树和其中的一个节点，找出前序遍历序列的下一个节点</strong></h2><p>思路：<br>分情况讨论——<br>（1）给出的节点有左子节点，则下一个节点是该左子节点；<br>（2）给出的节点没有左子节点，但是有右子节点，则下一个节点是该右子节点；<br>（3）给出的节点没有子节点，如果它是父节点的右子节点，且有兄弟节点，则下一个节点是兄弟节点；如果它是父节点的右子节点，则沿着父节点向上遍历，直到节点是父节点的左子节点，并且有兄弟节点，则下一个节点是兄弟节点。</p><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Node <span class="hljs-title function_">preorderNext</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-keyword">if</span> (node.getLeft() != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> node.getLeft();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.getRight() != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> node.getRight();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">while</span> (node.getParent() != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (node.equals(node.getParent().getLeft()) &amp;&amp; node.getParent().getRight() != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> node.getParent().getRight();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                node = node.getParent();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> list.get(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span>) &#123;<br>    System.out.println(<span class="hljs-string">&quot;node:&quot;</span> + node.getValue() + <span class="hljs-string">&quot;; next node:&quot;</span> + ((node = preorderNext(node)) == <span class="hljs-literal">null</span> ? <span class="hljs-string">&quot;null&quot;</span> : node.getValue()));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="扩展给定一棵二叉树和其中的一个节点找出后序遍历序列的下一个节点"><a class="markdownIt-Anchor" href="#扩展给定一棵二叉树和其中的一个节点找出后序遍历序列的下一个节点"></a> <strong>扩展：给定一棵二叉树和其中的一个节点，找出后序遍历序列的下一个节点</strong></h2><p>思路：<br>分情况讨论——<br>（1）给出的节点没有父节点，则下一个节点是 null；<br>（2）给出的节点有父节点，且是左节点，如果没有兄弟节点，则下一个节点是父节点；否则，找到兄弟节点的最左子节点，如果该节点没有左子节点，但是有右子节点，则继续向下遍历，最后获取的节点就是下一个节点；<br>（3）给出的节点有父节点，且是右节点，则下一个节点是父节点。</p><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Node <span class="hljs-title function_">postorderNext</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-keyword">if</span> (node.getParent() == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (node.equals(node.getParent().getLeft())) &#123;<br>            <span class="hljs-keyword">if</span> (node.getParent().getRight() == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> node.getParent();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                node = node.getParent().getRight();<br>                <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">while</span> (node.getLeft() != <span class="hljs-literal">null</span>) &#123;<br>                        node = node.getLeft();<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (node.getRight() == <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-keyword">return</span> node;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        node = node.getRight();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> node.getParent();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (Node node : list) &#123;<br>    System.out.println(<span class="hljs-string">&quot;node:&quot;</span> + node.getValue() + <span class="hljs-string">&quot;; next node:&quot;</span> + ((node = postorderNext(node)) == <span class="hljs-literal">null</span> ? <span class="hljs-string">&quot;null&quot;</span> : node.getValue()));<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="用两个栈实现队列"><a class="markdownIt-Anchor" href="#用两个栈实现队列"></a> <strong>用两个栈实现队列</strong></h1><blockquote><p>用两个栈实现一个队列，分别完成在队列尾部插入节点和在队列头部删除节点的功能。</p></blockquote><p>思路：<br>队列的特点是先进先出。栈的特点是后进先出，进栈和出栈的顺序相反，如果数据从栈 A 出栈后依次入栈 B，再从栈 B 出栈，则出栈 B 时的顺序和入栈 A 时的顺序是一致的。以此为突破口，即可实现队列。<br>初始化栈 A、B，栈 A 用于存数据，栈 B 用于取数据。当栈 B 没数据时，会先将栈 A 的数据导入到栈 B，然后再从栈 B 取数据；当栈 B 有数据时，就直接从栈 B 取数据，后续存入栈 A 的数据，等到栈 B 没数据时，在取数据前才从栈 A 导入到栈 B。<br><img src="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E3%80%8A%E5%89%91%E6%8C%87%20Offer%E3%80%8B%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%881068%EF%BC%898.PNG" alt=""><br><img src="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E3%80%8A%E5%89%91%E6%8C%87%20Offer%E3%80%8B%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%881068%EF%BC%899.PNG" alt=""></p><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Queue</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> Stack&lt;T&gt; stack1;<br>    <span class="hljs-keyword">private</span> Stack&lt;T&gt; stack2;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Queue</span><span class="hljs-params">()</span> &#123;<br>        stack1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        stack2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(T t)</span> &#123;<br>        stack1.push(t);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (stack2.isEmpty()) &#123;<br>            <span class="hljs-keyword">while</span> (!stack1.isEmpty()) &#123;<br>                stack2.push(stack1.pop());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack2.pop();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;stack1:&quot;</span> + stack1.toString() + <span class="hljs-string">&quot;\nstack2:&quot;</span> + stack2.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>&lt;&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">128</span>);<br>    <span class="hljs-keyword">if</span> ((random &amp; <span class="hljs-number">4</span>) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">pop</span> <span class="hljs-operator">=</span> queue.pop();<br>            System.out.println(<span class="hljs-string">&quot;pop:&quot;</span> + pop + <span class="hljs-string">&quot;\n&quot;</span> + queue.toString());<br>        &#125; <span class="hljs-keyword">catch</span> (EmptyStackException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        queue.push(random);<br>        System.out.println(<span class="hljs-string">&quot;push:&quot;</span> + random + <span class="hljs-string">&quot;\n&quot;</span> + queue.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：<br>空间复杂度：</p><h2 id="相关题目用两个队列实现一个栈"><a class="markdownIt-Anchor" href="#相关题目用两个队列实现一个栈"></a> <strong>相关题目：用两个队列实现一个栈</strong></h2><p>思路：<br>初始化队列 A、B，两个队列都是用于存/取数据，但是同一时刻，只能有一个队列存数据，另一个队列中的数据为空。当取数据时，将前 n - 1 个数据导入到空队列中，返回倒数第 1 个数据，此时，原来的空队列已经有数据了，以后用于存数据，原来存数据的队列已经被清空了。两个队列交替，总是返回倒数第 1 个数据。<br><img src="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E3%80%8A%E5%89%91%E6%8C%87%20Offer%E3%80%8B%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%881068%EF%BC%8910.PNG" alt=""></p><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> ArrayDeque&lt;T&gt; queue1;<br>    <span class="hljs-keyword">private</span> ArrayDeque&lt;T&gt; queue2;<br>    <span class="hljs-keyword">private</span> ArrayDeque&lt;T&gt; pushQueue;<br>    <span class="hljs-keyword">private</span> ArrayDeque&lt;T&gt; popQueue;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Stack</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        queue1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;(capacity);<br>        queue2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;(capacity);<br>        pushQueue = queue1;<br>        popQueue = queue2;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(T t)</span> &#123;<br>        pushQueue.addLast(t);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, size = pushQueue.size(); i &lt; size - <span class="hljs-number">1</span>; i++) &#123;<br>            popQueue.add(pushQueue.removeFirst());<br>        &#125;<br>        <span class="hljs-keyword">if</span> (pushQueue == queue1) &#123;<br>            pushQueue = queue2;<br>            popQueue = queue1;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            pushQueue = queue1;<br>            popQueue = queue2;<br>        &#125;<br>        <span class="hljs-keyword">return</span> popQueue.removeFirst();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;queue1:&quot;</span> + queue1.toString() + <span class="hljs-string">&quot;\nqueue2:&quot;</span> + queue2.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;(<span class="hljs-number">20</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">128</span>);<br>    <span class="hljs-keyword">if</span> ((random &amp; <span class="hljs-number">6</span>) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">pop</span> <span class="hljs-operator">=</span> stack.pop();<br>            System.out.println(<span class="hljs-string">&quot;pop:&quot;</span> + pop + <span class="hljs-string">&quot;\n&quot;</span> + stack.toString());<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchElementException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        stack.push(random);<br>        System.out.println(<span class="hljs-string">&quot;push:&quot;</span> + random + <span class="hljs-string">&quot;\n&quot;</span> + stack.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="斐波那契数列"><a class="markdownIt-Anchor" href="#斐波那契数列"></a> <strong>斐波那契数列</strong></h1><blockquote><p>求斐波那契数列的第 n 项。</p></blockquote><p>思路：<br>递归由于多次重复计算，所以效率低。可以使用循环，由下向上计算。</p><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fibonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">preTwo</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">preOne</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>            value = preTwo + preOne;<br>            preTwo = preOne;<br>            preOne = value;<br>        &#125;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; n &lt; <span class="hljs-number">10</span>; n++) &#123;<br>    System.out.println(<span class="hljs-string">&quot;fibonacci[&quot;</span> + n + <span class="hljs-string">&quot;]:&quot;</span> + fibonacci(n));<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n)。<br>空间复杂度：O(1)。</p><h2 id="题目二青蛙跳台阶问题"><a class="markdownIt-Anchor" href="#题目二青蛙跳台阶问题"></a> <strong>题目二：青蛙跳台阶问题</strong></h2><blockquote><p>一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p></blockquote><p>思路：<br>把 n 级台阶时的跳法看成 n 的函数，计为 f(n)，当 n &gt; 2 时，如果第一次跳 1 级，则跳法数目等于剩余 n - 1 级台阶的跳法数目，即 f(n - 1)；如果第一次跳 2 级，则跳法数目等于剩余 n - 2 级台阶的跳法数目，即 f(n - 2)；因为第一次只能跳 1 级或 2 级，所以 f(n) = f(n - 1) + f(n - 2)，就是上面的斐波那契数列了。</p><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">jump</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">preTwo</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">preOne</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; i &lt;= n; i++) &#123;<br>            value = preTwo + preOne;<br>            preTwo = preOne;<br>            preOne = value;<br>        &#125;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; n &lt; <span class="hljs-number">10</span>; n++) &#123;<br>    System.out.println(<span class="hljs-string">&quot;jump[&quot;</span> + n + <span class="hljs-string">&quot;]:&quot;</span> + jump(n));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="本题扩展青蛙跳-n-级台阶时一次最多可以跳-n-级"><a class="markdownIt-Anchor" href="#本题扩展青蛙跳-n-级台阶时一次最多可以跳-n-级"></a> <strong>本题扩展：青蛙跳 n 级台阶时，一次最多可以跳 n 级</strong></h3><blockquote><p>在青蛙跳台阶的问题中，如果把条件改成：一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级台阶……它也可以跳上 n 级，此时该青蛙跳上一个 n 级的台阶总共有多少种跳法？我们用数学归纳法可以证明 f(n) = 2^(n - 1)。</p></blockquote><p>思路：<br>因为 f(n) = 2^(n - 1)，所以 f(n - 1) = 2<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> = 2^(n - 1) * 2^(-1)，也就是说 f(n) 是 f(n - 1) 的 2 倍。</p><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">jump</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            value *= <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; n &lt; <span class="hljs-number">10</span>; n++) &#123;<br>    System.out.println(<span class="hljs-string">&quot;jump[&quot;</span> + n + <span class="hljs-string">&quot;]:&quot;</span> + jump(n));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相关题目用-2-x-1-的小矩形横着或者竖着去覆盖-2-x-n-的大矩形"><a class="markdownIt-Anchor" href="#相关题目用-2-x-1-的小矩形横着或者竖着去覆盖-2-x-n-的大矩形"></a> <strong>相关题目：用 2 x 1 的小矩形横着或者竖着去覆盖 2 x n 的大矩形</strong></h2><blockquote><p>我们可以用 2 x 1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2 x 1 的小矩形无重叠地覆盖一个 2 x n 的大矩形，总共有多少种方法？</p></blockquote><p>思路：<br>当小矩形竖着放时，剩余面积是 2 x (n - 1)；当小矩形横着放时，小矩形下方也是惟一确定可以放一个小矩形，剩余面积是 2 x （n - 2）；所以 f(n) = f(n - 1) + f(n - 2)。</p><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">jump</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">preTwo</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">preOne</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; i &lt;= n; i++) &#123;<br>            value = preTwo + preOne;<br>            preTwo = preOne;<br>            preOne = value;<br>        &#125;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; n &lt; <span class="hljs-number">10</span>; n++) &#123;<br>    System.out.println(<span class="hljs-string">&quot;jump[&quot;</span> + n + <span class="hljs-string">&quot;]:&quot;</span> + jump(n));<br>&#125;<br></code></pre></td></tr></table></figure><hr><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>(n - 1) - 1 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section></div><hr><div><div class="post-metas my-3"></div><div class="license-box my-3"><div class="license-title"><div>《剑指 Offer》算法题（10/68）</div><div>https://weichao.io/db7d7a2f7b38/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>魏超</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2020年3月16日</div></div><div class="license-meta-item license-meta-date"><div>更新于</div><div>2022年12月4日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i> </span></a><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="NC - 非商业性使用"><i class="iconfont icon-nc"></i> </span></a><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="SA - 相同方式共享"><i class="iconfont icon-sa"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/de67cf472b53/" title="《剑指 Offer》算法题（20/68）"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">《剑指 Offer》算法题（20/68）</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/44f2184e1eee/" title="数据结构"><span class="hidden-mobile">数据结构</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><i class="iconfont icon-my-hexo"></i>&nbsp;<span>博客框架Hexo&nbsp;&nbsp;</span></a> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><i class="iconfont icon-my-theme"></i>&nbsp;<span>博客主题Fluid&nbsp;&nbsp;</span></a> <a href="https://weichao.io" target="_blank" rel="nofollow noopener"><i class="iconfont icon-my-copyright"></i>&nbsp;2023<span>魏超</span></a></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>