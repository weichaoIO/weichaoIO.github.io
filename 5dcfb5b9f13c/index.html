<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/my_icon.ico"><link rel="icon" href="/img/my_icon.ico"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="魏超"><meta name="keywords" content="魏超,weichao"><meta name="description" content="“那些参数、类型、重定位表只不过是用于计算符号地址的，而 GOT 和 PLT 才是整个流程得以顺利进行的关键。”"><meta property="og:type" content="article"><meta property="og:title" content="第 4 章：深入理解 ELF 文件格式"><meta property="og:url" content="https://weichao.io/5dcfb5b9f13c/index.html"><meta property="og:site_name" content="『魏超』的 blog"><meta property="og:description" content="“那些参数、类型、重定位表只不过是用于计算符号地址的，而 GOT 和 PLT 才是整个流程得以顺利进行的关键。”"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E7%AC%AC-4-%E7%AB%A0%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-ELF-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/%E7%AC%AC%204%20%E7%AB%A0%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20ELF%20%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.jpg"><meta property="og:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E7%AC%AC-4-%E7%AB%A0%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-ELF-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/1.png"><meta property="og:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E7%AC%AC-4-%E7%AB%A0%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-ELF-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/2.png"><meta property="og:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E7%AC%AC-4-%E7%AB%A0%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-ELF-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/3.png"><meta property="og:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E7%AC%AC-4-%E7%AB%A0%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-ELF-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/4.png"><meta property="og:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E7%AC%AC-4-%E7%AB%A0%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-ELF-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/5.png"><meta property="og:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E7%AC%AC-4-%E7%AB%A0%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-ELF-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/6.png"><meta property="og:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E7%AC%AC-4-%E7%AB%A0%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-ELF-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/7.png"><meta property="og:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E7%AC%AC-4-%E7%AB%A0%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-ELF-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/8.png"><meta property="og:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E7%AC%AC-4-%E7%AB%A0%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-ELF-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/9.png"><meta property="og:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E7%AC%AC-4-%E7%AB%A0%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-ELF-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/10.png"><meta property="og:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E7%AC%AC-4-%E7%AB%A0%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-ELF-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/11.png"><meta property="og:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E7%AC%AC-4-%E7%AB%A0%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-ELF-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/12.png"><meta property="og:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E7%AC%AC-4-%E7%AB%A0%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-ELF-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/13.png"><meta property="article:published_time" content="2023-02-17T00:00:00.000Z"><meta property="article:modified_time" content="2023-02-23T06:01:42.624Z"><meta property="article:author" content="魏超"><meta property="article:tag" content="Java"><meta property="article:tag" content="读书笔记"><meta property="article:tag" content="JVM"><meta property="article:tag" content="《深入理解 Android：Java 虚拟机 ART》"><meta property="article:tag" content="Android"><meta property="article:tag" content="ART"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E7%AC%AC-4-%E7%AB%A0%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-ELF-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/%E7%AC%AC%204%20%E7%AB%A0%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20ELF%20%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.jpg"><title>第 4 章：深入理解 ELF 文件格式 - 『魏超』的 blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1956623_vyed6le6uz.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"weichao.io",root:"/",version:"1.9.4",typing:{enable:!1,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!1},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:2},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!0,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"kQcwfNV9f5OTEb51AgXNco4o-gzGzoHsz",app_key:"IVVmse4bqkjcVx2bEJiswbJc",server_url:"https://kqcwfnv9.lc-cn-n1-shared.com",path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>『魏超』的 blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-my-home"></i> <span>首页</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-my-document"></i> <span>文档</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/archives/"><i class="iconfont icon-my-archive"></i> <span>归档</span> </a><a class="dropdown-item" href="/categories/"><i class="iconfont icon-my-category"></i> <span>分类</span> </a><a class="dropdown-item" href="/tags/"><i class="iconfont icon-my-tag"></i> <span>标签</span></a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-my-image"></i> <span>图库</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/photo/"><i class="iconfont icon-my-camera"></i> <span>摄影</span> </a><a class="dropdown-item" href="/skiing/"><i class="iconfont icon-my-skiing"></i> <span>滑雪</span> </a><a class="dropdown-item" href="/motor/"><i class="iconfont icon-my-motor"></i> <span>摩托车</span></a></div></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-my-me"></i> <span>关于</span></a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-my-link"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/banner_book.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle">第 4 章：深入理解 ELF 文件格式</span></div><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> 魏超 </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2023-02-17 08:00" pubdate>2023年2月17日 早上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 10k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 88 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar category-bar" style="margin-right:-1rem"><div class="category-list"><div class="category row nomargin-x"><a class="category-item list-group-item category-item-action col-10 col-md-11 col-xm-11" title="《深入理解 Android：Java 虚拟机 ART》" id="heading-1f1a166239f9e85fe5c4f5e55531e8c0" role="tab" data-toggle="collapse" href="#collapse-1f1a166239f9e85fe5c4f5e55531e8c0" aria-expanded="true">《深入理解 Android：Java 虚拟机 ART》 <span class="list-group-count">(6)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse show" id="collapse-1f1a166239f9e85fe5c4f5e55531e8c0" role="tabpanel" aria-labelledby="heading-1f1a166239f9e85fe5c4f5e55531e8c0"><div class="category-post-list"><a href="/500af8156fd5/" title="第 2 章：深入理解 Class 文件格式" class="list-group-item list-group-item-action"><span class="category-post">第 2 章：深入理解 Class 文件格式</span> </a><a href="/eca312d65798/" title="第 3 章：深入理解 Dex 文件格式" class="list-group-item list-group-item-action"><span class="category-post">第 3 章：深入理解 Dex 文件格式</span> </a><a href="/5dcfb5b9f13c/" title="第 4 章：深入理解 ELF 文件格式" class="list-group-item list-group-item-action active"><span class="category-post">第 4 章：深入理解 ELF 文件格式</span> </a><a href="/b0288764f22c/" title="第 5 章：认识 C++11" class="list-group-item list-group-item-action"><span class="category-post">第 5 章：认识 C++11</span> </a><a href="/f867eb9c1f1d/" title="第 6 章：编译 dex 字节码为机器码" class="list-group-item list-group-item-action"><span class="category-post">第 6 章：编译 dex 字节码为机器码</span> </a><a href="/411da2cc8d27/" title="第 7 章：虚拟机的创建" class="list-group-item list-group-item-action"><span class="category-post">第 7 章：虚拟机的创建</span></a></div></div></div></div></aside></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">第 4 章：深入理解 ELF 文件格式</h1><p class="note note-info">本文最后更新于：1 年前</p><div class="markdown-body"><h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> <strong>Reference</strong></h1><ul><li><a target="_blank" rel="noopener" href="https://refspecs.linuxfoundation.org/elf/elf.pdf" title="https://refspecs.linuxfoundation.org/elf/elf.pdf">Executable and Linking Format (ELF) Specification Version 1.2</a></li><li><a target="_blank" rel="noopener" href="https://docs.oracle.com/cd/E19120-01/open.solaris/819-0690/6n33n7fcb/index.html" title="https://docs.oracle.com/cd/E19120-01/open.solaris/819-0690/6n33n7fcb/index.html">File Format</a></li></ul><hr><p><img src="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E7%AC%AC-4-%E7%AB%A0%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-ELF-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/%E7%AC%AC%204%20%E7%AB%A0%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20ELF%20%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.jpg" srcset="/img/loading.gif" lazyload alt=""></p><p>.oat 文件和 ELF <code>Executable and Linkable Format</code> 文件：</p><ul><li>ELF 是 Unix <code>包括类 Unix</code> 平台上最通用的二进制文件格式。<ul><li>.c/.c++ 文件编译后得到的 .o <code>或 .obj</code> 文件就是 ELF 文件。</li><li>动态库 .so 文件是 ELF 文件。</li><li>.o 文件和 .so 文件链接后得到的二进制可执行文件也是 ELF 文件。</li></ul></li><li>.oat 文件是 ART 虚拟机的可执行文件，本质是一种经 Android 定制的 ELF 文件。</li></ul><p>ELF 文件格式<code>有两种视图</code>：<br><img src="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E7%AC%AC-4-%E7%AB%A0%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-ELF-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/1.png" srcset="/img/loading.gif" lazyload alt=""></p><ul><li>Section Header Table 用于描述该文件中所有 section 的头的信息，是 Linking View 的必须信息。</li><li>Program Header Table 用于描述该文件中所有 segment 的信息，是 Execution View 的必须信息。</li><li>section 和 segment 之间的映射关系 <code>ELF 文件物理上并不存在 segment，segment 其实是一个或多个 section 按照映射关系组合而成的</code>：区间落在 [p_offset, p_offset + p_filesz] 范围内的 section 属于同一个 segment。</li></ul><p>解析 ELF 文件：</p><ul><li>【readelf】基于 Linking View 的方式：根据 Section Header Table 解析 section，按基于文件的偏移量来读取不同 section 的内容，再根据 section 对应的数据结构来解析。</li><li>【oatdump】基于 Execution View 的方式：先打开文件，逐个将 Program Header Table 中的 segment 映射到对应的虚拟内存地址，再遍历 segment 的内容<code>因为 segment 可由多个 section 组成，所以还会用到 Section Header Table</code>。</li></ul><p>ELF Header <code>32 位和 64 位平台有区别</code>：</p><ul><li><p>Elf64_Ehdr <code>64 位平台</code>：</p><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">名称</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">unsigned char[16]</td><td style="text-align:left">e_ident</td><td style="text-align:left">【0-3】魔数：0x7F、<code>E</code>、<code>L</code>、<code>F</code><br>【4】EI_CLASS：1 表示 32 位 ELF 文件；2 表示 64 位 ELF 文件<br>【5】EI_DATA：1 表示字节序是小端；2 表示字节序是大端<br>【6】EI_VERSION：ELF 文件版本<br>【7-15】保留</td></tr><tr><td style="text-align:left">Elf64_Half</td><td style="text-align:left">e_type</td><td style="text-align:left">ELF 文件的类型。0<code>NONE</code> 表示没有类型；1<code>REL</code> 表示 relocatable <code>如 .obj、.o</code>；2<code>EXEC</code> 表示 executable；3<code>DYN</code> 表示 shared <code>比如 .so</code></td></tr><tr><td style="text-align:left">Elf64_Half</td><td style="text-align:left">e_machine</td><td style="text-align:left">ELF 文件对应哪种 CPU 结构。40 表示 ARM 32 位平台；62 表示 AMD x86 64 位平台；183 表示 ARM 64 位平台</td></tr><tr><td style="text-align:left">Elf64_Word</td><td style="text-align:left">e_version</td><td style="text-align:left">取值和 e_ident[6] 相同</td></tr><tr><td style="text-align:left">Elf64_Addr</td><td style="text-align:left">e_entry</td><td style="text-align:left">虚拟内存地址，可执行程序的入口</td></tr><tr><td style="text-align:left">Elf64_Off</td><td style="text-align:left">e_phoff</td><td style="text-align:left">Program Header Table 在该 ELF 文件的起始位置<code>从文件开头开始算起的偏移量</code></td></tr><tr><td style="text-align:left">Elf64_Off</td><td style="text-align:left">e_shoff</td><td style="text-align:left">Section Header Table 在该 ELF 文件的起始位置<code>从文件开头开始算起的偏移量</code></td></tr><tr><td style="text-align:left">Elf64_Word</td><td style="text-align:left">e_flags</td><td style="text-align:left">和处理器相关的标识</td></tr><tr><td style="text-align:left">Elf64_Half</td><td style="text-align:left">e_ehsize</td><td style="text-align:left">表示 ELF Header 的长度 <code>64 位 ELF Header 长度是 64</code></td></tr><tr><td style="text-align:left">Elf64_Half</td><td style="text-align:left">e_phentsize</td><td style="text-align:left">Program Header Table 中每个元素的长度</td></tr><tr><td style="text-align:left">Elf64_Half</td><td style="text-align:left">e_phnum</td><td style="text-align:left">Program Header Table 中包含多少个元素</td></tr><tr><td style="text-align:left">Elf64_Half</td><td style="text-align:left">e_shentsize</td><td style="text-align:left">Section Header Table 中每个元素的长度</td></tr><tr><td style="text-align:left">Elf64_Half</td><td style="text-align:left">e_shnum</td><td style="text-align:left">Section Header Table 中包含多少个元素</td></tr><tr><td style="text-align:left">Elf64_Half</td><td style="text-align:left">e_shstrndx</td><td style="text-align:left">Section Header Table 中每个 section 都有名字，这个索引大概相当于这个 table 的 toString() 的地址</td></tr></tbody></table></li><li><p>Elf32_Ehdr <code>32 位平台，只有某些属性的长度不同</code>：</p><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">名称</th></tr></thead><tbody><tr><td style="text-align:left">unsigned char[16]</td><td style="text-align:left">e_ident</td></tr><tr><td style="text-align:left">Elf32_Half</td><td style="text-align:left">e_type</td></tr><tr><td style="text-align:left">Elf32_Half</td><td style="text-align:left">e_machine</td></tr><tr><td style="text-align:left">Elf32_Word</td><td style="text-align:left">e_version</td></tr><tr><td style="text-align:left">Elf32_Addr</td><td style="text-align:left">e_entry</td></tr><tr><td style="text-align:left">Elf32_Off</td><td style="text-align:left">e_phoff</td></tr><tr><td style="text-align:left">Elf32_Off</td><td style="text-align:left">e_shoff</td></tr><tr><td style="text-align:left">Elf32_Word</td><td style="text-align:left">e_flags</td></tr><tr><td style="text-align:left">Elf32_Half</td><td style="text-align:left">e_ehsize</td></tr><tr><td style="text-align:left">Elf32_Half</td><td style="text-align:left">e_phentsize</td></tr><tr><td style="text-align:left">Elf32_Half</td><td style="text-align:left">e_phnum</td></tr><tr><td style="text-align:left">Elf32_Half</td><td style="text-align:left">e_shentsize</td></tr><tr><td style="text-align:left">Elf32_Half</td><td style="text-align:left">e_shnum</td></tr><tr><td style="text-align:left">Elf32_Half</td><td style="text-align:left">e_shstrndx</td></tr></tbody></table></li><li><p>数据类型：</p><ul><li>Elf64_Half、Elf32_Half：作用为 unsigned medium integer，表示无符号的中等大小的整数，2 字节<code>等同于 short</code>。</li><li>Elf64_Word、Elf32_Word：作用为 unsigned integer，表示无符号的整数，4 字节<code>等同于 int</code>。</li><li>Elf64_Addr：作用为 unsigned program address，表示无符号的程序内的地址，8 字节<code>等同于 64 位平台的指针类型</code>。</li><li>Elf32_Addr：作用为 unsigned program address，表示无符号的程序内的地址，4 字节<code>等同于 32 位平台的指针类型</code>。</li><li>Elf64_Off：作用为 unsigned file offset，表示无符号的文件偏移量，8 字节<code>等同于 64 位平台的 long</code>。</li><li>Elf32_Off：作用为 unsigned file offset，表示无符号的文件偏移量，4 字节<code>等同于 32 位平台的 int</code>。</li></ul></li></ul><p>ELF 文件的作用：</p><ul><li>参与了源代码的编译和链接<code>比如一个 C 源文件编译成 relocatable 的 .o 文件，然后编译器处理这些 .o 文件（函数、变量、符号表等都可以调整到合适的位置），最终组成 .so 动态库文件或可执行文件</code>。</li><li>可执行程序的运行依赖 ELF 文件里的信息<code>比如 ELF Header 的 e_entry 指明了可执行程序的入口地址</code>。</li></ul><p>ABI：</p><ul><li>ABI <code>Application Binary Interface</code> 是用于<strong>二进制模块之间</strong>以及<strong>模块和操作系统之间</strong>交互的标准。</li><li>ABI 是 ELF 相关规范在不同硬件平台上的进一步拓展和补充<code>比如，ABI 会规定应用程序调用动态库的函数时，栈帧该如何创建，参数该如何传递</code>。</li></ul><p>ELF 和 ABI 相关的文档：</p><ul><li>通用 ELF 和 ABI 文档。</li><li>特定处理器相关 ELF 和 ABI 文档。</li><li>特定平台/语言相关的 ABI 文档。</li></ul><p>Linking View 视图下的 ELF：</p><p>示例程序 1：</p><ol><li><p>main.c：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is elf test&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Makefile 文件：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-comment"># 使用方法</span><br><span class="hljs-section">all:</span><br>    <span class="hljs-variable">$(<span class="hljs-built_in">error</span> &quot;usage: make [obj|so|exe|clean]&quot;)</span><br><br><span class="hljs-comment"># 编译 relocatable 的 obj 文件</span><br><span class="hljs-section">obj:main.c</span><br>    gcc -c main.c -o main.o<br><span class="hljs-comment"># 编译动态库 so 文件</span><br><span class="hljs-section">so:main.c</span><br>    gcc -fPIC -shared main.c -o main.so<br><span class="hljs-comment"># 编译 exe 可执行程序</span><br><span class="hljs-section">exe:main.c</span><br>    gcc main.c -o main.out<br><br><span class="hljs-section">clean:</span><br>    rm -rf *.o *.so *.out<br></code></pre></td></tr></table></figure></li><li><p>编译生成 main.o <code>Obj 文件参与链接，可以用于研究 Linking View</code>：</p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs make">make obj<br></code></pre></td></tr></table></figure></li></ol><p>执行 <code>readelf --section main.o</code>，获取到 Section Header Table 的信息：<br><img src="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E7%AC%AC-4-%E7%AB%A0%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-ELF-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/2.png" srcset="/img/loading.gif" lazyload alt=""></p><ul><li><p>分析信息：</p><ul><li>【0】：占位用的，值全为 0。</li><li>【10】.shstrtab <code>Section Header String Table</code>：专门存储 String 名字的 section。<ul><li>SHT_STRTAB 类型的 section 用于存储字符串，ELF 文件可能有多个 String Table section <code>比如 .shstrtab、.strtab、.dynstr</code>，具体使用哪个取决于 Section Header Table 的 sh_link 的值<code>比如上图【11】的 Link 是【12】</code>。</li><li>本质是一块存储区域，通过 <code>[索引, '\0')</code> 的方式截取字符串：<br><img src="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E7%AC%AC-4-%E7%AB%A0%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-ELF-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/3.png" srcset="/img/loading.gif" lazyload alt=""></li><li>执行 <code>readelf -p [section 名|索引] main.o</code>，可将指定名字或索引的 section 的内容转换成字符信息打印出来：<br><img src="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E7%AC%AC-4-%E7%AB%A0%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-ELF-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/4.png" srcset="/img/loading.gif" lazyload alt=""></li></ul></li><li>【1】.text：用于存储程序的机器指令。</li><li>【4】.bss <code>Block Storage Segment</code>：在 ELF 加载到内存的时候会分配一块由 sh_size 指定大小的内存并初始化数据为 0，在 ELF 文件里不占据任何文件的空间。</li><li>【3】.data：和 .bss 类似，但是不会初始化数据为 0。</li><li>【5】.rodata <code>read-only data</code>：包含只读数据的信息。</li><li>【11】.symtab <code>Symbol Table</code>：存储的是符号表，主要用于编译链接，也可以参与动态库的加载。<br>.dynsym<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="Special Sections（[https://docs.oracle.com/cd/E19120-01/open.solaris/819-0690/6n33n7fcb/index.html](https://docs.oracle.com/cd/E19120-01/open.solaris/819-0690/6n33n7fcb/index.html)） 里只有 .dynsym，没有 .dynsymtab，书中这里应该是写错了。">[1]</span></a></sup> <code>Dynamic Linking Symbol Table</code>：存储的仅是动态链接需要的符号信息。</li></ul></li><li><p>Section Header Table 中元素的数据结构：</p><ul><li><p>Elf64_Shdr <code>64 位平台</code>：</p><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">名称</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Elf64_Word</td><td style="text-align:left">sh_name</td><td style="text-align:left">指向 .shstrtab <code>Section Header String Table，专门存储 String 名字的 section</code> 的某个位置<code>存储了本 section 的名字</code></td></tr><tr><td style="text-align:left">Elf64_Word</td><td style="text-align:left">sh_type</td><td style="text-align:left">section 的类型</td></tr><tr><td style="text-align:left">Elf64_Xword</td><td style="text-align:left">sh_flags</td><td style="text-align:left">section 的属性</td></tr><tr><td style="text-align:left">Elf64_Addr</td><td style="text-align:left">sh_addr</td><td style="text-align:left">如果该 section 被加载到内存，该值指明应该加载到内存的什么位置<code>进程的虚拟地址空间</code></td></tr><tr><td style="text-align:left">Elf64_Off</td><td style="text-align:left">sh_offset</td><td style="text-align:left">section 真正的内容在文件中的位置<code>从文件开头开始算起的偏移量</code></td></tr><tr><td style="text-align:left">Elf64_Xword</td><td style="text-align:left">sh_size</td><td style="text-align:left">section 的大小</td></tr><tr><td style="text-align:left">Elf64_Word</td><td style="text-align:left">sh_link</td><td style="text-align:left">Section Header Table 的索引链接<code>其解释取决于 section 的类型</code></td></tr><tr><td style="text-align:left">Elf64_Word</td><td style="text-align:left">sh_info</td><td style="text-align:left">额外信息<code>其解释取决于 section 的类型</code></td></tr><tr><td style="text-align:left">Elf64_Xword</td><td style="text-align:left">sh_addralign</td><td style="text-align:left">地址对齐 <code>2 的整数幂</code></td></tr><tr><td style="text-align:left">Elf64_Xword</td><td style="text-align:left">sh_entsize</td><td style="text-align:left">一些 section 的表的条目大小是固定的<code>比如符号表</code>，该值给定了每个条目的大小</td></tr></tbody></table></li><li><p>Elf32_Shdr <code>32 位平台</code>：</p><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">名称</th></tr></thead><tbody><tr><td style="text-align:left">Elf32_Word</td><td style="text-align:left">sh_name</td></tr><tr><td style="text-align:left">Elf32_Word</td><td style="text-align:left">sh_type</td></tr><tr><td style="text-align:left">Elf32_Word</td><td style="text-align:left">sh_flags</td></tr><tr><td style="text-align:left">Elf32_Addr</td><td style="text-align:left">sh_addr</td></tr><tr><td style="text-align:left">Elf32_Off</td><td style="text-align:left">sh_offset</td></tr><tr><td style="text-align:left">Elf32_Word</td><td style="text-align:left">sh_size</td></tr><tr><td style="text-align:left">Elf32_Word</td><td style="text-align:left">sh_link</td></tr><tr><td style="text-align:left">Elf32_Word</td><td style="text-align:left">sh_info</td></tr><tr><td style="text-align:left">Elf32_Word</td><td style="text-align:left">sh_addralign</td></tr><tr><td style="text-align:left">Elf32_Word</td><td style="text-align:left">sh_entsize</td></tr></tbody></table></li></ul></li></ul><p>执行 <code>readelf -s main.o</code>，获取到符号表的信息：<br><img src="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E7%AC%AC-4-%E7%AB%A0%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-ELF-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/5.png" srcset="/img/loading.gif" lazyload alt=""></p><ul><li><p>符号表主要用于编译链接，也可以参与动态库的加载。</p></li><li><p>符号表中元素的数据结构：</p><ul><li><p>Elf64_Sym <code>64 位平台</code>：</p><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">名称</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Elf64_Word</td><td style="text-align:left">st_name</td><td style="text-align:left">符号的名称，指向 .strtab 的某个索引位置</td></tr><tr><td style="text-align:left">unsigned char</td><td style="text-align:left">st_info</td><td style="text-align:left">符号的类型和绑定属性。<br><strong>类型</strong>：1<code>OBJECT</code> 表示该符号和某个数据有关；2<code>FUNC</code> 表示该符号和某个函数有关；3<code>SECTION</code> 表示该符号和 section 有关；4<code>FILE</code> 表示存储源文件名。<br><strong>绑定属性</strong>：0<code>LOCAL</code> 表示只在该 ELF 文件里可见的符号；1<code>GLOBAL</code> 表示可在多个 ELF 文件里可见的符号；2<code>WEAK</code> 和 1<code>GLOBAL</code> 一样，但是在链接或加载的时候优先级更低。</td></tr><tr><td style="text-align:left">unsigned char</td><td style="text-align:left">st_other</td><td style="text-align:left">符号的可见性。DEFAULT 表示该符号的可见性由绑定属性决定</td></tr><tr><td style="text-align:left">Elf64_Half</td><td style="text-align:left">st_shndx</td><td style="text-align:left">符号表中的每个元素都和其他 section 有关系，这个值就是相关的 section 的索引。0<code>UND</code> 表示该符号的定义在别的 ELF 文件中；0xFFF1<code>ABS</code> 表示该符号的值是固定不变的</td></tr><tr><td style="text-align:left">Elf64_Addr</td><td style="text-align:left">st_value</td><td style="text-align:left">符号的值。对于 relocatable 类型的 ELF 文件，表示该符号位于相关 section 的具体位置；对于 shared 和 executable 类型的 ELF 文件，表示该符号的虚拟内存地址</td></tr><tr><td style="text-align:left">Elf64_Xword</td><td style="text-align:left">st_size</td><td style="text-align:left">和这个符号相关联的数据的长度</td></tr></tbody></table></li><li><p>Elf32_Sym <code>32 位平台</code>：</p><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">名称</th></tr></thead><tbody><tr><td style="text-align:left">Elf32_Word</td><td style="text-align:left">st_name</td></tr><tr><td style="text-align:left">Elf32_Addr</td><td style="text-align:left">st_value</td></tr><tr><td style="text-align:left">Elf32_Word</td><td style="text-align:left">st_size</td></tr><tr><td style="text-align:left">unsigned char</td><td style="text-align:left">st_info</td></tr><tr><td style="text-align:left">unsigned char</td><td style="text-align:left">st_other</td></tr><tr><td style="text-align:left">Elf32_Half</td><td style="text-align:left">st_shndx</td></tr></tbody></table></li></ul></li></ul><p>示例程序 2：</p><ol><li><p>test.h：</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs H"><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure></li><li><p>test.c：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;test.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>main.c：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;test.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> &#123;<br>    test();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Makefile 文件：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-comment"># 使用方法</span><br><span class="hljs-section">all:</span><br>    <span class="hljs-variable">$(<span class="hljs-built_in">error</span> &quot;usage: make [obj|clean]&quot;)</span><br><br><span class="hljs-comment"># 编译 relocatable 的 obj 文件</span><br><span class="hljs-section">obj:test.c main.c</span><br>    gcc -c test.c -o test.o<br>    gcc -c main.c -o main.o<br><br><span class="hljs-section">clean:</span><br>    rm -rf *.o<br></code></pre></td></tr></table></figure></li><li><p>编译生成 main.o <code>Obj 文件参与链接，可以用于研究 Linking View</code>：</p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs make">make obj<br></code></pre></td></tr></table></figure></li></ol><p>执行 <code>readelf -r main.o</code>，获取到重定位表的信息：<br><img src="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E7%AC%AC-4-%E7%AB%A0%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-ELF-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/6.png" srcset="/img/loading.gif" lazyload alt=""></p><ul><li>重定位最主要的作用就是将符号的使用之处和它的定义之处关联起来。</li><li>重定位的方法：<ul><li>编译链接过程中，最终生成可执行文件或动态库文件时，<strong>编译链接器将根据 ELF 文件中的重定位表计算最终的符号的位置</strong>。</li><li>加载动态库时，加载器也会根据重定位信息修改对应的符号使用之处，使得动态库能正常工作。</li></ul></li><li>分析信息：</li></ul><ol><li>【确定要修改的偏移量】.rela.text[0].Offset = 000000000015 <code>先放着，后面用</code></li><li>【确定符号在符号表中的索引】.rela.text[0].Info = 000900000002：右移 32 位为 9 -&gt; 符号在符号表中的索引为 9</li><li>【确定符号表】Section Header 中 .rela.text.Link = 10 <code>符号表在 Section Header 中的索引</code> -&gt; 符号表是 .symtab</li><li>【确定要修改的 section <code>根据名字也能猜出来</code>】Section Header 中 .rela.text.Info = 1 <code>要修改的 section 在 Section Header 中的索引</code> -&gt; 要修改的 section 是 .text</li><li>执行 <code>objdump -r -d main.o</code>，反编译 .text：<br><img src="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E7%AC%AC-4-%E7%AB%A0%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-ELF-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/7.png" srcset="/img/loading.gif" lazyload alt=""><ul><li>解析第 0x14 个字节：<ul><li>e8：intel 汇编指令，表示 call <code>函数调用</code>。</li><li>00 00 00 00：偏移量<code>相对于下一条指令</code>。这里的值是 0x19 + 偏移量为 0，相当于跳过了 test 函数，所以全 0 的地址肯定不对。<br>【要修改的偏移量】0x15 <code>来自于1. 【确定要修改的偏移量】.rela.text[0].Offset = 000000000015</code>，对应的信息是 15: R_X86_64_PC32 test-0x4 <code>还不是最终的目标函数的地址，需要编译器处理</code>。<ul><li>15：偏移量 0x15。</li><li>R_X86_64_PC32：重定位的类型<code>和目标机器有关，主要作用是告诉编译器如何计算真正的地址值</code>。</li><li>test-0x4：重定位对应的符号信息和 r_addend 的值。</li></ul></li></ul></li></ul></li></ol><ul><li>重定位表中元素的数据结构：<ul><li><p>Elf64_Rela <code>64 位平台、section 名字以 .rela 开头</code>：</p><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">名称</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Elf64_Addr</td><td style="text-align:left">r_offset</td><td style="text-align:left">偏移量</td></tr><tr><td style="text-align:left">Elf64_Xword</td><td style="text-align:left">r_info</td><td style="text-align:left">该重定位项针对符号表的哪一项 + 重定位的类型</td></tr><tr><td style="text-align:left">Elf64_Sxword</td><td style="text-align:left">r_addend</td><td style="text-align:left">用于计算最终的重定位信息的位置</td></tr></tbody></table></li><li><p>Elf32_Rela <code>32 位平台、section 名字以 .rela 开头</code>：</p><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">名称</th></tr></thead><tbody><tr><td style="text-align:left">Elf32_Addr</td><td style="text-align:left">r_offset</td></tr><tr><td style="text-align:left">Elf32_Word</td><td style="text-align:left">r_info</td></tr><tr><td style="text-align:left">Elf32_Sword</td><td style="text-align:left">r_addend</td></tr></tbody></table></li><li><p>Elf64_Rel <code>64 位平台、section 名字以 .rel 开头</code>：</p><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">名称</th></tr></thead><tbody><tr><td style="text-align:left">Elf64_Addr</td><td style="text-align:left">r_offset</td></tr><tr><td style="text-align:left">Elf64_Xword</td><td style="text-align:left">r_info</td></tr></tbody></table></li><li><p>Elf32_Rel <code>32 位平台、section 名字以 .rel 开头</code>：</p><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">名称</th></tr></thead><tbody><tr><td style="text-align:left">Elf32_Addr</td><td style="text-align:left">r_offset</td></tr><tr><td style="text-align:left">Elf32_Word</td><td style="text-align:left">r_info</td></tr></tbody></table></li></ul></li></ul><p>Execution View 视图下的 ELF：</p><p>示例程序 3：</p><ol><li><p>main.c：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;this is elf test&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Makefile 文件：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-comment"># 使用方法</span><br><span class="hljs-section">all:</span><br>    <span class="hljs-variable">$(<span class="hljs-built_in">error</span> &quot;usage: make [obj|so|exe|clean]&quot;)</span><br><br><span class="hljs-comment"># 编译 relocatable 的 obj 文件</span><br><span class="hljs-section">obj:main.c</span><br>    gcc -c main.c -o main.o<br><span class="hljs-comment"># 编译动态库 so 文件</span><br><span class="hljs-section">so:main.c</span><br>    gcc -fPIC -shared main.c -o main.so<br><span class="hljs-comment"># 编译 exe 可执行程序</span><br><span class="hljs-section">exe:main.c</span><br>    gcc main.c -o main.out<br><br><span class="hljs-section">clean:</span><br>    rm -rf *.o *.so *.out<br></code></pre></td></tr></table></figure></li><li><p>编译生成 main.out：</p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs make">make exe<br></code></pre></td></tr></table></figure></li></ol><p>执行 <code>readelf -l main.out</code>，获取到 Program Header Table 的信息：<br><img src="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E7%AC%AC-4-%E7%AB%A0%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-ELF-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/8.png" srcset="/img/loading.gif" lazyload alt=""></p><ul><li>Program Header Table 中元素的数据结构：<ul><li><p>Elf64_Phdr <code>64 位平台</code>：</p><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">名称</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Elf64_Word</td><td style="text-align:left">p_type</td><td style="text-align:left">segment 的类型。1<code>LOAD</code> 表示可加载到内存的 segment；2<code>DYNAMIC</code> 表示和动态链接有关；3<code>INTERP</code> 表示该 segment 用于说明此程序使用的链接器<code>可执行程序使用动态库的时候，动态库的加载工作是由程序解释器来完成的，程序解释器就是链接器</code>在系统中的绝对路径；6<code>PHDR</code> 表示 Program Header Table 本身的信息，当文件加载到内存的时候使用</td></tr><tr><td style="text-align:left">Elf64_Word</td><td style="text-align:left">p_flags</td><td style="text-align:left">segment 的标记符，和 segment 在内存中的访问权限有关</td></tr><tr><td style="text-align:left">Elf64_Off</td><td style="text-align:left">p_offset</td><td style="text-align:left">该 segment 位于文件的起始位置</td></tr><tr><td style="text-align:left">Elf64_Addr</td><td style="text-align:left">p_vaddr</td><td style="text-align:left">该 segment 加载到进程虚拟内存空间时指定的内存地址</td></tr><tr><td style="text-align:left">Elf64_Addr</td><td style="text-align:left">p_paddr</td><td style="text-align:left">该 segment 对应的物理地址<code>对于可执行文件和动态库文件而言，这个值没有意义，因为系统用的是虚拟地址</code></td></tr><tr><td style="text-align:left">Elf64_Xword</td><td style="text-align:left">p_filesz</td><td style="text-align:left">该 segment 在文件中占据的大小</td></tr><tr><td style="text-align:left">Elf64_Xword</td><td style="text-align:left">p_memsz</td><td style="text-align:left">该 segment 在内存中占据的大小</td></tr><tr><td style="text-align:left">Elf64_Xword</td><td style="text-align:left">p_align</td><td style="text-align:left">segment 加载到内存后其首地址需要按 p_align 的要求进行对齐</td></tr></tbody></table></li><li><p>Elf32_Phdr <code>32 位平台</code>：</p><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">名称</th></tr></thead><tbody><tr><td style="text-align:left">Elf32_Word</td><td style="text-align:left">p_type</td></tr><tr><td style="text-align:left">Elf32_Off</td><td style="text-align:left">p_offset</td></tr><tr><td style="text-align:left">Elf32_Addr</td><td style="text-align:left">p_vaddr</td></tr><tr><td style="text-align:left">Elf32_Addr</td><td style="text-align:left">p_paddr</td></tr><tr><td style="text-align:left">Elf32_Word</td><td style="text-align:left">p_filesz</td></tr><tr><td style="text-align:left">Elf32_Word</td><td style="text-align:left">p_memsz</td></tr><tr><td style="text-align:left">Elf32_Word</td><td style="text-align:left">p_flags</td></tr><tr><td style="text-align:left">Elf32_Word</td><td style="text-align:left">p_align</td></tr></tbody></table></li></ul></li></ul><p>实例分析：调用动态库中的函数</p><ul><li><p>本质：源码编译成 ELF 文件后，代码就被翻译成了机器指令。而函数调用对应的指令就是指示 <strong>CPU 先跳到该函数所在的内存地址</strong>，然后<strong>执行后面的指令</strong>。</p></li><li><p>【存在的问题】编译时无法确定函数的入口在内存中的地址。原因是：</p><ul><li>如果一个程序使用多个动态库，编译器很难为所有函数都确定一个绝对地址。</li><li>出于安全考虑，操作系统加载动态库到内存的时候会基于一个随机数来计算最终的加载位置。</li></ul><p>【解决问题】GOT <code>Global Offset Table</code>。<br><img src="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E7%AC%AC-4-%E7%AB%A0%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-ELF-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/9.png" srcset="/img/loading.gif" lazyload alt=""></p><ul><li>GOT 对应的 section 是 .got <code>存储的是该 ELF 文件用到的符号（函数或变量）地址</code>。</li><li>GOT[1] 和 GOT[2] 这两项内存存储的是<strong>解释器</strong><code>其实就是链接器，Program Header Table 中类型为 INTERP 的元素，用于加载执行时需要的动态库</code>的信息和符号解析处理函数的入口地址。其余项中的值将由 Resolver 动态填写。</li><li>当可执行程序被操作系统加载和准备执行时，如果操作系统发现该程序有 INTERP 类型的 segment，就会先跳转到链接器的 entry point 执行。链接器会设置好 GOT 等对应项，然后将系统的控制权交还给可执行程序。<ul><li>【引入问题】符号地址什么时候计算？<br>【解决问题】有两种方法：1、链接器将控制权交给可执行程序之前<code>链接器加载了依赖的动态库后就知道了动态库加载到内存的虚拟地址，就可以计算出符号地址</code>。缺点是加载时间变长；2、用的时候再计算。优点是提升了程序启动速度。<ul><li>【引入问题】程序不知道链接器会使用哪种方法计算符号地址。<br>【解决问题】编译器生成的二进制文件必须同时支持这两种方法。PLT <code>Procedure Linkage Table</code>。<br><img src="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E7%AC%AC-4-%E7%AB%A0%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-ELF-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/10.png" srcset="/img/loading.gif" lazyload alt=""><ul><li>PLT 中元素存储的是一段代码<code>辅助触发符号地址的计算以及跳转到正确的符号地址上</code>。</li><li>图中 PLT[0] 存储的是跳转到 GOT 表 Resolver 的指令。</li><li>图中 PLT[1] 中 *name1_in_GOT 表示 GOT[name1] 的值：<ul><li>如果 name1 的地址还没有计算，GOT[name1] 存储的就是后一条指令 <code>push $offset，把 Resolver 计算这个符号地址所需的参数压栈，下一条指令是跳转到 PLT[0]</code>；</li><li>如果 name1 的地址已经计算过，jmp *name1_in_GOT 就直接跳转到目标地址。</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><p>示例程序 4：</p><ol><li><p>test.h：</p><figure class="highlight h"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs H"><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure></li><li><p>test.c：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;test.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am in test2&quot;</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am in test&quot;</span>);<br>    test2()<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>main.c：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;test.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> &#123;<br>    test();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Makefile 文件：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-comment"># 使用方法</span><br><span class="hljs-section">all:</span><br>    <span class="hljs-variable">$(<span class="hljs-built_in">error</span> &quot;usage: make [so|exe|clean]&quot;)</span><br><br><span class="hljs-comment"># 编译动态库 so 文件</span><br><span class="hljs-section">so:test.c</span><br>    gcc -fPIC -m32 -g -shared test.c -o libtest.so<br><span class="hljs-comment"># 编译 exe 可执行程序</span><br><span class="hljs-section">exe:main.c</span><br>    gcc -g -m32 main.c -o main.out -L`pwd` -ltest<br><br><span class="hljs-section">clean:</span><br>    rm -rf *.exe *.so<br></code></pre></td></tr></table></figure></li><li><p>编译生成 <code>libtest.so</code>：</p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs make">make so<br></code></pre></td></tr></table></figure></li><li><p>编译生成 main.out：</p><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs make">make exe<br></code></pre></td></tr></table></figure></li></ol><p>反编译，获取到的信息：<br><img src="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E7%AC%AC-4-%E7%AB%A0%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-ELF-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/11.png" srcset="/img/loading.gif" lazyload alt=""></p><p><img src="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E7%AC%AC-4-%E7%AB%A0%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-ELF-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/12.png" srcset="/img/loading.gif" lazyload alt=""></p><p><img src="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/%E7%AC%AC-4-%E7%AB%A0%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-ELF-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/13.png" srcset="/img/loading.gif" lazyload alt=""></p><div class="note note-warning"><p>“符号地址的计算依赖于重定位信息，除非有特殊需要，否则无须死抠细节。”</p></div><p>分析信息：</p><ul><li>main.out 的 <code>call 8048430 &lt;test@plt&gt;</code><ul><li>-&gt; .plt 的 0x8048430 之后的是 PLT[1] <code>3 行代码</code>：第一行的 GOT[0x804a014] 还未计算 test 函数的地址<code>地址 0x804a014，在【图 2】.rel.plt 可以查到 0x804a014 的符号名是 test；等计算后会在 .got.plt 的 0x804a014 存储函数符号的地址</code>，所以后一行<code>地址 0x8048436，最开始时 .got.plt 的 0x804a014 存储的就是这个地址</code>把参数<code>【图 3】0x10 是 .rel.plt 中 test 的偏移量</code>压栈，最后一行 <code>jmp 8048400</code><ul><li>-&gt; .plt 的 0x8048400 是 PLT[0] <code>2 行代码</code><ul><li>-&gt; GOT[1] 的地址是 0x804a004 <code>GOT[0] 的地址是 0x804a000，GOT[2] 的地址是 0x804a008</code>，第二行 <code>jmp *0x804a008</code><ul><li>-&gt; Resolver 计算 test 的最终地址，并填写到 GOT[0x804a014]，以后就可以直接跳转到 test 函数了。</li></ul></li></ul></li></ul></li></ul></li></ul><p>Absolute PLT 和 PIC <code>Position Independent Code</code> PLT：</p><ul><li>Absolute PLT：PLT 里的参数都是绝对地址 <code>GOT 地址在编译时可以确定</code>。<ul><li>main 函数中调用 <code>libtest.so</code> 的 test() 函数。</li></ul></li><li>PIC PLT：PLT 里的参数都是基于 GOT 的偏移量 <code>GOT 的值在运行过程中计算出来的</code>。<ul><li><code>libtest.so</code> 的 test() 函数中调用 test2() 函数。</li><li>x86 平台的 GOT 的地址放在 ebx 寄存器里。</li></ul></li></ul><p><em>TODO：自己编写一个简单的 ELF 文件解析器</em></p><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> <strong>参考</strong></h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Special Sections（<a target="_blank" rel="noopener" href="https://docs.oracle.com/cd/E19120-01/open.solaris/819-0690/6n33n7fcb/index.html">https://docs.oracle.com/cd/E19120-01/open.solaris/819-0690/6n33n7fcb/index.html</a>） 里只有 .dynsym，没有 .dynsymtab，书中这里应该是写错了。 <a href="#fnref:1" rev="footnote" class="footnote-backref">↩</a></span></span></li></ol></div></section></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Android%EF%BC%9AJava-%E8%99%9A%E6%8B%9F%E6%9C%BA-ART%E3%80%8B/" class="category-chain-item">《深入理解 Android：Java 虚拟机 ART》</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/Java/">#Java</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">#读书笔记</a> <a href="/tags/JVM/">#JVM</a> <a href="/tags/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Android%EF%BC%9AJava-%E8%99%9A%E6%8B%9F%E6%9C%BA-ART%E3%80%8B/">#《深入理解 Android：Java 虚拟机 ART》</a> <a href="/tags/Android/">#Android</a> <a href="/tags/ART/">#ART</a></div></div><div class="license-box my-3"><div class="license-title"><div>第 4 章：深入理解 ELF 文件格式</div><div>https://weichao.io/5dcfb5b9f13c/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>魏超</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2023年2月17日</div></div><div class="license-meta-item license-meta-date"><div>更新于</div><div>2023年2月23日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i> </span></a><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="NC - 非商业性使用"><i class="iconfont icon-nc"></i> </span></a><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="SA - 相同方式共享"><i class="iconfont icon-sa"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/b0288764f22c/" title="第 5 章：认识 C++11"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">第 5 章：认识 C++11</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/eca312d65798/" title="第 3 章：深入理解 Dex 文件格式"><span class="hidden-mobile">第 3 章：深入理解 Dex 文件格式</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><i class="iconfont icon-my-hexo"></i>&nbsp;<span>博客框架Hexo&nbsp;&nbsp;</span></a> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><i class="iconfont icon-my-theme"></i>&nbsp;<span>博客主题Fluid&nbsp;&nbsp;</span></a> <a href="https://weichao.io" target="_blank" rel="nofollow noopener"><i class="iconfont icon-my-copyright"></i>&nbsp;2023<span>魏超</span></a></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>