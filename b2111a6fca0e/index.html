<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/my_icon.ico"><link rel="icon" href="/img/my_icon.ico"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="魏超"><meta name="keywords" content="魏超,weichao"><meta name="description" content="Reference  FFmpeg 5.0 “Lorentz”    编译出对应 FFmpeg 源码的 API doc 1、下载 doxygen 1sudo apt-get install doxygen  2、编译 1make apidoc  执行完成后在 ffmpeg-5.0&#x2F;doc&#x2F;doxy&#x2F;html 目录内生成 html 形式的 doc，访问入口是 index.html。   TODO"><meta property="og:type" content="article"><meta property="og:title" content="FFmpeg Examples 涉及的 API"><meta property="og:url" content="https://weichao.io/b2111a6fca0e/index.html"><meta property="og:site_name" content="『魏超』的 blog"><meta property="og:description" content="Reference  FFmpeg 5.0 “Lorentz”    编译出对应 FFmpeg 源码的 API doc 1、下载 doxygen 1sudo apt-get install doxygen  2、编译 1make apidoc  执行完成后在 ffmpeg-5.0&#x2F;doc&#x2F;doxy&#x2F;html 目录内生成 html 形式的 doc，访问入口是 index.html。   TODO"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/FFmpeg-Examples-%E6%B6%89%E5%8F%8A%E7%9A%84-API/FFmpeg-Examples-%E6%B6%89%E5%8F%8A%E7%9A%84-API1.png"><meta property="og:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/FFmpeg-Examples-%E6%B6%89%E5%8F%8A%E7%9A%84-API/FFmpeg-Examples-%E6%B6%89%E5%8F%8A%E7%9A%84-API2.png"><meta property="og:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/FFmpeg-Examples-%E6%B6%89%E5%8F%8A%E7%9A%84-API/FFmpeg-Examples-%E6%B6%89%E5%8F%8A%E7%9A%84-API3.png"><meta property="og:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/FFmpeg-Examples-%E6%B6%89%E5%8F%8A%E7%9A%84-API/FFmpeg-Examples-%E6%B6%89%E5%8F%8A%E7%9A%84-API4.png"><meta property="og:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/FFmpeg-Examples-%E6%B6%89%E5%8F%8A%E7%9A%84-API/FFmpeg-Examples-%E6%B6%89%E5%8F%8A%E7%9A%84-API5.png"><meta property="article:published_time" content="2022-03-27T11:00:44.000Z"><meta property="article:modified_time" content="2022-12-04T06:04:05.224Z"><meta property="article:author" content="魏超"><meta property="article:tag" content="魏超,weichao"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/FFmpeg-Examples-%E6%B6%89%E5%8F%8A%E7%9A%84-API/FFmpeg-Examples-%E6%B6%89%E5%8F%8A%E7%9A%84-API1.png"><title>FFmpeg Examples 涉及的 API - 『魏超』的 blog</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_1956623_vyed6le6uz.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"weichao.io",root:"/",version:"1.9.4",typing:{enable:!1,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!1},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:2},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!0,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:"kQcwfNV9f5OTEb51AgXNco4o-gzGzoHsz",app_key:"IVVmse4bqkjcVx2bEJiswbJc",server_url:"https://kqcwfnv9.lc-cn-n1-shared.com",path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>『魏超』的 blog</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-my-home"></i> <span>首页</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-my-document"></i> <span>文档</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/archives/"><i class="iconfont icon-my-archive"></i> <span>归档</span> </a><a class="dropdown-item" href="/categories/"><i class="iconfont icon-my-category"></i> <span>分类</span> </a><a class="dropdown-item" href="/tags/"><i class="iconfont icon-my-tag"></i> <span>标签</span></a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-my-image"></i> <span>图库</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/photo/"><i class="iconfont icon-my-camera"></i> <span>摄影</span> </a><a class="dropdown-item" href="/skiing/"><i class="iconfont icon-my-skiing"></i> <span>滑雪</span> </a><a class="dropdown-item" href="/motor/"><i class="iconfont icon-my-motor"></i> <span>摩托车</span></a></div></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-my-me"></i> <span>关于</span></a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-my-link"></i> <span>友链</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/my_background.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle">FFmpeg Examples 涉及的 API</span></div><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> 魏超 </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2022-03-27 19:00" pubdate>2022年3月27日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 34k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 286 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">FFmpeg Examples 涉及的 API</h1><p class="note note-info">本文最后更新于：1 年前</p><div class="markdown-body"><h1 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> <strong>Reference</strong></h1><ul><li><a target="_blank" rel="noopener" href="https://ffmpeg.org/download.html#release_5.0" title="https://ffmpeg.org/download.html#release_5.0">FFmpeg 5.0 “Lorentz”</a></li></ul><hr><h1 id="编译出对应-ffmpeg-源码的-api-doc"><a class="markdownIt-Anchor" href="#编译出对应-ffmpeg-源码的-api-doc"></a> <strong>编译出对应 FFmpeg 源码的 API doc</strong></h1><p>1、下载 doxygen</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">sudo apt-get install doxygen<br></code></pre></td></tr></table></figure><p><img src="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/FFmpeg-Examples-%E6%B6%89%E5%8F%8A%E7%9A%84-API/FFmpeg-Examples-%E6%B6%89%E5%8F%8A%E7%9A%84-API1.png" alt=""></p><p>2、编译</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">make apidoc<br></code></pre></td></tr></table></figure><p><img src="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/FFmpeg-Examples-%E6%B6%89%E5%8F%8A%E7%9A%84-API/FFmpeg-Examples-%E6%B6%89%E5%8F%8A%E7%9A%84-API2.png" alt=""></p><p>执行完成后在 ffmpeg-5.0/doc/doxy/html 目录内生成 html 形式的 doc，访问入口是 index.html。</p><p><img src="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/FFmpeg-Examples-%E6%B6%89%E5%8F%8A%E7%9A%84-API/FFmpeg-Examples-%E6%B6%89%E5%8F%8A%E7%9A%84-API3.png" alt=""></p><p><img src="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/FFmpeg-Examples-%E6%B6%89%E5%8F%8A%E7%9A%84-API/FFmpeg-Examples-%E6%B6%89%E5%8F%8A%E7%9A%84-API4.png" alt=""></p><p>TODO Examples list 缺少：avio_list_dir、extract_mvs、qsvdec、vaapi_encode、vaapi_transcode，这些在 ffmpeg-5.0/doc/examples 可以找到。<br><img src="https://weichao-io-1257283924.cos.ap-beijing.myqcloud.com/qldownload/FFmpeg-Examples-%E6%B6%89%E5%8F%8A%E7%9A%84-API/FFmpeg-Examples-%E6%B6%89%E5%8F%8A%E7%9A%84-API5.png" alt=""></p><p>3、编译好的 API doc<br><a target="_blank" rel="noopener" href="http://colors.black:10086/0/ffmpeg-5.0-doc" title="http://colors.black:10086/0/ffmpeg-5.0-doc">FFmpeg-5.0 doc</a></p><hr><h1 id="examples"><a class="markdownIt-Anchor" href="#examples"></a> <strong>Examples</strong></h1><p>（前例写过的 API 不会在后例中写）</p><h2 id="avio_list_dir"><a class="markdownIt-Anchor" href="#avio_list_dir"></a> <strong>avio_list_dir</strong></h2><blockquote><p>API example program to show how to list files in directory accessed through AVIOContext.</p></blockquote><p>API 示例程序显示如何列出通过 AVIOContext 访问的目录中的文件。</p><h3 id="打开输入的路径"><a class="markdownIt-Anchor" href="#打开输入的路径"></a> <strong>打开输入的路径</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">AVIODirContext *ctx = <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *input_dir = 不能为空;<br><br><span class="hljs-type">int</span> ret = avio_open_dir(&amp;ctx, input_dir, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><h3 id="关闭输入的路径"><a class="markdownIt-Anchor" href="#关闭输入的路径"></a> <strong>关闭输入的路径</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">AVIODirContext *ctx = 不能为空;<br><br>avio_close_dir(&amp;ctx);<br></code></pre></td></tr></table></figure><h3 id="错误信息转字符串"><a class="markdownIt-Anchor" href="#错误信息转字符串"></a> <strong>错误信息转字符串</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> ret = 不能为空;<br><br>av_err2str(ret);<br></code></pre></td></tr></table></figure><h3 id="打印信息"><a class="markdownIt-Anchor" href="#打印信息"></a> <strong>打印信息</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">av_log(<span class="hljs-literal">NULL</span>, AV_LOG_INFO, <span class="hljs-string">&quot;%-9s %12s %30s %10s %s %16s %16s %16s\n&quot;</span>,<br>                   <span class="hljs-string">&quot;TYPE&quot;</span>, <span class="hljs-string">&quot;SIZE&quot;</span>, <span class="hljs-string">&quot;NAME&quot;</span>, <span class="hljs-string">&quot;UID(GID)&quot;</span>, <span class="hljs-string">&quot;UGO&quot;</span>, <span class="hljs-string">&quot;MODIFIED&quot;</span>,<br>                   <span class="hljs-string">&quot;ACCESSED&quot;</span>, <span class="hljs-string">&quot;STATUS_CHANGED&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="读目录内的文件"><a class="markdownIt-Anchor" href="#读目录内的文件"></a> <strong>读目录内的文件</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">AVIODirEntry *entry = <span class="hljs-literal">NULL</span>;<br>AVIODirContext *ctx = 不能为空;<br><br><span class="hljs-type">int</span> ret = avio_read_dir(ctx, &amp;entry);<br></code></pre></td></tr></table></figure><h3 id="释放对文件的引用"><a class="markdownIt-Anchor" href="#释放对文件的引用"></a> <strong>释放对文件的引用</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">AVIODirEntry *entry = 不能为空;<br><br>avio_free_directory_entry(&amp;entry);<br></code></pre></td></tr></table></figure><h3 id="获取文件模式操作文件的权限"><a class="markdownIt-Anchor" href="#获取文件模式操作文件的权限"></a> <strong>获取文件模式（操作文件的权限）</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C">AVIODirEntry *entry = 不能为空;<br><span class="hljs-type">char</span> filemode[<span class="hljs-number">4</span>];<br><br><span class="hljs-keyword">if</span> (entry-&gt;filemode == <span class="hljs-number">-1</span>) &#123;<br>    <span class="hljs-built_in">snprintf</span>(filemode, <span class="hljs-number">4</span>, <span class="hljs-string">&quot;???&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">snprintf</span>(filemode, <span class="hljs-number">4</span>, <span class="hljs-string">&quot;%3&quot;</span> PRIo64, entry-&gt;filemode);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="获取-user-id-和-group-id"><a class="markdownIt-Anchor" href="#获取-user-id-和-group-id"></a> <strong>获取 User ID 和 Group ID</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">AVIODirEntry *entry = 不能为空;<br><span class="hljs-type">char</span> uid_and_gid[<span class="hljs-number">20</span>];<br><br><span class="hljs-built_in">snprintf</span>(uid_and_gid, <span class="hljs-number">20</span>, <span class="hljs-string">&quot;%&quot;</span> PRId64<span class="hljs-string">&quot;(%&quot;</span> PRId64<span class="hljs-string">&quot;)&quot;</span>, entry-&gt;user_id, entry-&gt;group_id);<br></code></pre></td></tr></table></figure><h3 id="打印文件信息"><a class="markdownIt-Anchor" href="#打印文件信息"></a> <strong>打印文件信息</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title function_">type_string</span><span class="hljs-params">(<span class="hljs-type">int</span> type)</span> &#123;<br>    <span class="hljs-keyword">switch</span> (type) &#123;<br>        <span class="hljs-keyword">case</span> AVIO_ENTRY_DIRECTORY:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;DIR&gt;&quot;</span>;<br>        <span class="hljs-keyword">case</span> AVIO_ENTRY_FILE:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;FILE&gt;&quot;</span>;<br>        <span class="hljs-keyword">case</span> AVIO_ENTRY_BLOCK_DEVICE:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;BLOCK DEVICE&gt;&quot;</span>;<br>        <span class="hljs-keyword">case</span> AVIO_ENTRY_CHARACTER_DEVICE:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;CHARACTER DEVICE&gt;&quot;</span>;<br>        <span class="hljs-keyword">case</span> AVIO_ENTRY_NAMED_PIPE:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;PIPE&gt;&quot;</span>;<br>        <span class="hljs-keyword">case</span> AVIO_ENTRY_SYMBOLIC_LINK:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;LINK&gt;&quot;</span>;<br>        <span class="hljs-keyword">case</span> AVIO_ENTRY_SOCKET:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;SOCKET&gt;&quot;</span>;<br>        <span class="hljs-keyword">case</span> AVIO_ENTRY_SERVER:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;SERVER&gt;&quot;</span>;<br>        <span class="hljs-keyword">case</span> AVIO_ENTRY_SHARE:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;SHARE&gt;&quot;</span>;<br>        <span class="hljs-keyword">case</span> AVIO_ENTRY_WORKGROUP:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;WORKGROUP&gt;&quot;</span>;<br>        <span class="hljs-keyword">case</span> AVIO_ENTRY_UNKNOWN:<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;UNKNOWN&gt;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C">AVIODirEntry *entry = 不能为空;<br><span class="hljs-type">char</span> uid_and_gid[<span class="hljs-number">20</span>] = 不能为空;<br><span class="hljs-type">char</span> filemode[<span class="hljs-number">4</span>] = 不能为空;<br><br>av_log(<span class="hljs-literal">NULL</span>, AV_LOG_INFO, <span class="hljs-string">&quot;%-9s %12&quot;</span> PRId64<span class="hljs-string">&quot; %30s %10s %s %16&quot;</span> PRId64<span class="hljs-string">&quot; %16&quot;</span> PRId64<span class="hljs-string">&quot; %16&quot;</span> PRId64<span class="hljs-string">&quot;\n&quot;</span>,<br>       type_string(entry-&gt;type),<br>       entry-&gt;size,<br>       entry-&gt;name,<br>       uid_and_gid,<br>       filemode,<br>       entry-&gt;modification_timestamp,<br>       entry-&gt;access_timestamp,<br>       entry-&gt;status_change_timestamp);<br></code></pre></td></tr></table></figure><h2 id="avio_reading"><a class="markdownIt-Anchor" href="#avio_reading"></a> <strong>avio_reading</strong></h2><blockquote><p>API example program to show how to read from a custom buffer accessed through AVIOContext.</p></blockquote><p>API 示例程序显示如何从通过 AVIOContext 访问的自定义缓冲区中读取数据。</p><h3 id="映射文件的内容到缓冲区"><a class="markdownIt-Anchor" href="#映射文件的内容到缓冲区"></a> <strong>映射文件的内容到缓冲区</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">uint8_t</span> *buffer = <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">size_t</span> buffer_size;<br><span class="hljs-type">char</span> *input_filename = 不能为空;<br><br><span class="hljs-type">int</span> ret = av_file_map(input_filename, &amp;buffer, &amp;buffer_size, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><h3 id="取消映射文件的内容到缓冲区"><a class="markdownIt-Anchor" href="#取消映射文件的内容到缓冲区"></a> <strong>取消映射文件的内容到缓冲区</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">uint8_t</span> *buffer = 不能为空;<br><span class="hljs-type">size_t</span> buffer_size = 不能为空;<br><br>av_file_unmap(buffer, buffer_size);<br></code></pre></td></tr></table></figure><h3 id="创建-avformatcontext"><a class="markdownIt-Anchor" href="#创建-avformatcontext"></a> <strong>创建 AVFormatContext</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">AVFormatContext *fmt_ctx = <span class="hljs-literal">NULL</span>;<br><br>fmt_ctx = avformat_alloc_context();<br></code></pre></td></tr></table></figure><h3 id="关闭-avformatcontext"><a class="markdownIt-Anchor" href="#关闭-avformatcontext"></a> <strong>关闭 AVFormatContext</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">AVFormatContext *fmt_ctx = 不能为空;<br><br>avformat_close_input(&amp;fmt_ctx);<br></code></pre></td></tr></table></figure><h3 id="创建缓冲区"><a class="markdownIt-Anchor" href="#创建缓冲区"></a> <strong>创建缓冲区</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">uint8_t</span> *avio_ctx_buffer = <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">size_t</span> avio_ctx_buffer_size = <span class="hljs-number">4096</span>;<br><br>avio_ctx_buffer = (<span class="hljs-type">uint8_t</span> *) (av_malloc(avio_ctx_buffer_size));<br></code></pre></td></tr></table></figure><h3 id="释放缓冲区"><a class="markdownIt-Anchor" href="#释放缓冲区"></a> <strong>释放缓冲区</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span> (avio_ctx)<br>    av_freep(&amp;avio_ctx-&gt;buffer);<br></code></pre></td></tr></table></figure><h3 id="创建-aviocontext"><a class="markdownIt-Anchor" href="#创建-aviocontext"></a> <strong>创建 AVIOContext</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buffer_data</span> &#123;</span><br>    <span class="hljs-type">uint8_t</span> *ptr;<br>    <span class="hljs-type">size_t</span> size; <span class="hljs-comment">///&lt; size left in the buffer</span><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read_packet</span><span class="hljs-params">(<span class="hljs-type">void</span> *opaque, <span class="hljs-type">uint8_t</span> *buf, <span class="hljs-type">int</span> buf_size)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buffer_data</span> *<span class="hljs-title">bd</span> =</span> (<span class="hljs-keyword">struct</span> buffer_data *) opaque;<br>    buf_size = FFMIN(buf_size, bd-&gt;size);<br><br>    <span class="hljs-keyword">if</span> (!buf_size)<br>        <span class="hljs-keyword">return</span> AVERROR_EOF;<br>    LOGD(<span class="hljs-string">&quot;ptr:%p size:%zu\n&quot;</span>, bd-&gt;ptr, bd-&gt;size);<br><br>    <span class="hljs-comment">/* copy internal buffer data to buf */</span><br>    <span class="hljs-built_in">memcpy</span>(buf, bd-&gt;ptr, buf_size);<br>    bd-&gt;ptr += buf_size;<br>    bd-&gt;size -= buf_size;<br><br>    <span class="hljs-keyword">return</span> buf_size;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C">AVIOContext *avio_ctx = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-type">uint8_t</span> *avio_ctx_buffer = 不能为空;<br><span class="hljs-type">size_t</span> avio_ctx_buffer_size = <span class="hljs-number">4096</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buffer_data</span> <span class="hljs-title">bd</span> =</span> &#123;<span class="hljs-number">0</span>&#125;;<br>bd.ptr = 不能为空;<br>bd.size = 不能为空;<br><br>avio_ctx = avio_alloc_context(avio_ctx_buffer, avio_ctx_buffer_size,<br>                                  <span class="hljs-number">0</span>, &amp;bd, &amp;read_packet, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><h3 id="后一个数组向前一个数组复制-n-个数据"><a class="markdownIt-Anchor" href="#后一个数组向前一个数组复制-n-个数据"></a> <strong>后一个数组向前一个数组复制 n 个数据</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buffer_data</span> &#123;</span><br>    <span class="hljs-type">uint8_t</span> *ptr;<br>    <span class="hljs-type">size_t</span> size; <span class="hljs-comment">///&lt; size left in the buffer</span><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buffer_data</span> *<span class="hljs-title">bd</span> =</span> 不能为空;<br><span class="hljs-type">uint8_t</span> *buf = 不能为空;<br><span class="hljs-type">int</span> buf_size = 不能为空;<br><br><span class="hljs-built_in">memcpy</span>(buf, bd-&gt;ptr, buf_size);<br>bd-&gt;ptr += buf_size;<br>bd-&gt;size -= buf_size;<br></code></pre></td></tr></table></figure><h3 id="释放-aviocontext"><a class="markdownIt-Anchor" href="#释放-aviocontext"></a> <strong>释放 AVIOContext</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">AVIOContext *avio_ctx = 不能为空;<br><br>avio_context_free(&amp;avio_ctx);<br></code></pre></td></tr></table></figure><h3 id="建立-avformatcontext-对-aviocontext-的引用"><a class="markdownIt-Anchor" href="#建立-avformatcontext-对-aviocontext-的引用"></a> <strong>建立 AVFormatContext 对 AVIOContext 的引用</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">AVFormatContext *fmt_ctx = 不能为空;<br>AVIOContext *avio_ctx = 不能为空;<br><br>fmt_ctx-&gt;pb = avio_ctx;<br></code></pre></td></tr></table></figure><h3 id="打开输入的文件"><a class="markdownIt-Anchor" href="#打开输入的文件"></a> <strong>打开输入的文件</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">AVFormatContext *fmt_ctx = 不能为空;<br><br><span class="hljs-type">int</span> ret = avformat_open_input(&amp;fmt_ctx, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><h3 id="获取文件的流信息"><a class="markdownIt-Anchor" href="#获取文件的流信息"></a> <strong>获取文件的流信息</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">AVFormatContext *fmt_ctx = 不能为空;<br><br><span class="hljs-type">int</span> ret = avformat_find_stream_info(fmt_ctx, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><h3 id="打印输入或输出的详细信息"><a class="markdownIt-Anchor" href="#打印输入或输出的详细信息"></a> <strong>打印输入或输出的详细信息</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">AVFormatContext *fmt_ctx = 不能为空;<br><span class="hljs-type">char</span> *input_filename = 不能为空;<br><br>av_dump_format(fmt_ctx, <span class="hljs-number">0</span>, input_filename, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h2 id="decode_audio"><a class="markdownIt-Anchor" href="#decode_audio"></a> <strong>decode_audio</strong></h2><blockquote><p>audio decoding with libavcodec API example</p></blockquote><p>使用 libavcodec API 进行音频解码示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> AUDIO_INBUF_SIZE 20480</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AUDIO_REFILL_THRESH 4096</span><br></code></pre></td></tr></table></figure><h3 id="创建-avpacket"><a class="markdownIt-Anchor" href="#创建-avpacket"></a> <strong>创建 AVPacket</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">AVPacket *pkt = av_packet_alloc();<br></code></pre></td></tr></table></figure><h3 id="释放-avpacket"><a class="markdownIt-Anchor" href="#释放-avpacket"></a> <strong>释放 AVPacket</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">AVPacket *pkt = 不能为空;<br><br>av_packet_free(&amp;pkt);<br></code></pre></td></tr></table></figure><h3 id="获取指定的-avcodec"><a class="markdownIt-Anchor" href="#获取指定的-avcodec"></a> <strong>获取指定的 AVCodec</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">const</span> AVCodec *codec = avcodec_find_decoder(AV_CODEC_ID_MP2);<br></code></pre></td></tr></table></figure><h3 id="创建并初始化-avcodecparsercontext"><a class="markdownIt-Anchor" href="#创建并初始化-avcodecparsercontext"></a> <strong>创建并初始化 AVCodecParserContext</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">const</span> AVCodec *codec = 不能为空;<br><br>AVCodecParserContext *parser = av_parser_init(codec-&gt;id);<br></code></pre></td></tr></table></figure><h3 id="关闭-avcodecparsercontext"><a class="markdownIt-Anchor" href="#关闭-avcodecparsercontext"></a> <strong>关闭 AVCodecParserContext</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">AVCodecParserContext *parser  = 不能为空;<br><br>av_parser_close(parser);<br></code></pre></td></tr></table></figure><h3 id="创建-avcodeccontext"><a class="markdownIt-Anchor" href="#创建-avcodeccontext"></a> <strong>创建 AVCodecContext</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">const</span> AVCodec *codec = 不能为空;<br><br>AVCodecContext *c = avcodec_alloc_context3(codec);<br></code></pre></td></tr></table></figure><h3 id="释放-avcodeccontext"><a class="markdownIt-Anchor" href="#释放-avcodeccontext"></a> <strong>释放 AVCodecContext</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">AVCodecContext *c = 不能为空;<br><br>avcodec_free_context(&amp;c);<br></code></pre></td></tr></table></figure><h3 id="初始化-avcodeccontext"><a class="markdownIt-Anchor" href="#初始化-avcodeccontext"></a> <strong>初始化 AVCodecContext</strong></h3><blockquote><p>For some codecs, such as msmpeg4 and mpeg4, width and height MUST be initialized there because this information is not available in the bitstream.</p></blockquote><p>对于某些编解码器，例如 msmpeg4 和 mpeg4，必须在此处初始化宽度和高度，因为此信息在比特流中不可用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C">AVCodecContext *c = 不能为空;<br><span class="hljs-type">const</span> AVCodec *codec = 不能为空;<br><br><span class="hljs-type">int</span> ret = avcodec_open2(c, codec, <span class="hljs-literal">NULL</span>);<br><br><span class="hljs-comment">// 给参数赋值</span><br>AVDictionary *opts = <span class="hljs-literal">NULL</span>;<br><br>ret = av_dict_set(&amp;opts, <span class="hljs-string">&quot;flags2&quot;</span>, <span class="hljs-string">&quot;+export_mvs&quot;</span>, <span class="hljs-number">0</span>);<br>ret = avcodec_open2(c, codec, &amp;opts);<br>av_dict_free(&amp;opts);<br></code></pre></td></tr></table></figure><h3 id="释放-avcodeccontext-2"><a class="markdownIt-Anchor" href="#释放-avcodeccontext-2"></a> <strong>释放 AVCodecContext</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">AVCodecContext *c = 不能为空;<br><br>av_free(c);<br></code></pre></td></tr></table></figure><h3 id="释放-avcodeccontext-3"><a class="markdownIt-Anchor" href="#释放-avcodeccontext-3"></a> <strong>释放 AVCodecContext</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">AVCodecContext *c = 不能为空;<br><br>avcodec_free_context(&amp;c);<br></code></pre></td></tr></table></figure><h3 id="打开文件"><a class="markdownIt-Anchor" href="#打开文件"></a> <strong>打开文件</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename;<br><br>FILE *f = fopen(filename, <span class="hljs-string">&quot;rb&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="关闭文件"><a class="markdownIt-Anchor" href="#关闭文件"></a> <strong>关闭文件</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">FILE *f = 不能为空;<br><br><span class="hljs-type">int</span> ret = fclose(f);<br></code></pre></td></tr></table></figure><h3 id="读文件的内容"><a class="markdownIt-Anchor" href="#读文件的内容"></a> <strong>读文件的内容</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">uint8_t</span> inbuf[AUDIO_INBUF_SIZE + AV_INPUT_BUFFER_PADDING_SIZE];<br>FILE *f = 不能为空;<br><br><span class="hljs-type">size_t</span> data_size = fread(inbuf, <span class="hljs-number">1</span>, AUDIO_INBUF_SIZE, f);<br></code></pre></td></tr></table></figure><h3 id="创建-avframe"><a class="markdownIt-Anchor" href="#创建-avframe"></a> <strong>创建 AVFrame</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">AVFrame *decoded_frame = av_frame_alloc();<br></code></pre></td></tr></table></figure><h3 id="释放-avframe"><a class="markdownIt-Anchor" href="#释放-avframe"></a> <strong>释放 AVFrame</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">AVFrame *decoded_frame = 不能为空;<br><br>av_frame_free(&amp;decoded_frame);<br></code></pre></td></tr></table></figure><h3 id="解析数据包"><a class="markdownIt-Anchor" href="#解析数据包"></a> <strong>解析数据包</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C">AVCodecParserContext *parser = 不能为空;<br>AVCodecContext *c = 不能为空;<br>AVPacket *pkt = 不能为空;<br><span class="hljs-type">uint8_t</span> *data = 不能为空;<br><span class="hljs-type">size_t</span> data_size = 不能为空;<br><br><span class="hljs-type">int</span> ret = av_parser_parse2(parser, c, &amp;pkt-&gt;data, &amp;pkt-&gt;size,<br>                           data, data_size,<br>                           AV_NOPTS_VALUE, AV_NOPTS_VALUE, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>    LOGE(<span class="hljs-string">&quot;Error while parsing\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span><br>    LOGD(<span class="hljs-string">&quot;av_parser_parse2()&quot;</span>);<br>data += ret;<br>data_size -= ret;<br></code></pre></td></tr></table></figure><h3 id="提供原始数据包数据作为解码器的输入"><a class="markdownIt-Anchor" href="#提供原始数据包数据作为解码器的输入"></a> <strong>提供原始数据包数据作为解码器的输入</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">AVCodecContext *dec_ctx = 不能为空;<br>AVPacket *pkt = 不能为空;<br><br><span class="hljs-type">int</span> ret = avcodec_send_packet(dec_ctx, pkt);<br></code></pre></td></tr></table></figure><h3 id="获取解码器解码后的输出数据"><a class="markdownIt-Anchor" href="#获取解码器解码后的输出数据"></a> <strong>获取解码器解码后的输出数据</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">AVCodecContext *dec_ctx = 不能为空;<br>AVFrame *frame = 不能为空;<br><br><span class="hljs-type">int</span> ret = avcodec_receive_frame(dec_ctx, frame);<br></code></pre></td></tr></table></figure><h3 id="获取每个样本的字节数"><a class="markdownIt-Anchor" href="#获取每个样本的字节数"></a> <strong>获取每个样本的字节数</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">AVCodecContext *dec_ctx = 不能为空;<br><br><span class="hljs-type">int</span> data_size = av_get_bytes_per_sample(dec_ctx-&gt;sample_fmt);<br></code></pre></td></tr></table></figure><h3 id="写数据到文件"><a class="markdownIt-Anchor" href="#写数据到文件"></a> <strong>写数据到文件</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C">AVFrame *frame = 不能为空;<br>AVCodecContext *dec_ctx = 不能为空;<br><span class="hljs-type">int</span> i, ch;<br><span class="hljs-type">int</span> data_size = 不能为空;<br>FILE *outfile = 不能为空;<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; frame-&gt;nb_samples; i++)<br>    <span class="hljs-keyword">for</span> (ch = <span class="hljs-number">0</span>; ch &lt; dec_ctx-&gt;channels; ch++)<br>        fwrite(frame-&gt;data[ch] + data_size * i, <span class="hljs-number">1</span>, data_size, outfile);<br></code></pre></td></tr></table></figure><h3 id="后一个数组向前一个数组复制-n-个数据-2"><a class="markdownIt-Anchor" href="#后一个数组向前一个数组复制-n-个数据-2"></a> <strong>后一个数组向前一个数组复制 n 个数据</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">uint8_t</span> inbuf[AUDIO_INBUF_SIZE + AV_INPUT_BUFFER_PADDING_SIZE];<br><span class="hljs-type">uint8_t</span> *data = 不能为空;<br><span class="hljs-type">size_t</span> data_size = 不能为空;<br><br>memmove(inbuf, data, data_size);<br>data = inbuf;<br>len = fread(data + data_size, <span class="hljs-number">1</span>,<br>            AUDIO_INBUF_SIZE - data_size, f);<br><span class="hljs-keyword">if</span> (len &gt; <span class="hljs-number">0</span>)<br>    data_size += len;<br></code></pre></td></tr></table></figure><h3 id="刷新解码器"><a class="markdownIt-Anchor" href="#刷新解码器"></a> <strong>刷新解码器</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C">AVPacket *pkt = 不能为空;<br><br>pkt-&gt;data = <span class="hljs-literal">NULL</span>;<br>pkt-&gt;size = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 执行一次解码流程</span><br>decode(c, pkt, decoded_frame, outfile);<br></code></pre></td></tr></table></figure><h3 id="检查样本格式是否是平面的"><a class="markdownIt-Anchor" href="#检查样本格式是否是平面的"></a> <strong>检查样本格式是否是平面的</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AVSampleFormat</span> <span class="hljs-title">sfmt</span> =</span> 不能为空;<br><br><span class="hljs-type">int</span> ret = av_sample_fmt_is_planar(sfmt);<br></code></pre></td></tr></table></figure><h3 id="获取样本格式名称"><a class="markdownIt-Anchor" href="#获取样本格式名称"></a> <strong>获取样本格式名称</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AVSampleFormat</span> <span class="hljs-title">sfmt</span> =</span> 不能为空;<br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *packed = av_get_sample_fmt_name(sfmt);<br></code></pre></td></tr></table></figure><h3 id="获取样本格式的打包"><a class="markdownIt-Anchor" href="#获取样本格式的打包"></a> <strong>获取样本格式的打包</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AVSampleFormat</span> <span class="hljs-title">sfmt</span> =</span> 不能为空;<br><br>sfmt = av_get_packed_sample_fmt(sfmt);<br></code></pre></td></tr></table></figure><h3 id="获取-ffplay-时的参数"><a class="markdownIt-Anchor" href="#获取-ffplay-时的参数"></a> <strong>获取 ffplay 时的参数</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get_format_from_sample_fmt</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> **fmt,</span><br><span class="hljs-params">                                      <span class="hljs-keyword">enum</span> AVSampleFormat sample_fmt)</span> &#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sample_fmt_entry</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AVSampleFormat</span> <span class="hljs-title">sample_fmt</span>;</span><br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span> *fmt_be, *fmt_le;<br>    &#125; sample_fmt_entries[] = &#123;<br>            &#123;AV_SAMPLE_FMT_U8,  <span class="hljs-string">&quot;u8&quot;</span>,    <span class="hljs-string">&quot;u8&quot;</span>&#125;,<br>            &#123;AV_SAMPLE_FMT_S16, <span class="hljs-string">&quot;s16be&quot;</span>, <span class="hljs-string">&quot;s16le&quot;</span>&#125;,<br>            &#123;AV_SAMPLE_FMT_S32, <span class="hljs-string">&quot;s32be&quot;</span>, <span class="hljs-string">&quot;s32le&quot;</span>&#125;,<br>            &#123;AV_SAMPLE_FMT_FLT, <span class="hljs-string">&quot;f32be&quot;</span>, <span class="hljs-string">&quot;f32le&quot;</span>&#125;,<br>            &#123;AV_SAMPLE_FMT_DBL, <span class="hljs-string">&quot;f64be&quot;</span>, <span class="hljs-string">&quot;f64le&quot;</span>&#125;,<br>    &#125;;<br>    *fmt = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; FF_ARRAY_ELEMS(sample_fmt_entries); i++) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sample_fmt_entry</span> *<span class="hljs-title">entry</span> =</span> &amp;sample_fmt_entries[i];<br>        <span class="hljs-keyword">if</span> (sample_fmt == entry-&gt;sample_fmt) &#123;<br>            *fmt = AV_NE(entry-&gt;fmt_be, entry-&gt;fmt_le);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    LOGE(<br>            <span class="hljs-string">&quot;sample format %s is not supported as output format\n&quot;</span>,<br>            av_get_sample_fmt_name(sample_fmt));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *fmt;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AVSampleFormat</span> <span class="hljs-title">sfmt</span> =</span> 不能为空;<br><br><span class="hljs-type">int</span> ret = get_format_from_sample_fmt(&amp;fmt, sfmt);<br></code></pre></td></tr></table></figure><h2 id="decode_video"><a class="markdownIt-Anchor" href="#decode_video"></a> <strong>decode_video</strong></h2><blockquote><p>video decoding with libavcodec API example</p></blockquote><p>使用 libavcodec API 进行视频解码示例</p><blockquote><p>And check your input file is encoded by mpeg1video please.</p></blockquote><p>请检查您的输入文件是否由 mpeg1video 编码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> INBUF_SIZE 4096</span><br></code></pre></td></tr></table></figure><h3 id="创建-avpacket-2"><a class="markdownIt-Anchor" href="#创建-avpacket-2"></a> <strong>创建 AVPacket</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">AVPacket *pkt = av_packet_alloc();<br></code></pre></td></tr></table></figure><h3 id="将缓冲区的结尾设置为-0"><a class="markdownIt-Anchor" href="#将缓冲区的结尾设置为-0"></a> <strong>将缓冲区的结尾设置为 0</strong></h3><p>这可确保损坏的 MPEG 流不会发生过度读取</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">uint8_t</span> inbuf[INBUF_SIZE + AV_INPUT_BUFFER_PADDING_SIZE];<br><br><span class="hljs-built_in">memset</span>(inbuf + INBUF_SIZE, <span class="hljs-number">0</span>, AV_INPUT_BUFFER_PADDING_SIZE);<br></code></pre></td></tr></table></figure><h3 id="输出缓冲区中的数据"><a class="markdownIt-Anchor" href="#输出缓冲区中的数据"></a> <strong>输出缓冲区中的数据</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 没什么用，而且 example 中用法应该不对，参考 https://www.runoob.com/cprogramming/c-function-fflush.html</span><br>fflush(<span class="hljs-built_in">stdout</span>);<br></code></pre></td></tr></table></figure><h3 id="刷新解码器-2"><a class="markdownIt-Anchor" href="#刷新解码器-2"></a> <strong>刷新解码器</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">AVCodecContext *dec_ctx = 不能为空;<br><br><span class="hljs-type">int</span> ret = avcodec_send_packet(dec_ctx, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><h2 id="demuxing_decoding"><a class="markdownIt-Anchor" href="#demuxing_decoding"></a> <strong>demuxing_decoding</strong></h2><blockquote><p>API example program to show how to read frames from an input file.<br>This program reads frames from a file, decodes them, and writes decoded video frames to a rawvideo file named video_output_file, and decoded audio frames to a rawaudio file named audio_output_file.</p></blockquote><p>API 示例程序，展示如何从输入文件中读取帧。<br>该程序从文件中读取帧，对其进行解码，并将解码的视频帧写入名为 video_output_file 的 rawvideo 文件，并将解码的音频帧写入名为 audio_output_file 的 rawaudio 文件。</p><h3 id="打开输入的文件-2"><a class="markdownIt-Anchor" href="#打开输入的文件-2"></a> <strong>打开输入的文件</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> AVFormatContext *fmt_ctx = <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *src_filename = 不能为空;<br><br><span class="hljs-type">int</span> ret = avformat_open_input(&amp;fmt_ctx, src_filename, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><h3 id="获取最佳流"><a class="markdownIt-Anchor" href="#获取最佳流"></a> <strong>获取最佳流</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C">AVFormatContext *fmt_ctx = 不能为空;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AVMediaType</span> <span class="hljs-title">type</span> =</span> 不能为空;<br><span class="hljs-type">int</span> ret, stream_index;<br>AVStream *st;<br><br>ret = av_find_best_stream(fmt_ctx, type, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>    LOGE(<span class="hljs-string">&quot;Could not find %s stream in input file &#x27;%s&#x27;\n&quot;</span>,<br>         av_get_media_type_string(type), src_filename);<br>    <span class="hljs-keyword">return</span> ret;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    stream_index = ret;<br>    st = fmt_ctx-&gt;streams[stream_index];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="获取指定的-avcodec-2"><a class="markdownIt-Anchor" href="#获取指定的-avcodec-2"></a> <strong>获取指定的 AVCodec</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">AVStream *st = 不能为空;<br><br><span class="hljs-type">const</span> AVCodec *dec = avcodec_find_decoder(st-&gt;codecpar-&gt;codec_id);<br></code></pre></td></tr></table></figure><h3 id="覆盖-avcodeccontext-对应的参数"><a class="markdownIt-Anchor" href="#覆盖-avcodeccontext-对应的参数"></a> <strong>覆盖 AVCodecContext 对应的参数</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">AVCodecContext **dec_ctx = 不能为空;<br>AVStream *st = 不能为空;<br><br><span class="hljs-type">int</span> ret = avcodec_parameters_to_context(*dec_ctx, st-&gt;codecpar);<br></code></pre></td></tr></table></figure><h3 id="创建图像缓冲区"><a class="markdownIt-Anchor" href="#创建图像缓冲区"></a> <strong>创建图像缓冲区</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">uint8_t</span> *video_dst_data[<span class="hljs-number">4</span>] = &#123;<span class="hljs-literal">NULL</span>&#125;;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> video_dst_linesize[<span class="hljs-number">4</span>];<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> width = 不能为空;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> height = 不能为空;<br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AVPixelFormat</span> <span class="hljs-title">pix_fmt</span> =</span> 不能为空;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> video_dst_bufsize;<br><br><span class="hljs-type">int</span> ret = av_image_alloc(video_dst_data, video_dst_linesize,<br>                     width, height, pix_fmt, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>    LOGE(<span class="hljs-string">&quot;Could not allocate raw video buffer\n&quot;</span>);<br>    <span class="hljs-keyword">goto</span> end;<br>&#125; <span class="hljs-keyword">else</span><br>    LOGD(<span class="hljs-string">&quot;av_image_alloc()&quot;</span>);<br>video_dst_bufsize = ret;<br></code></pre></td></tr></table></figure><h3 id="循环读数据到-avpacket读成功后调用解码函数进行解码"><a class="markdownIt-Anchor" href="#循环读数据到-avpacket读成功后调用解码函数进行解码"></a> <strong>循环读数据到 AVPacket，读成功后调用解码函数进行解码</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C">AVFormatContext *fmt_ctx = 不能为空;<br><span class="hljs-type">static</span> AVPacket *pkt = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">/* read frames from the file */</span><br><span class="hljs-keyword">while</span> (av_read_frame(fmt_ctx, pkt) &gt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">if</span> (pkt-&gt;stream_index == video_stream_idx)<br>        ret = decode_packet(video_dec_ctx, pkt);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pkt-&gt;stream_index == audio_stream_idx)<br>        ret = decode_packet(audio_dec_ctx, pkt);<br>    av_packet_unref(pkt);<br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复制图像"><a class="markdownIt-Anchor" href="#复制图像"></a> <strong>复制图像</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">uint8_t</span> *video_dst_data[<span class="hljs-number">4</span>] = &#123;<span class="hljs-literal">NULL</span>&#125;;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> video_dst_linesize[<span class="hljs-number">4</span>];<br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AVPixelFormat</span> <span class="hljs-title">pix_fmt</span> =</span> 不能为空;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> width = 不能为空;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> height = 不能为空;<br><br>AVFrame *frame = 不能为空;<br><br>av_image_copy(video_dst_data, video_dst_linesize,<br>              (<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> **) (frame-&gt;data), frame-&gt;linesize,<br>              pix_fmt, width, height);<br></code></pre></td></tr></table></figure><h3 id="刷新解码器-3"><a class="markdownIt-Anchor" href="#刷新解码器-3"></a> <strong>刷新解码器</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span> (video_dec_ctx)<br>    decode_packet(video_dec_ctx, <span class="hljs-literal">NULL</span>);<br><span class="hljs-keyword">if</span> (audio_dec_ctx)<br>    decode_packet(audio_dec_ctx, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><h2 id="encode_audio"><a class="markdownIt-Anchor" href="#encode_audio"></a> <strong>encode_audio</strong></h2><h3 id="获取指定的-avcodec-3"><a class="markdownIt-Anchor" href="#获取指定的-avcodec-3"></a> <strong>获取指定的 AVCodec</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">const</span> AVCodec *codec = avcodec_find_encoder(AV_CODEC_ID_MP2);<br></code></pre></td></tr></table></figure><h3 id="获取通道数"><a class="markdownIt-Anchor" href="#获取通道数"></a> <strong>获取通道数</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">const</span> AVCodec *codec = 不能为空;<br><span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> *p;<br><br>p = codec-&gt;channel_layouts;<br><span class="hljs-type">int</span> nb_channels = av_get_channel_layout_nb_channels(*p);<br></code></pre></td></tr></table></figure><h3 id="创建缓冲区-2"><a class="markdownIt-Anchor" href="#创建缓冲区-2"></a> <strong>创建缓冲区</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">AVFrame *frame = 不能为空;<br><br><span class="hljs-type">int</span> ret = av_frame_get_buffer(frame, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h3 id="确保帧数据可写"><a class="markdownIt-Anchor" href="#确保帧数据可写"></a> <strong>确保帧数据可写</strong></h3><p>确保帧数据是可写的。<br>在第一轮中，帧是来自 av_frame_get_buffer() 的新帧，因此我们知道它是可写的。<br>但在接下来的几轮中，encode() 将调用 avcodec_send_frame()，并且编解码器可能在其内部结构中保留了对该帧的引用，这使得该帧不可写。<br>av_frame_make_writable() 检查并仅在必要时为帧分配新缓冲区。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">AVFrame *frame = 不能为空;<br><br><span class="hljs-type">int</span> ret = av_frame_make_writable(frame);<br></code></pre></td></tr></table></figure><h3 id="提供原始视频或音频帧作为编码器的输入"><a class="markdownIt-Anchor" href="#提供原始视频或音频帧作为编码器的输入"></a> <strong>提供原始视频或音频帧作为编码器的输入</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">AVCodecContext *ctx = 不能为空;<br>AVFrame *frame = 不能为空;<br><br><span class="hljs-type">int</span> ret = avcodec_send_frame(ctx, frame);<br></code></pre></td></tr></table></figure><h3 id="从编码器返回编码后的输出数据"><a class="markdownIt-Anchor" href="#从编码器返回编码后的输出数据"></a> <strong>从编码器返回编码后的输出数据</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">AVCodecContext *ctx = 不能为空;<br>AVPacket *pkt = 不能为空;<br><br><span class="hljs-type">int</span> ret = avcodec_receive_packet(ctx, pkt);<br></code></pre></td></tr></table></figure><h3 id="刷新编码器"><a class="markdownIt-Anchor" href="#刷新编码器"></a> <strong>刷新编码器</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C">AVCodecContext *c = 不能为空;<br>AVPacket *pkt = 不能为空;<br>FILE *f = 不能为空;<br><br><span class="hljs-comment">// 执行一次编码流程</span><br>encodeSound(c, <span class="hljs-literal">NULL</span>, pkt, f);<br></code></pre></td></tr></table></figure><h2 id="encode_video"><a class="markdownIt-Anchor" href="#encode_video"></a> <strong>encode_video</strong></h2><h3 id="获取指定的-avcodec-4"><a class="markdownIt-Anchor" href="#获取指定的-avcodec-4"></a> <strong>获取指定的 AVCodec</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *codec_name = 不能为空;<br><br><span class="hljs-type">const</span> AVCodec *codec = avcodec_find_encoder_by_name(codec_name);<br></code></pre></td></tr></table></figure><h3 id="给参数赋值"><a class="markdownIt-Anchor" href="#给参数赋值"></a> <strong>给参数赋值</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">AVCodecContext *c = 不能为空;<br><br><span class="hljs-type">int</span> ret = av_opt_set(c-&gt;priv_data, <span class="hljs-string">&quot;preset&quot;</span>, <span class="hljs-string">&quot;slow&quot;</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h3 id="添加序列结束代码以获得真正的-mpeg-文件"><a class="markdownIt-Anchor" href="#添加序列结束代码以获得真正的-mpeg-文件"></a> <strong>添加序列结束代码，以获得真正的 MPEG 文件</strong></h3><p>之所以有意义，是因为这个小示例直接写入数据包。这称为“基本流”，仅适用于某些编解码器。<br>要创建有效的文件，通常需要将数据包写入适当的文件格式或协议； 参见 muxing.c。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">const</span> AVCodec *codec = 不能为空;<br><span class="hljs-type">uint8_t</span> endcode[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0xb7</span>&#125;;<br><br><span class="hljs-keyword">if</span> (codec-&gt;id == AV_CODEC_ID_MPEG1VIDEO || codec-&gt;id == AV_CODEC_ID_MPEG2VIDEO)<br>    fwrite(endcode, <span class="hljs-number">1</span>, <span class="hljs-keyword">sizeof</span>(endcode), f);<br></code></pre></td></tr></table></figure><h2 id="extract_mvs"><a class="markdownIt-Anchor" href="#extract_mvs"></a> <strong>extract_mvs</strong></h2><h3 id="获取边数据"><a class="markdownIt-Anchor" href="#获取边数据"></a> <strong>获取边数据</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> AVFrame *frame = 不能为空;<br><br><span class="hljs-type">int</span> i;<br>AVFrameSideData *sd = av_frame_get_side_data(frame, AV_FRAME_DATA_MOTION_VECTORS);<br><span class="hljs-keyword">if</span> (sd) &#123;<br>    <span class="hljs-type">const</span> AVMotionVector *mvs = (<span class="hljs-type">const</span> AVMotionVector *) sd-&gt;data;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; sd-&gt;size / <span class="hljs-keyword">sizeof</span>(*mvs); i++) &#123;<br>        <span class="hljs-type">const</span> AVMotionVector *mv = &amp;mvs[i];<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,%2d,%2d,%2d,%4d,%4d,%4d,%4d,0x%&quot;</span> PRIx64<span class="hljs-string">&quot;\n&quot;</span>,<br>               video_frame_count, mv-&gt;source,<br>               mv-&gt;w, mv-&gt;h, mv-&gt;src_x, mv-&gt;src_y,<br>               mv-&gt;dst_x, mv-&gt;dst_y, mv-&gt;flags);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ffhash"><a class="markdownIt-Anchor" href="#ffhash"></a> <strong>ffhash</strong></h2><blockquote><p>This example is a simple command line application that takes one or more arguments. It demonstrates a typical use of the hashing API with allocation, initialization, updating, and finalizing.</p></blockquote><p>此示例是一个简单的命令行应用程序，它采用一个或多个参数。 它演示了哈希 API 的典型用法，包括分配、初始化、更新和完成。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SIZE 65536</span><br></code></pre></td></tr></table></figure><h3 id="获取支持的-hash-算法"><a class="markdownIt-Anchor" href="#获取支持的-hash-算法"></a> <strong>获取支持的 hash 算法</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<br>LOGD(<span class="hljs-string">&quot;usage: ffhash [b64:]algorithm [input]...\n&quot;</span>);<br>LOGD(<span class="hljs-string">&quot;Supported hash algorithms:&quot;</span>);<br><span class="hljs-keyword">do</span> &#123;<br>    name = av_hash_names(i);<br>    <span class="hljs-keyword">if</span> (name)<br>        LOGD(<span class="hljs-string">&quot; %s&quot;</span>, name);<br>    i++;<br>&#125; <span class="hljs-keyword">while</span> (name);<br></code></pre></td></tr></table></figure><h3 id="获取指定的位置"><a class="markdownIt-Anchor" href="#获取指定的位置"></a> <strong>获取指定的位置</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *hash_name = 不能为空;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> out_b64 = av_strstart(hash_name, <span class="hljs-string">&quot;b64:&quot;</span>, &amp;hash_name);<br></code></pre></td></tr></table></figure><h3 id="创建-avhashcontext"><a class="markdownIt-Anchor" href="#创建-avhashcontext"></a> <strong>创建 AVHashContext</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AVHashContext</span> *<span class="hljs-title">hash</span>;</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *hash_name = 不能为空;<br><br><span class="hljs-type">int</span> ret = av_hash_alloc(&amp;hash, hash_name);<br></code></pre></td></tr></table></figure><h3 id="初始化-avhashcontext"><a class="markdownIt-Anchor" href="#初始化-avhashcontext"></a> <strong>初始化 AVHashContext</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AVHashContext</span> *<span class="hljs-title">hash</span> =</span> 不能为空;<br><br>av_hash_init(hash);<br></code></pre></td></tr></table></figure><h3 id="更新-avhashcontext"><a class="markdownIt-Anchor" href="#更新-avhashcontext"></a> <strong>更新 AVHashContext</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AVHashContext</span> *<span class="hljs-title">hash</span> =</span> 不能为空;<br><span class="hljs-type">uint8_t</span> buffer[SIZE];<br><br>av_hash_update(hash, buffer, size);<br></code></pre></td></tr></table></figure><h3 id="释放-avhashcontext"><a class="markdownIt-Anchor" href="#释放-avhashcontext"></a> <strong>释放 AVHashContext</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AVHashContext</span> *<span class="hljs-title">hash</span>;</span><br><br>av_hash_freep(&amp;hash);<br></code></pre></td></tr></table></figure><h3 id="打开文件-2"><a class="markdownIt-Anchor" href="#打开文件-2"></a> <strong>打开文件</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">char</span> *file = 不能为空;<br><span class="hljs-type">int</span> flags = O_RDONLY;<br><br><span class="hljs-type">int</span> fd = open(file, flags);<br></code></pre></td></tr></table></figure><h3 id="关闭文件-2"><a class="markdownIt-Anchor" href="#关闭文件-2"></a> <strong>关闭文件</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> fd = 不能为空;<br><br><span class="hljs-type">int</span> ret = close(fd);<br></code></pre></td></tr></table></figure><h3 id="获取-hash-算法名"><a class="markdownIt-Anchor" href="#获取-hash-算法名"></a> <strong>获取 hash 算法名</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AVHashContext</span> *<span class="hljs-title">hash</span> =</span> 不能为空;<br><br>av_hash_get_name(hash);<br></code></pre></td></tr></table></figure><h3 id="hash-值转字符串"><a class="markdownIt-Anchor" href="#hash-值转字符串"></a> <strong>hash 值转字符串</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AVHashContext</span> *<span class="hljs-title">hash</span> =</span> 不能为空;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> out_b64 = 不能为空;<br><span class="hljs-type">char</span> res[<span class="hljs-number">2</span> * AV_HASH_MAX_SIZE + <span class="hljs-number">4</span>];<br><br><span class="hljs-keyword">if</span> (out_b64) &#123;<br>    av_hash_final_b64(hash, (<span class="hljs-type">uint8_t</span> *) res, <span class="hljs-keyword">sizeof</span>(res));<br>    LOGD(<span class="hljs-string">&quot;b64:%s&quot;</span>, res);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    av_hash_final_hex(hash, (<span class="hljs-type">uint8_t</span> *) res, <span class="hljs-keyword">sizeof</span>(res));<br>    LOGD(<span class="hljs-string">&quot;0x%s&quot;</span>, res);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="filter_audio"><a class="markdownIt-Anchor" href="#filter_audio"></a> <strong>filter_audio</strong></h2><blockquote><p>This example will generate a sine wave audio, pass it through a simple filter chain, and then compute the MD5 checksum of the output data.<br>The filter chain it uses is: (input) -&gt; abuffer -&gt; volume -&gt; aformat -&gt; abuffersink -&gt; (output)<br>abuffer: This provides the endpoint where you can feed the decoded samples.<br>volume: In this example we hardcode it to 0.90.<br>aformat: This converts the samples to the samplefreq, channel layout, and sample format required by the audio device.<br>abuffersink: This provides the endpoint where you can read the samples after they have passed through the filter chain.</p></blockquote><p>这个例子将生成一个正弦波音频，通过一个简单的过滤器链，然后计算输出数据的 MD5 校验和。<br>它使用的过滤器链是：(input) -&gt; abuffer -&gt; volume -&gt; aformat -&gt; abuffersink -&gt; (output)<br>abuffer：这提供了您可以提供解码样本的端点。<br>volume：在本例中，我们将其硬编码为 0.90。<br>aformat：这会将样本转换为音频设备所需的样本频率、通道布局和样本格式。<br>abuffersink：这提供了端点，您可以在样本通过过滤器链后读取样本。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> INPUT_SAMPLERATE     48000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INPUT_FORMAT         AV_SAMPLE_FMT_FLTP</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INPUT_CHANNEL_LAYOUT AV_CH_LAYOUT_5POINT0</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> VOLUME_VAL 0.90</span><br></code></pre></td></tr></table></figure><h3 id="字符串转-float"><a class="markdownIt-Anchor" href="#字符串转-float"></a> <strong>字符串转 float</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">char</span> *argv[] = 不能为空;<br><br><span class="hljs-type">float</span> duration = atof(argv[<span class="hljs-number">1</span>]);<br></code></pre></td></tr></table></figure><h3 id="创建-avmd5"><a class="markdownIt-Anchor" href="#创建-avmd5"></a> <strong>创建 AVMD5</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AVMD5</span> *<span class="hljs-title">md5</span> =</span> av_md5_alloc();<br></code></pre></td></tr></table></figure><h3 id="初始化-avmd5"><a class="markdownIt-Anchor" href="#初始化-avmd5"></a> <strong>初始化 AVMD5</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AVMD5</span> *<span class="hljs-title">md5</span> =</span> 不能为空;<br><br>av_md5_init(md5);<br></code></pre></td></tr></table></figure><h3 id="计算-md5-值"><a class="markdownIt-Anchor" href="#计算-md5-值"></a> <strong>计算 MD5 值</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C">AVFrame *frame = 不能为空;<br><span class="hljs-type">int</span> planar = av_sample_fmt_is_planar((<span class="hljs-keyword">enum</span> AVSampleFormat) frame-&gt;format);<br><span class="hljs-type">int</span> channels = av_get_channel_layout_nb_channels(frame-&gt;channel_layout);<br><span class="hljs-type">int</span> bps = av_get_bytes_per_sample((<span class="hljs-keyword">enum</span> AVSampleFormat) frame-&gt;format);<br><span class="hljs-type">int</span> plane_size = bps * frame-&gt;nb_samples * (planar ? <span class="hljs-number">1</span> : channels);<br><span class="hljs-type">uint8_t</span> checksum[<span class="hljs-number">16</span>];<br><br>av_md5_sum(checksum, frame-&gt;extended_data[i], plane_size);<br></code></pre></td></tr></table></figure><h3 id="创建-avfiltergraph"><a class="markdownIt-Anchor" href="#创建-avfiltergraph"></a> <strong>创建 AVFilterGraph</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">AVFilterGraph *filter_graph = avfilter_graph_alloc();<br></code></pre></td></tr></table></figure><h3 id="释放-avfiltergraph"><a class="markdownIt-Anchor" href="#释放-avfiltergraph"></a> <strong>释放 AVFilterGraph</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">AVFilterGraph *graph = 不能为空;<br><br>avfilter_graph_free(&amp;graph);<br></code></pre></td></tr></table></figure><h3 id="获取指定的-avfilter"><a class="markdownIt-Anchor" href="#获取指定的-avfilter"></a> <strong>获取指定的 AVFilter</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">const</span> AVFilter *abuffer = avfilter_get_by_name(<span class="hljs-string">&quot;abuffer&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="创建-avfiltercontext"><a class="markdownIt-Anchor" href="#创建-avfiltercontext"></a> <strong>创建 AVFilterContext</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">AVFilterGraph *filter_graph = 不能为空;<br><span class="hljs-type">const</span> AVFilter *abuffer = 不能为空;<br><br>AVFilterContext *abuffer_ctx = avfilter_graph_alloc_filter(filter_graph, abuffer, <span class="hljs-string">&quot;src&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="获取通道布局的描述"><a class="markdownIt-Anchor" href="#获取通道布局的描述"></a> <strong>获取通道布局的描述</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">uint8_t</span> ch_layout[<span class="hljs-number">64</span>];<br><br>av_get_channel_layout_string((<span class="hljs-type">char</span> *) ch_layout, <span class="hljs-keyword">sizeof</span>(ch_layout), <span class="hljs-number">0</span>, INPUT_CHANNEL_LAYOUT);<br></code></pre></td></tr></table></figure><h3 id="设置-avfiltercontext-的参数"><a class="markdownIt-Anchor" href="#设置-avfiltercontext-的参数"></a> <strong>设置 AVFilterContext 的参数</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C">AVFilterContext *abuffer_ctx = 不能为空;<br><span class="hljs-type">uint8_t</span> ch_layout[<span class="hljs-number">64</span>] = 不能为空;<br><br>av_opt_set(abuffer_ctx, <span class="hljs-string">&quot;channel_layout&quot;</span>, (<span class="hljs-type">char</span> *) ch_layout, AV_OPT_SEARCH_CHILDREN);<br>av_opt_set(abuffer_ctx, <span class="hljs-string">&quot;sample_fmt&quot;</span>, av_get_sample_fmt_name(INPUT_FORMAT), AV_OPT_SEARCH_CHILDREN);<br>av_opt_set_q(abuffer_ctx, <span class="hljs-string">&quot;time_base&quot;</span>, (AVRational) &#123;<span class="hljs-number">1</span>, INPUT_SAMPLERATE&#125;, AV_OPT_SEARCH_CHILDREN);<br>av_opt_set_int(abuffer_ctx, <span class="hljs-string">&quot;sample_rate&quot;</span>, INPUT_SAMPLERATE, AV_OPT_SEARCH_CHILDREN);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C">AVFilterContext *buffersink_ctx = 不能为空;<br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AVSampleFormat</span> <span class="hljs-title">out_sample_fmts</span>[] =</span> &#123;AV_SAMPLE_FMT_S16, (<span class="hljs-keyword">enum</span> AVSampleFormat) <span class="hljs-number">-1</span>&#125;;<br><br><span class="hljs-type">int</span> ret = av_opt_set_int_list(buffersink_ctx, <span class="hljs-string">&quot;sample_fmts&quot;</span>, out_sample_fmts, <span class="hljs-number">-1</span>,<br>                              AV_OPT_SEARCH_CHILDREN);<br></code></pre></td></tr></table></figure><h3 id="初始化-avfiltercontext"><a class="markdownIt-Anchor" href="#初始化-avfiltercontext"></a> <strong>初始化 AVFilterContext</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">AVFilterContext *abuffer_ctx = 不能为空;<br><br><span class="hljs-type">int</span> ret = avfilter_init_str(abuffer_ctx, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">AVFilterContext *volume_ctx = 不能为空;<br>AVDictionary *options_dict = 不能为空;<br><br><span class="hljs-type">int</span> ret = avfilter_init_dict(volume_ctx, &amp;options_dict);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C">AVFilterContext *aformat_ctx = 不能为空;<br><span class="hljs-type">uint8_t</span> options_str[<span class="hljs-number">1024</span>];<br><br><span class="hljs-built_in">snprintf</span>((<span class="hljs-type">char</span> *) options_str, <span class="hljs-keyword">sizeof</span>(options_str),<br>         <span class="hljs-string">&quot;sample_fmts=%s:sample_rates=%d:channel_layouts=0x%&quot;</span> PRIx64,<br>         av_get_sample_fmt_name(AV_SAMPLE_FMT_S16), <span class="hljs-number">44100</span>,<br>         (<span class="hljs-type">uint64_t</span>) AV_CH_LAYOUT_STEREO);<br><span class="hljs-type">int</span> ret = avfilter_init_str(aformat_ctx, (<span class="hljs-type">char</span> *) options_str);<br></code></pre></td></tr></table></figure><h3 id="转字符串"><a class="markdownIt-Anchor" href="#转字符串"></a> <strong>转字符串</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *value = AV_STRINGIFY(VOLUME_VAL);<br></code></pre></td></tr></table></figure><h3 id="释放-avdictionary"><a class="markdownIt-Anchor" href="#释放-avdictionary"></a> <strong>释放 AVDictionary</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">AVDictionary *options_dict = 不能为空;<br><br>av_dict_free(&amp;options_dict);<br></code></pre></td></tr></table></figure><h3 id="链接过滤器"><a class="markdownIt-Anchor" href="#链接过滤器"></a> <strong>链接过滤器</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">AVFilterContext *aformat_ctx = 不能为空;<br>AVFilterContext *volume_ctx = 不能为空;<br><br><span class="hljs-type">int</span> ret = avfilter_link(abuffer_ctx, <span class="hljs-number">0</span>, volume_ctx, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h3 id="配置图"><a class="markdownIt-Anchor" href="#配置图"></a> <strong>配置图</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">AVFilterGraph *filter_graph = 不能为空;<br><br><span class="hljs-type">int</span> ret = avfilter_graph_config(filter_graph, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><h3 id="将帧发送到-avfiltergraph-的输入"><a class="markdownIt-Anchor" href="#将帧发送到-avfiltergraph-的输入"></a> <strong>将帧发送到 AVFilterGraph 的输入</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">AVFilterContext *src = 不能为空;<br>AVFrame *frame = 不能为空;<br><br><span class="hljs-type">int</span> ret = av_buffersrc_add_frame(src, frame);<br></code></pre></td></tr></table></figure><h3 id="获取-avfiltergraph-的输出"><a class="markdownIt-Anchor" href="#获取-avfiltergraph-的输出"></a> <strong>获取 AVFilterGraph 的输出</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">AVFilterContext *sink = 不能为空;<br>AVFrame *frame = 不能为空;<br><br><span class="hljs-type">int</span> ret = av_buffersink_get_frame(sink, frame);<br></code></pre></td></tr></table></figure><h3 id="释放对-avframe-的引用"><a class="markdownIt-Anchor" href="#释放对-avframe-的引用"></a> <strong>释放对 AVFrame 的引用</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">AVFrame *frame = 不能为空;<br><br>av_frame_unref(frame);<br></code></pre></td></tr></table></figure><h2 id="filtering_audio"><a class="markdownIt-Anchor" href="#filtering_audio"></a> <strong>filtering_audio</strong></h2><blockquote><p>API example for audio decoding and filtering</p></blockquote><p>用于音频解码和过滤的 API 示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *audio_filter_descr = <span class="hljs-string">&quot;aresample=8000,aformat=sample_fmts=s16:channel_layouts=mono&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="创建-avfilterinout"><a class="markdownIt-Anchor" href="#创建-avfilterinout"></a> <strong>创建 AVFilterInOut</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">AVFilterInOut *outputs = avfilter_inout_alloc();<br></code></pre></td></tr></table></figure><h3 id="释放-avfilterinout"><a class="markdownIt-Anchor" href="#释放-avfilterinout"></a> <strong>释放 AVFilterInOut</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">AVFilterInOut *outputs = 不能为空;<br><br>avfilter_inout_free(&amp;outputs);<br></code></pre></td></tr></table></figure><h3 id="获取指定数量频道的默认频道布局"><a class="markdownIt-Anchor" href="#获取指定数量频道的默认频道布局"></a> <strong>获取指定数量频道的默认频道布局</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> AVCodecContext *dec_ctx = 不能为空;<br><br>dec_ctx-&gt;channel_layout = av_get_default_channel_layout(dec_ctx-&gt;channels);<br></code></pre></td></tr></table></figure><h3 id="创建过滤器并添加到图中"><a class="markdownIt-Anchor" href="#创建过滤器并添加到图中"></a> <strong>创建过滤器并添加到图中</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C">AVFilterContext *buffersrc_ctx = 不能为空;<br><span class="hljs-type">const</span> AVFilter *abuffersrc = 不能为空;<br><span class="hljs-type">char</span> args[<span class="hljs-number">512</span>];<br>AVFilterGraph *filter_graph = 不能为空;<br><br>AVRational time_base = 不能为空;<br><span class="hljs-type">static</span> AVCodecContext *dec_ctx = 不能为空;<br><span class="hljs-built_in">snprintf</span>(args, <span class="hljs-keyword">sizeof</span>(args),<br>         <span class="hljs-string">&quot;time_base=%d/%d:sample_rate=%d:sample_fmt=%s:channel_layout=0x%&quot;</span> PRIx64,<br>         time_base.num, time_base.den, dec_ctx-&gt;sample_rate,<br>         av_get_sample_fmt_name(dec_ctx-&gt;sample_fmt), dec_ctx-&gt;channel_layout);<br><br><span class="hljs-type">int</span> ret = avfilter_graph_create_filter(&amp;buffersrc_ctx, abuffersrc, <span class="hljs-string">&quot;in&quot;</span>,<br>                                       args, <span class="hljs-literal">NULL</span>, filter_graph);<br></code></pre></td></tr></table></figure><h3 id="设置-avfilterinout-的参数"><a class="markdownIt-Anchor" href="#设置-avfilterinout-的参数"></a> <strong>设置 AVFilterInOut 的参数</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C">AVFilterInOut *outputs = 不能为空;<br>AVFilterContext *buffersrc_ctx = 不能为空;<br><br><span class="hljs-comment">// 缓冲源输出必须连接到由 filters_descr 描述的第一个滤波器的输入板；</span><br><span class="hljs-comment">// 由于未指定第一个过滤器的输入标签，因此默认设置为“in”。</span><br>outputs-&gt;name = av_strdup(<span class="hljs-string">&quot;in&quot;</span>);<br>outputs-&gt;filter_ctx = buffersrc_ctx;<br>outputs-&gt;pad_idx = <span class="hljs-number">0</span>;<br>outputs-&gt;next = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C">AVFilterInOut *inputs = 不能为空;<br>AVFilterContext *buffersink_ctx = 不能为空;<br><br><span class="hljs-comment">// 缓冲接收器输入必须连接到由 filters_descr 描述的最后一个滤波器的输出板；</span><br><span class="hljs-comment">// 由于未指定最后一个过滤器输出标签，因此默认设置为“out”。</span><br>inputs-&gt;name = av_strdup(<span class="hljs-string">&quot;out&quot;</span>);<br>inputs-&gt;filter_ctx = buffersink_ctx;<br>inputs-&gt;pad_idx = <span class="hljs-number">0</span>;<br>inputs-&gt;next = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><h3 id="添加图"><a class="markdownIt-Anchor" href="#添加图"></a> <strong>添加图</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C">AVFilterGraph *filter_graph = 不能为空;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *filters_descr = 不能为空;<br>AVFilterInOut *inputs = 不能为空;<br>AVFilterInOut *outputs = 不能为空;<br><br><span class="hljs-type">int</span> ret = avfilter_graph_parse_ptr(filter_graph, filters_descr,<br>                                    &amp;inputs, &amp;outputs, <span class="hljs-literal">NULL</span>)<br></code></pre></td></tr></table></figure><h3 id="将帧添加到缓冲区源"><a class="markdownIt-Anchor" href="#将帧添加到缓冲区源"></a> <strong>将帧添加到缓冲区源</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">AVFilterContext *buffersrc_ctx = 不能为空;<br>AVFrame *frame = 不能为空;<br><br><span class="hljs-type">int</span> ret = av_buffersrc_add_frame_flags(buffersrc_ctx, frame, AV_BUFFERSRC_FLAG_KEEP_REF);<br></code></pre></td></tr></table></figure><h2 id="filtering_video"><a class="markdownIt-Anchor" href="#filtering_video"></a> <strong>filtering_video</strong></h2><blockquote><p>API example for decoding and filtering</p></blockquote><p>用于解码和过滤的 API 示例</p><h3 id="睡眠一段时间"><a class="markdownIt-Anchor" href="#睡眠一段时间"></a> <strong>睡眠一段时间</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">const</span> AVFrame *frame = 不能为空;<br><br><span class="hljs-comment">// 该操作在数学上等价于 a * bq / cq</span><br><span class="hljs-type">int64_t</span> delay = av_rescale_q(frame-&gt;pts - last_pts,<br>                             time_base, AV_TIME_BASE_Q);<br><span class="hljs-keyword">if</span> (delay &gt; <span class="hljs-number">0</span> &amp;&amp; delay &lt; <span class="hljs-number">1000000</span>)<br>    usleep(delay);<br></code></pre></td></tr></table></figure><h3 id="将视频中的像素点替换成字符然后从终端输出"><a class="markdownIt-Anchor" href="#将视频中的像素点替换成字符然后从终端输出"></a> <strong>将视频中的像素点替换成字符，然后从终端输出</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">const</span> AVFrame *frame = 不能为空;<br><span class="hljs-type">int</span> x, y;<br><span class="hljs-type">uint8_t</span> *p0, *p;<br><br>p0 = frame-&gt;data[<span class="hljs-number">0</span>];<br><span class="hljs-comment">// 把一个字符串写入到标准输出 stdout</span><br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\033c&quot;</span>);<br><span class="hljs-keyword">for</span> (y = <span class="hljs-number">0</span>; y &lt; frame-&gt;height; y++) &#123;<br>    p = p0;<br>    <span class="hljs-keyword">for</span> (x = <span class="hljs-number">0</span>; x &lt; frame-&gt;width; x++)<br>        <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&quot; .-+#&quot;</span>[*(p++) / <span class="hljs-number">52</span>]);<br>    <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>    p0 += frame-&gt;linesize[<span class="hljs-number">0</span>];<br>&#125;<br>fflush(<span class="hljs-built_in">stdout</span>);<br></code></pre></td></tr></table></figure><h2 id="http_multiclient"><a class="markdownIt-Anchor" href="#http_multiclient"></a> <strong>http_multiclient</strong></h2><blockquote><p>API example program to serve http to multiple clients.<br>This example will serve a file without decoding or demuxing it over http.Multiple clients can connect and will receive the same file.</p></blockquote><p>为多个客户端提供 http 服务的 API 示例程序。<br>此示例将提供一个文件，而无需通过 http 对其进行解码或解复用。多个客户端可以连接并接收相同的文件。</p><h3 id="创建并初始化服务端-aviocontext"><a class="markdownIt-Anchor" href="#创建并初始化服务端-aviocontext"></a> <strong>创建并初始化服务端 AVIOContext</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C">AVDictionary *options = 不能为空;<br>AVIOContext *server = 不能为空;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *out_uri = 不能为空;<br><br><span class="hljs-type">int</span> ret = avio_open2(&amp;server, out_uri, AVIO_FLAG_WRITE, <span class="hljs-literal">NULL</span>, &amp;options);<br></code></pre></td></tr></table></figure><h3 id="接受并创建客户端-aviocontext"><a class="markdownIt-Anchor" href="#接受并创建客户端-aviocontext"></a> <strong>接受并创建客户端 AVIOContext</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">AVIOContext *client = <span class="hljs-literal">NULL</span>;<br>AVIOContext *server = 不能为空;<br><br><span class="hljs-type">int</span> ret = avio_accept(server, &amp;client);<br></code></pre></td></tr></table></figure><h3 id="刷新-aviocontext"><a class="markdownIt-Anchor" href="#刷新-aviocontext"></a> <strong>刷新 AVIOContext</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">AVIOContext *client = 不能为空;<br><br>avio_flush(client);<br></code></pre></td></tr></table></figure><h3 id="关闭-aviocontext"><a class="markdownIt-Anchor" href="#关闭-aviocontext"></a> <strong>关闭 AVIOContext</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">AVIOContext *server = 不能为空;<br><br><span class="hljs-type">int</span> ret = avio_close(server);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">AVFormatContext *ofmt_ctx = 不能为空;<br><br>avio_closep(&amp;ofmt_ctx-&gt;pb);<br></code></pre></td></tr></table></figure><h3 id="创建进程"><a class="markdownIt-Anchor" href="#创建进程"></a> <strong>创建进程</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> pid = fork();<br></code></pre></td></tr></table></figure><h3 id="http-握手"><a class="markdownIt-Anchor" href="#http-握手"></a> <strong>HTTP 握手</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">AVIOContext *client = 不能为空;<br><br><span class="hljs-type">int</span> ret = avio_handshake(client);<br></code></pre></td></tr></table></figure><h3 id="获取指定参数的值"><a class="markdownIt-Anchor" href="#获取指定参数的值"></a> <strong>获取指定参数的值</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">AVIOContext *client = 不能为空;<br><span class="hljs-type">uint8_t</span> *resource = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-type">int</span> ret = av_opt_get(client, <span class="hljs-string">&quot;resource&quot;</span>, AV_OPT_SEARCH_CHILDREN, &amp;resource);<br></code></pre></td></tr></table></figure><h3 id="打开指定的文件"><a class="markdownIt-Anchor" href="#打开指定的文件"></a> <strong>打开指定的文件</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">AVIOContext *input = <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *in_uri = 不能为空;<br><br><span class="hljs-type">int</span> ret = avio_open2(&amp;input, in_uri, AVIO_FLAG_READ, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>)<br></code></pre></td></tr></table></figure><h3 id="循环读并发给客户端直到读完"><a class="markdownIt-Anchor" href="#循环读并发给客户端直到读完"></a> <strong>循环读，并发给客户端，直到读完</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C">AVIOContext *input = 不能为空;<br>AVIOContext *client = 不能为空;<br><span class="hljs-type">uint8_t</span> buf[<span class="hljs-number">1024</span>];<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-keyword">for</span> (;;) &#123;<br>    n = avio_read(input, buf, <span class="hljs-keyword">sizeof</span>(buf));<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (n == AVERROR_EOF)<br>            <span class="hljs-keyword">break</span>;<br>        av_log(input, AV_LOG_ERROR, <span class="hljs-string">&quot;Error reading from input: %s.\n&quot;</span>,<br>               av_err2str(n));<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    avio_write(client, buf, n);<br>    avio_flush(client);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="hw_decode"><a class="markdownIt-Anchor" href="#hw_decode"></a> <strong>hw_decode</strong></h2><blockquote><p>HW-Accelerated decoding example.<br>This example shows how to do HW-accelerated decoding with output frames from the HW video surfaces.</p></blockquote><p>硬件加速解码示例。<br>此示例说明如何使用来自硬件视频表面的输出帧进行硬件加速解码。</p><h3 id="获取指定的-avhwdevicetype"><a class="markdownIt-Anchor" href="#获取指定的-avhwdevicetype"></a> <strong>获取指定的 AVHWDeviceType</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">char</span> *argv[] = 不能为空;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AVHWDeviceType</span> <span class="hljs-title">type</span> =</span> av_hwdevice_find_type_by_name(argv[<span class="hljs-number">1</span>]);<br></code></pre></td></tr></table></figure><h3 id="遍历受支持的-avhwdevicetype"><a class="markdownIt-Anchor" href="#遍历受支持的-avhwdevicetype"></a> <strong>遍历受支持的 AVHWDeviceType</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AVHWDeviceType</span> <span class="hljs-title">type</span> =</span> 不能为空;<br><br>type = av_hwdevice_iterate_types(type);<br></code></pre></td></tr></table></figure><h3 id="获取-avhwdevicetype-的字符串名称"><a class="markdownIt-Anchor" href="#获取-avhwdevicetype-的字符串名称"></a> <strong>获取 AVHWDeviceType 的字符串名称</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AVHWDeviceType</span> <span class="hljs-title">type</span> =</span> 不能为空;<br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* str = av_hwdevice_get_type_name(type);<br></code></pre></td></tr></table></figure><h3 id="获取-avcodec-支持的硬件配置"><a class="markdownIt-Anchor" href="#获取-avcodec-支持的硬件配置"></a> <strong>获取 AVCodec 支持的硬件配置</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">const</span> AVCodec *decoder = 不能为空;<br><span class="hljs-type">int</span> i;<br><br><span class="hljs-type">const</span> AVCodecHWConfig *config = avcodec_get_hw_config(decoder, i);<br></code></pre></td></tr></table></figure><h3 id="打开指定类型的设备并创建-avcodeccontext"><a class="markdownIt-Anchor" href="#打开指定类型的设备并创建-avcodeccontext"></a> <strong>打开指定类型的设备，并创建 AVCodecContext</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> AVBufferRef *hw_device_ctx = 不能为空;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AVHWDeviceType</span> <span class="hljs-title">type</span> =</span> 不能为空;<br><br><span class="hljs-type">int</span> err = av_hwdevice_ctx_create(&amp;hw_device_ctx, type,<br>                                  <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h3 id="创建新的引用"><a class="markdownIt-Anchor" href="#创建新的引用"></a> <strong>创建新的引用</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> AVBufferRef *hw_device_ctx = 不能为空;<br><br>AVBufferRef *ref = av_buffer_ref(hw_device_ctx);<br></code></pre></td></tr></table></figure><h3 id="释放引用"><a class="markdownIt-Anchor" href="#释放引用"></a> <strong>释放引用</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> AVBufferRef *hw_device_ctx = 不能为空;<br><br>av_buffer_unref(&amp;hw_device_ctx);<br></code></pre></td></tr></table></figure><h3 id="在不同硬件之间复制数据"><a class="markdownIt-Anchor" href="#在不同硬件之间复制数据"></a> <strong>在不同硬件之间复制数据</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">AVFrame *frame = 不能为空;<br>AVFrame *sw_frame = 不能为空;<br><br><span class="hljs-type">int</span> ret = av_hwframe_transfer_data(sw_frame, frame, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h3 id="获取所需的内存大小"><a class="markdownIt-Anchor" href="#获取所需的内存大小"></a> <strong>获取所需的内存大小</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">AVFrame *tmp_frame = 不能为空;<br><br><span class="hljs-type">int</span> size = av_image_get_buffer_size((<span class="hljs-keyword">enum</span> AVPixelFormat) tmp_frame-&gt;format, tmp_frame-&gt;width,<br>                                    tmp_frame-&gt;height, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h3 id="复制数据到缓冲区"><a class="markdownIt-Anchor" href="#复制数据到缓冲区"></a> <strong>复制数据到缓冲区</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">uint8_t</span> *buffer = 不能为空;<br><span class="hljs-type">int</span> size = 不能为空;<br>AVFrame *tmp_frame = 不能为空;<br><br><span class="hljs-type">int</span> ret = av_image_copy_to_buffer(buffer, size,<br>                                  (<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *<span class="hljs-type">const</span> *) tmp_frame-&gt;data,<br>                                  (<span class="hljs-type">const</span> <span class="hljs-type">int</span> *) tmp_frame-&gt;linesize, (<span class="hljs-keyword">enum</span> AVPixelFormat) tmp_frame-&gt;format,<br>                                  tmp_frame-&gt;width, tmp_frame-&gt;height, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h2 id="metadata"><a class="markdownIt-Anchor" href="#metadata"></a> <strong>metadata</strong></h2><blockquote><p>example program to demonstrate the use of the libavformat metadata API.</p></blockquote><p>示例程序来演示 libavformat 元数据 API 的使用。</p><h3 id="获取-avdictionaryentry"><a class="markdownIt-Anchor" href="#获取-avdictionaryentry"></a> <strong>获取 AVDictionaryEntry</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">const</span> AVDictionaryEntry *tag = av_dict_get(fmt_ctx-&gt;metadata, <span class="hljs-string">&quot;&quot;</span>, tag, AV_DICT_IGNORE_SUFFIX);<br></code></pre></td></tr></table></figure><h2 id="muxing"><a class="markdownIt-Anchor" href="#muxing"></a> <strong>muxing</strong></h2><blockquote><p>API example program to output a media file with libavformat.<br>This program generates a synthetic audio and video stream, encodes and muxes them into a file named output_file.<br>The output format is automatically guessed according to the file extension.<br>Raw images can also be output by using ‘%%d’ in the filename.</p></blockquote><p>使用 libavformat 输出媒体文件的 API 示例程序。<br>该程序生成合成的音频和视频流，将它们编码并复用到一个名为 output_file 的文件中。<br>根据文件扩展名自动猜测输出格式。<br>也可以通过在文件名中使用“%%d”来输出原始图像。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> STREAM_DURATION   10.0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STREAM_FRAME_RATE 25 <span class="hljs-comment">/* 25 images/s */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STREAM_PIX_FMT    AV_PIX_FMT_YUV420P <span class="hljs-comment">/* default pix_fmt */</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SCALE_FLAGS SWS_BICUBIC</span><br></code></pre></td></tr></table></figure><h3 id="比较两个字符串的值"><a class="markdownIt-Anchor" href="#比较两个字符串的值"></a> <strong>比较两个字符串的值</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">char</span> **argv = 不能为空;<br><br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">strcmp</span>(argv[i], <span class="hljs-string">&quot;-flags&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="创建输出的-avformatcontext"><a class="markdownIt-Anchor" href="#创建输出的-avformatcontext"></a> <strong>创建输出的 AVFormatContext</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">AVFormatContext *oc;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename = 不能为空;<br><br><span class="hljs-type">int</span> ret = avformat_alloc_output_context2(&amp;oc, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, filename);<br></code></pre></td></tr></table></figure><h3 id="释放-avformatcontext"><a class="markdownIt-Anchor" href="#释放-avformatcontext"></a> <strong>释放 AVFormatContext</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">AVFormatContext *oc = 不能为空;<br><br>avformat_free_context(oc);<br></code></pre></td></tr></table></figure><h3 id="获取-avcodec-的字符串名称"><a class="markdownIt-Anchor" href="#获取-avcodec-的字符串名称"></a> <strong>获取 AVCodec 的字符串名称</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AVCodecID</span> <span class="hljs-title">codec_id</span> =</span> 不能为空;<br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *codec = avcodec_get_name(codec_id);<br></code></pre></td></tr></table></figure><h3 id="创建-avstream"><a class="markdownIt-Anchor" href="#创建-avstream"></a> <strong>创建 AVStream</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">AVFormatContext *oc = 不能为空;<br><br>AVStream *st = avformat_new_stream(oc, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><h3 id="复制-avdictionary"><a class="markdownIt-Anchor" href="#复制-avdictionary"></a> <strong>复制 AVDictionary</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">AVDictionary *opt_arg = 不能为空;<br>AVDictionary *opt = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-type">int</span> ret = av_dict_copy(&amp;opt, opt_arg, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h3 id="设置-avcodecparameters-的值"><a class="markdownIt-Anchor" href="#设置-avcodecparameters-的值"></a> <strong>设置 AVCodecParameters 的值</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">OutputStream *ost = 不能为空;<br>AVCodecContext *c = ost-&gt;enc;<br><br><span class="hljs-type">int</span> ret = avcodec_parameters_from_context(ost-&gt;st-&gt;codecpar, c);<br></code></pre></td></tr></table></figure><h3 id="创建-swrcontext"><a class="markdownIt-Anchor" href="#创建-swrcontext"></a> <strong>创建 SwrContext</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">OutputStream *ost = 不能为空;<br><br>ost-&gt;swr_ctx = swr_alloc();<br></code></pre></td></tr></table></figure><h3 id="释放-swrcontext"><a class="markdownIt-Anchor" href="#释放-swrcontext"></a> <strong>释放 SwrContext</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">OutputStream *ost = 不能为空;<br><br>swr_free(&amp;ost-&gt;swr_ctx);<br></code></pre></td></tr></table></figure><h3 id="设置-swrcontext-的参数"><a class="markdownIt-Anchor" href="#设置-swrcontext-的参数"></a> <strong>设置 SwrContext 的参数</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">OutputStream *ost = 不能为空;<br><br><span class="hljs-type">int</span> ret = av_opt_set_sample_fmt(ost-&gt;swr_ctx, <span class="hljs-string">&quot;in_sample_fmt&quot;</span>, AV_SAMPLE_FMT_S16, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h3 id="初始化-swrcontext"><a class="markdownIt-Anchor" href="#初始化-swrcontext"></a> <strong>初始化 SwrContext</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">OutputStream *ost = 不能为空;<br><br><span class="hljs-type">int</span> ret = swr_init(ost-&gt;swr_ctx);<br></code></pre></td></tr></table></figure><h3 id="创建-aviocontext-2"><a class="markdownIt-Anchor" href="#创建-aviocontext-2"></a> <strong>创建 AVIOContext</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">AVFormatContext *oc = 不能为空;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename = 不能为空;<br><br><span class="hljs-type">int</span> ret = avio_open(&amp;oc-&gt;pb, filename, AVIO_FLAG_WRITE);<br></code></pre></td></tr></table></figure><h3 id="写文件头"><a class="markdownIt-Anchor" href="#写文件头"></a> <strong>写文件头</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">AVFormatContext *oc = 不能为空;<br>AVDictionary *opt = 不能为空;<br><br><span class="hljs-type">int</span> ret = avformat_write_header(oc, &amp;opt);<br></code></pre></td></tr></table></figure><h3 id="比较时间戳"><a class="markdownIt-Anchor" href="#比较时间戳"></a> <strong>比较时间戳</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">OutputStream video_st = &#123;<span class="hljs-number">0</span>&#125;, audio_st = &#123;<span class="hljs-number">0</span>&#125;;<br>    <br><span class="hljs-type">int</span> ret = av_compare_ts(video_st.next_pts, video_st.enc-&gt;time_base,<br>                        audio_st.next_pts, audio_st.enc-&gt;time_base)<br></code></pre></td></tr></table></figure><h3 id="创建-swscontext"><a class="markdownIt-Anchor" href="#创建-swscontext"></a> <strong>创建 SwsContext</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C">AVCodecContext *c = 不能为空;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SwsContext</span> *<span class="hljs-title">sws_ctx</span> =</span> sws_getContext(c-&gt;width, c-&gt;height,<br>                                          AV_PIX_FMT_YUV420P,<br>                                          c-&gt;width, c-&gt;height,<br>                                          c-&gt;pix_fmt,<br>                                          SCALE_FLAGS, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><h3 id="释放-swscontext"><a class="markdownIt-Anchor" href="#释放-swscontext"></a> <strong>释放 SwsContext</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">OutputStream *ost = 不能为空;<br><br>sws_freeContext(ost-&gt;sws_ctx);<br></code></pre></td></tr></table></figure><h3 id="缩放"><a class="markdownIt-Anchor" href="#缩放"></a> <strong>缩放</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C">OutputStream *ost = 不能为空;<br>AVCodecContext *c = 不能为空;<br><br><span class="hljs-type">int</span> ret = sws_scale(ost-&gt;sws_ctx, (<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *<span class="hljs-type">const</span> *) ost-&gt;tmp_frame-&gt;data,<br>                  ost-&gt;tmp_frame-&gt;linesize, <span class="hljs-number">0</span>, c-&gt;height, ost-&gt;frame-&gt;data,<br>                  ost-&gt;frame-&gt;linesize);<br></code></pre></td></tr></table></figure><h3 id="转换-timebase"><a class="markdownIt-Anchor" href="#转换-timebase"></a> <strong>转换 timebase</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C">AVPacket *pkt = 不能为空;<br>AVCodecContext *c = 不能为空;<br>AVStream *st = 不能为空;<br><br>av_packet_rescale_ts(pkt, c-&gt;time_base, st-&gt;time_base);<br></code></pre></td></tr></table></figure><h3 id="打印-avpacket-的信息"><a class="markdownIt-Anchor" href="#打印-avpacket-的信息"></a> <strong>打印 AVPacket 的信息</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">const</span> AVFormatContext *fmt_ctx = 不能为空;<br><span class="hljs-type">const</span> AVPacket *pkt = 不能为空;<br><br>AVRational *time_base = &amp;fmt_ctx-&gt;streams[pkt-&gt;stream_index]-&gt;time_base;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pts:%s pts_time:%s dts:%s dts_time:%s duration:%s duration_time:%s stream_index:%d\n&quot;</span>,<br>       av_ts2str(pkt-&gt;pts), av_ts2timestr(pkt-&gt;pts, time_base),<br>       av_ts2str(pkt-&gt;dts), av_ts2timestr(pkt-&gt;dts, time_base),<br>       av_ts2str(pkt-&gt;duration), av_ts2timestr(pkt-&gt;duration, time_base),<br>       pkt-&gt;stream_index);<br></code></pre></td></tr></table></figure><h3 id="写-avpacket-到文件并重置-avpacket"><a class="markdownIt-Anchor" href="#写-avpacket-到文件并重置-avpacket"></a> <strong>写 AVPacket 到文件，并重置 AVPacket</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">const</span> AVFormatContext *fmt_ctx = 不能为空;<br><span class="hljs-type">const</span> AVPacket *pkt = 不能为空;<br><br><span class="hljs-type">int</span> ret = av_interleaved_write_frame(fmt_ctx, pkt);<br></code></pre></td></tr></table></figure><h3 id="获取下一个输入样本相对于下一个输出样本将经历的延迟"><a class="markdownIt-Anchor" href="#获取下一个输入样本相对于下一个输出样本将经历的延迟"></a> <strong>获取下一个输入样本相对于下一个输出样本将经历的延迟</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int64_t</span> delay = swr_get_delay(ost-&gt;swr_ctx, c-&gt;sample_rate);<br></code></pre></td></tr></table></figure><h3 id="使用指定的舍入重新调整-64-位整数"><a class="markdownIt-Anchor" href="#使用指定的舍入重新调整-64-位整数"></a> <strong>使用指定的舍入重新调整 64 位整数</strong></h3><p>该运算在数学上相当于a * b / c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> dst_nb_samples = av_rescale_rnd(swr_get_delay(ost-&gt;swr_ctx, c-&gt;sample_rate) + frame-&gt;nb_samples,<br>                                    c-&gt;sample_rate, c-&gt;sample_rate, AV_ROUND_UP);<br></code></pre></td></tr></table></figure><h3 id="转换音频"><a class="markdownIt-Anchor" href="#转换音频"></a> <strong>转换音频</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C">OutputStream *ost = 不能为空;<br><span class="hljs-type">int</span> dst_nb_samples = 不能为空;<br>AVFrame *frame = 不能为空;<br><br><span class="hljs-type">int</span> ret = swr_convert(ost-&gt;swr_ctx,<br>                      ost-&gt;frame-&gt;data, dst_nb_samples,<br>                      (<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> **) frame-&gt;data, frame-&gt;nb_samples);<br></code></pre></td></tr></table></figure><h3 id="写文件尾"><a class="markdownIt-Anchor" href="#写文件尾"></a> <strong>写文件尾</strong></h3><p>只能在成功调用 avformat_write_header 后调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">AVFormatContext *oc = 不能为空;<br><br><span class="hljs-type">int</span> ret = av_write_trailer(oc);<br></code></pre></td></tr></table></figure><h2 id="qsvdec"><a class="markdownIt-Anchor" href="#qsvdec"></a> <strong>qsvdec</strong></h2><blockquote><p>This example shows how to do QSV-accelerated H.264 decoding with output frames in the GPU video surfaces.</p></blockquote><p>此示例说明如何使用 GPU 视频表面中的输出帧进行 QSV 加速 H.264 解码。</p><h3 id="获取指定的-avcodec-5"><a class="markdownIt-Anchor" href="#获取指定的-avcodec-5"></a> <strong>获取指定的 AVCodec</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">const</span> AVCodec *decoder = avcodec_find_decoder_by_name(<span class="hljs-string">&quot;h264_qsv&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="获取所需的内存"><a class="markdownIt-Anchor" href="#获取所需的内存"></a> <strong>获取所需的内存</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">AVStream *video_st = 不能为空;<br><br><span class="hljs-type">uint8_t</span> *mem = (<span class="hljs-type">uint8_t</span> *) av_mallocz(video_st-&gt;codecpar-&gt;extradata_size +<br>                                        AV_INPUT_BUFFER_PADDING_SIZE);<br></code></pre></td></tr></table></figure><h2 id="remuxing"><a class="markdownIt-Anchor" href="#remuxing"></a> <strong>remuxing</strong></h2><blockquote><p>API example program to remux a media file with libavformat and libavcodec.</p></blockquote><p>使用 libavformat 和 libavcodec 重新混合媒体文件的 API 示例程序。</p><h3 id="获取所需的内存-2"><a class="markdownIt-Anchor" href="#获取所需的内存-2"></a> <strong>获取所需的内存</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> *stream_mapping = 不能为空;<br><span class="hljs-type">int</span> stream_mapping_size = 不能为空;<br><br><span class="hljs-type">int</span> *mem = (<span class="hljs-type">int</span> *) av_calloc(stream_mapping_size, <span class="hljs-keyword">sizeof</span>(*stream_mapping));<br></code></pre></td></tr></table></figure><h3 id="复制-avcodecparameters"><a class="markdownIt-Anchor" href="#复制-avcodecparameters"></a> <strong>复制 AVCodecParameters</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">AVStream *out_stream = 不能为空;<br>AVCodecParameters *in_codecpar = 不能为空;<br><br><span class="hljs-type">int</span> ret = avcodec_parameters_copy(out_stream-&gt;codecpar, in_codecpar);<br></code></pre></td></tr></table></figure><h2 id="resampling_audio"><a class="markdownIt-Anchor" href="#resampling_audio"></a> <strong>resampling_audio</strong></h2><blockquote><p>API example program to show how to resample an audio stream with libswresample.<br>This program generates a series of audio frames, resamples them to a specified output format and rate and saves them to an output file named output_file.</p></blockquote><p>API 示例程序，展示如何使用 libswresample 重新采样音频流。<br>该程序生成一系列音频帧，将它们重新采样为指定的输出格式和速率，并将它们保存到名为 output_file 的输出文件中。</p><h3 id="创建缓冲区-3"><a class="markdownIt-Anchor" href="#创建缓冲区-3"></a> <strong>创建缓冲区</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">uint8_t</span> **src_data = 不能为空;<br><span class="hljs-type">int</span> src_linesize = 不能为空;<br><span class="hljs-type">int</span> src_nb_channels = 不能为空;<br><span class="hljs-type">int</span> src_nb_samples = 不能为空;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AVSampleFormat</span> <span class="hljs-title">src_sample_fmt</span> =</span> 不能为空;<br><br><span class="hljs-type">int</span> ret = av_samples_alloc_array_and_samples(&amp;src_data, &amp;src_linesize, src_nb_channels,<br>                                             src_nb_samples, src_sample_fmt, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h3 id="创建缓冲区-4"><a class="markdownIt-Anchor" href="#创建缓冲区-4"></a> <strong>创建缓冲区</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">uint8_t</span> **dst_data = 不能为空;<br><span class="hljs-type">int</span> dst_linesize = 不能为空;<br><span class="hljs-type">int</span> dst_nb_channels = 不能为空;<br><span class="hljs-type">int</span> dst_nb_samples = 不能为空;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AVSampleFormat</span> <span class="hljs-title">dst_sample_fmt</span> =</span> 不能为空;<br><br><span class="hljs-type">int</span> ret = av_samples_alloc(dst_data, &amp;dst_linesize, dst_nb_channels,<br>                           dst_nb_samples, dst_sample_fmt, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h3 id="获取所需的内存大小-2"><a class="markdownIt-Anchor" href="#获取所需的内存大小-2"></a> <strong>获取所需的内存大小</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> dst_linesize = 不能为空;<br><span class="hljs-type">int</span> dst_nb_channels = 不能为空;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AVSampleFormat</span> <span class="hljs-title">dst_sample_fmt</span> =</span> 不能为空;<br><br><span class="hljs-type">int</span> dst_bufsize = av_samples_get_buffer_size(&amp;dst_linesize, dst_nb_channels,<br>                                             ret, dst_sample_fmt, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h2 id="scaling_video"><a class="markdownIt-Anchor" href="#scaling_video"></a> <strong>scaling_video</strong></h2><blockquote><p>API example program to show how to scale an image with libswscale.<br>This program generates a series of pictures, rescales them to the given output_size and saves them to an output file named output_file.</p></blockquote><p>展示如何使用 libswscale 缩放图像的 API 示例程序。<br>该程序生成一系列图片，将它们重新缩放到给定的 output_size 并将它们保存到名为 output_file 的输出文件中。</p><h3 id="解析出视频的宽高数据"><a class="markdownIt-Anchor" href="#解析出视频的宽高数据"></a> <strong>解析出视频的宽高数据</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *dst_size = 不能为空;<br><span class="hljs-type">int</span> dst_w, dst_h;<br><br><span class="hljs-type">int</span> ret = av_parse_video_size(&amp;dst_w, &amp;dst_h, dst_size);<br></code></pre></td></tr></table></figure><h3 id="获取像素格式的短名称"><a class="markdownIt-Anchor" href="#获取像素格式的短名称"></a> <strong>获取像素格式的短名称</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AVPixelFormat</span> <span class="hljs-title">dst_pix_fmt</span> =</span> 不能为空;<br><br><span class="hljs-type">char</span> *str = av_get_pix_fmt_name(dst_pix_fmt);<br></code></pre></td></tr></table></figure><h2 id="transcode_aac"><a class="markdownIt-Anchor" href="#transcode_aac"></a> <strong>transcode_aac</strong></h2><blockquote><p>Simple audio converter<br>Convert an input audio file to AAC in an MP4 container using FFmpeg.Formats other than MP4 are supported based on the output file extension.</p></blockquote><p>简单的音频转换器<br>使用 FFmpeg 将输入音频文件转换为 MP4 容器中的 AAC。根据输出文件扩展名，支持 MP4 以外的格式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> OUTPUT_BIT_RATE 96000</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OUTPUT_CHANNELS 2</span><br></code></pre></td></tr></table></figure><h3 id="获取-avoutputformat"><a class="markdownIt-Anchor" href="#获取-avoutputformat"></a> <strong>获取 AVOutputFormat</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">const</span> AVOutputFormat *format = av_guess_format(<span class="hljs-literal">NULL</span>, filename,<br>                                                  <span class="hljs-literal">NULL</span>)<br></code></pre></td></tr></table></figure><h3 id="创建-swrcontext-并设置参数"><a class="markdownIt-Anchor" href="#创建-swrcontext-并设置参数"></a> <strong>创建 SwrContext 并设置参数</strong></h3><p>// 为简单起见，假定基于通道数量的默认通道布局（解复用器和/或解码器有时无法正确检测到它们）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C">AVCodecContext *input_codec_context = 不能为空;<br>AVCodecContext *output_codec_context = 不能为空;<br>SwrContext **resample_context = 不能为空;<br><br>*resample_context = swr_alloc_set_opts(<span class="hljs-literal">NULL</span>,<br>                                       av_get_default_channel_layout(output_codec_context-&gt;channels),<br>                                       output_codec_context-&gt;sample_fmt,<br>                                       output_codec_context-&gt;sample_rate,<br>                                       av_get_default_channel_layout(input_codec_context-&gt;channels),<br>                                       input_codec_context-&gt;sample_fmt,<br>                                       input_codec_context-&gt;sample_rate,<br>                                       <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><h3 id="创建-avaudiofifo"><a class="markdownIt-Anchor" href="#创建-avaudiofifo"></a> <strong>创建 AVAudioFifo</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C">AVAudioFifo **fifo = 不能为空;<br>AVCodecContext *output_codec_context = 不能为空;<br><br>*fifo = av_audio_fifo_alloc(output_codec_context-&gt;sample_fmt,<br>                                      output_codec_context-&gt;channels, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h3 id="释放-avaudiofifo"><a class="markdownIt-Anchor" href="#释放-avaudiofifo"></a> <strong>释放 AVAudioFifo</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">AVAudioFifo *fifo = 不能为空;<br><br>av_audio_fifo_free(fifo);<br></code></pre></td></tr></table></figure><h3 id="获取可用的样本数"><a class="markdownIt-Anchor" href="#获取可用的样本数"></a> <strong>获取可用的样本数</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">AVAudioFifo *fifo = 不能为空;<br><br><span class="hljs-type">int</span> size = av_audio_fifo_size(fifo);<br></code></pre></td></tr></table></figure><h3 id="获取所需的内存-3"><a class="markdownIt-Anchor" href="#获取所需的内存-3"></a> <strong>获取所需的内存</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">uint8_t</span> ***converted_input_samples = 不能为空;<br>AVCodecContext *output_codec_context = 不能为空;<br><br>*converted_input_samples = (<span class="hljs-type">uint8_t</span> **) <span class="hljs-built_in">calloc</span>(output_codec_context-&gt;channels,<br>                                                         <span class="hljs-keyword">sizeof</span>(**converted_input_samples))<br></code></pre></td></tr></table></figure><h3 id="重新创建-avaudiofifo"><a class="markdownIt-Anchor" href="#重新创建-avaudiofifo"></a> <strong>重新创建 AVAudioFifo</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">AVAudioFifo *fifo = 不能为空;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> frame_size = 不能为空;<br><br><span class="hljs-type">int</span> error = av_audio_fifo_realloc(fifo, av_audio_fifo_size(fifo) + frame_size)<br></code></pre></td></tr></table></figure><h3 id="写数据到-avaudiofifo"><a class="markdownIt-Anchor" href="#写数据到-avaudiofifo"></a> <strong>写数据到 AVAudioFifo</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C">AVAudioFifo *fifo = 不能为空;<br><span class="hljs-type">uint8_t</span> **converted_input_samples = 不能为空;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> frame_size = 不能为空;<br><br><span class="hljs-type">int</span> size = av_audio_fifo_write(fifo, (<span class="hljs-type">void</span> **) converted_input_samples,<br>                            frame_size)<br></code></pre></td></tr></table></figure><h3 id="从-avaudiofifo-读数据"><a class="markdownIt-Anchor" href="#从-avaudiofifo-读数据"></a> <strong>从 AVAudioFifo 读数据</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C">AVAudioFifo *fifo = 不能为空;<br>AVFrame *output_frame = 不能为空;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> frame_size = 不能为空;<br><br><span class="hljs-type">int</span> size = av_audio_fifo_read(fifo, (<span class="hljs-type">void</span> **) output_frame-&gt;data, frame_size)<br></code></pre></td></tr></table></figure><h3 id="写数据到文件-2"><a class="markdownIt-Anchor" href="#写数据到文件-2"></a> <strong>写数据到文件</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">AVFormatContext *output_format_context = 不能为空;<br>AVPacket *output_packet = 不能为空;<br><br><span class="hljs-type">int</span> error = av_write_frame(output_format_context, output_packet);<br></code></pre></td></tr></table></figure><h2 id="transcoding"><a class="markdownIt-Anchor" href="#transcoding"></a> <strong>transcoding</strong></h2><blockquote><p>API example for demuxing, decoding, filtering, encoding and muxing</p></blockquote><p>用于解复用、解码、过滤、编码和复用的 API 示例</p><h3 id="获取-avrational"><a class="markdownIt-Anchor" href="#获取-avrational"></a> <strong>获取 AVRational</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> AVFormatContext *ifmt_ctx = 不能为空;<br>AVStream *stream = 不能为空;<br><br>AVRational rat = av_guess_frame_rate(ifmt_ctx, stream, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><h3 id="反转-avrational"><a class="markdownIt-Anchor" href="#反转-avrational"></a> <strong>反转 AVRational</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">AVCodecContext *dec_ctx = 不能为空;<br><br>AVRational rat = av_inv_q(dec_ctx-&gt;framerate);<br></code></pre></td></tr></table></figure><h3 id="获取所需的内存-4"><a class="markdownIt-Anchor" href="#获取所需的内存-4"></a> <strong>获取所需的内存</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> AVFormatContext *ifmt_ctx = 不能为空;<br><br><span class="hljs-type">static</span> FilteringContext *filter_ctx = (FilteringContext *) av_malloc_array(ifmt_ctx-&gt;nb_streams, <span class="hljs-keyword">sizeof</span>(*filter_ctx));<br></code></pre></td></tr></table></figure><h3 id="设置-avfiltercontext-的参数-2"><a class="markdownIt-Anchor" href="#设置-avfiltercontext-的参数-2"></a> <strong>设置 AVFilterContext 的参数</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C">AVFilterContext *buffersink_ctx = 不能为空;<br>AVCodecContext *enc_ctx = 不能为空;<br><br><span class="hljs-type">int</span> ret = av_opt_set_bin(buffersink_ctx, <span class="hljs-string">&quot;pix_fmts&quot;</span>,<br>                         (<span class="hljs-type">uint8_t</span> *) &amp;enc_ctx-&gt;pix_fmt, <span class="hljs-keyword">sizeof</span>(enc_ctx-&gt;pix_fmt),<br>                         AV_OPT_SEARCH_CHILDREN);<br></code></pre></td></tr></table></figure><h2 id="vaapi_encode"><a class="markdownIt-Anchor" href="#vaapi_encode"></a> <strong>vaapi_encode</strong></h2><blockquote><p>Intel VAAPI-accelerated encoding example.<br>This example shows how to do VAAPI-accelerated encoding. now only support NV12 raw file, usage like: vaapi_encode 1920 1080 input.yuv output.h264</p></blockquote><p>英特尔 VAAPI 加速编码示例。<br>这个例子展示了如何进行 VAAPI 加速编码。 现在只支持 NV12 原始文件，用法如：vaapi_encode 1920 1080 input.yuv output.h264</p><h3 id="创建-avhwframescontext"><a class="markdownIt-Anchor" href="#创建-avhwframescontext"></a> <strong>创建 AVHWFramesContext</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">AVBufferRef *hw_device_ctx = 不能为空;<br><br>AVBufferRef *hw_frames_ref = av_hwframe_ctx_alloc(hw_device_ctx);<br></code></pre></td></tr></table></figure><h3 id="初始化-avhwframescontext"><a class="markdownIt-Anchor" href="#初始化-avhwframescontext"></a> <strong>初始化 AVHWFramesContext</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">AVBufferRef *hw_frames_ref = 不能为空;<br><br><span class="hljs-type">int</span> err = av_hwframe_ctx_init(hw_frames_ref);<br></code></pre></td></tr></table></figure><h3 id="创建帧的缓冲区"><a class="markdownIt-Anchor" href="#创建帧的缓冲区"></a> <strong>创建帧的缓冲区</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C">AVCodecContext *avctx = 不能为空;<br>AVFrame *hw_frame = 不能为空;<br><br><span class="hljs-type">int</span> err = av_hwframe_get_buffer(avctx-&gt;hw_frames_ctx, hw_frame, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h2 id="vaapi_transcode"><a class="markdownIt-Anchor" href="#vaapi_transcode"></a> <strong>vaapi_transcode</strong></h2><blockquote><p>Intel VAAPI-accelerated transcoding example.<br>This example shows how to do VAAPI-accelerated transcoding.<br>Usage: vaapi_transcode input_stream codec output_stream<br>e.g: vaapi_transcode input.mp4 h264_vaapi output_h264.mp4<br>vaapi_transcode input.mp4 vp9_vaapi output_vp9.ivf<br>The output format is guessed according to the file extension.</p></blockquote><p>英特尔 VAAPI 加速转码示例。<br>这个例子展示了如何进行 VAAPI 加速的转码。<br>用法：vaapi_transcode input_stream codec output_stream<br>例如：vaapi_transcode input.mp4 h264_vaapi output_h264.mp4<br>vaapi_transcode input.mp4 vp9_vaapi output_vp9.ivf<br>根据文件扩展名猜测输出格式。</p><hr></div><hr><div><div class="post-metas my-3"></div><div class="license-box my-3"><div class="license-title"><div>FFmpeg Examples 涉及的 API</div><div>https://weichao.io/b2111a6fca0e/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>魏超</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2022年3月27日</div></div><div class="license-meta-item license-meta-date"><div>更新于</div><div>2022年12月4日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i> </span></a><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="NC - 非商业性使用"><i class="iconfont icon-nc"></i> </span></a><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><span class="hint--top hint--rounded" aria-label="SA - 相同方式共享"><i class="iconfont icon-sa"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/7e67a79aea20/" title="使用 QuMagie 管理 NAS 中的图片"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">使用 QuMagie 管理 NAS 中的图片</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/39f465f4ad80/" title="在 Android 上运行 FFmpeg Examples"><span class="hidden-mobile">在 Android 上运行 FFmpeg Examples</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><i class="iconfont icon-my-hexo"></i>&nbsp;<span>博客框架Hexo&nbsp;&nbsp;</span></a> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><i class="iconfont icon-my-theme"></i>&nbsp;<span>博客主题Fluid&nbsp;&nbsp;</span></a> <a href="https://weichao.io" target="_blank" rel="nofollow noopener"><i class="iconfont icon-my-copyright"></i>&nbsp;2023<span>魏超</span></a></div><div class="statistics"><span id="leancloud-site-pv-container" style="display:none">总访问量 <span id="leancloud-site-pv"></span> 次 </span><span id="leancloud-site-uv-container" style="display:none">总访客数 <span id="leancloud-site-uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script defer src="/js/leancloud.js"></script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>